<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>ES6标准入门（第三版） | WeiLoong&#39;s Notes</title>
    <meta name="generator" content="VuePress 1.5.3">
    <link rel="shortcut icon" type="image/x-icon" href="/note/favicon.ico">
    <link rel="manifest" href="/note/manifest.json">
    <meta name="description" content="wei loong FULL STACK, Node, JavaScript">
    <link rel="preload" href="/note/assets/css/0.styles.ff9ba36c.css" as="style"><link rel="preload" href="/note/assets/js/app.492a4f88.js" as="script"><link rel="preload" href="/note/assets/js/2.7a960a6a.js" as="script"><link rel="preload" href="/note/assets/js/6.c5848a03.js" as="script"><link rel="preload" href="/note/assets/js/3.ededa1a2.js" as="script"><link rel="prefetch" href="/note/assets/js/10.2622995d.js"><link rel="prefetch" href="/note/assets/js/11.9f956728.js"><link rel="prefetch" href="/note/assets/js/12.1cb194a0.js"><link rel="prefetch" href="/note/assets/js/13.928d70c1.js"><link rel="prefetch" href="/note/assets/js/14.8a455de1.js"><link rel="prefetch" href="/note/assets/js/15.585e7a9a.js"><link rel="prefetch" href="/note/assets/js/16.0be4655f.js"><link rel="prefetch" href="/note/assets/js/17.0a38b819.js"><link rel="prefetch" href="/note/assets/js/18.fc9e43b4.js"><link rel="prefetch" href="/note/assets/js/19.b8e384b2.js"><link rel="prefetch" href="/note/assets/js/20.2c831812.js"><link rel="prefetch" href="/note/assets/js/21.a5321a89.js"><link rel="prefetch" href="/note/assets/js/22.b65d4093.js"><link rel="prefetch" href="/note/assets/js/23.d262cf87.js"><link rel="prefetch" href="/note/assets/js/24.cac54fd7.js"><link rel="prefetch" href="/note/assets/js/25.b0a8251d.js"><link rel="prefetch" href="/note/assets/js/26.36797c5e.js"><link rel="prefetch" href="/note/assets/js/27.077dde45.js"><link rel="prefetch" href="/note/assets/js/28.0cec50b9.js"><link rel="prefetch" href="/note/assets/js/29.91e862b6.js"><link rel="prefetch" href="/note/assets/js/30.024d811c.js"><link rel="prefetch" href="/note/assets/js/31.d25ca2c6.js"><link rel="prefetch" href="/note/assets/js/32.011c4e75.js"><link rel="prefetch" href="/note/assets/js/33.614570f2.js"><link rel="prefetch" href="/note/assets/js/34.c9897c33.js"><link rel="prefetch" href="/note/assets/js/35.4ed26875.js"><link rel="prefetch" href="/note/assets/js/36.927bc12a.js"><link rel="prefetch" href="/note/assets/js/37.c29adea3.js"><link rel="prefetch" href="/note/assets/js/38.78518438.js"><link rel="prefetch" href="/note/assets/js/4.b4907637.js"><link rel="prefetch" href="/note/assets/js/5.ff2c26d6.js"><link rel="prefetch" href="/note/assets/js/7.f76b479f.js"><link rel="prefetch" href="/note/assets/js/8.cd7b7e77.js"><link rel="prefetch" href="/note/assets/js/9.0783b7e1.js">
    <link rel="stylesheet" href="/note/assets/css/0.styles.ff9ba36c.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container"><header class="navbar"><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/note/" class="home-link router-link-active"><img src="/note/avatar.png" alt="WeiLoong's Notes" class="logo"> <span class="site-name can-hide">WeiLoong's Notes</span></a> <div class="links"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <nav class="nav-links can-hide"><div class="nav-item"><a href="/note/" class="nav-link">
  Home
</a></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="FrontEnd" class="dropdown-title"><span class="title">FrontEnd</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/note/JavaScript_FrontEnd/" class="nav-link">
  JavaScript
</a></li><li class="dropdown-item"><!----> <a href="/note/React_FrontEnd/" class="nav-link">
  React
</a></li><li class="dropdown-item"><!----> <a href="/note/TypeScript_FrontEnd/" class="nav-link">
  TypeScript
</a></li><li class="dropdown-item"><!----> <a href="/note/Vue_FrontEnd/" class="nav-link">
  Vue
</a></li></ul></div></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="BackEnd" class="dropdown-title"><span class="title">BackEnd</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/note/Koa_BackEnd/" class="nav-link">
  Koa
</a></li><li class="dropdown-item"><!----> <a href="/note/MySQL_BackEnd/" class="nav-link">
  MySQL
</a></li><li class="dropdown-item"><!----> <a href="/note/Nginx_BackEnd/" class="nav-link">
  Nginx
</a></li><li class="dropdown-item"><!----> <a href="/note/NodeJS_BackEnd/" class="nav-link">
  NodeJS
</a></li></ul></div></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="System" class="dropdown-title"><span class="title">System</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/note/Linux_System/" class="nav-link">
  Linux
</a></li></ul></div></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="DevTools" class="dropdown-title"><span class="title">DevTools</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/note/Git_DevTools/" class="nav-link">
  Git
</a></li><li class="dropdown-item"><!----> <a href="/note/Jenkins_DevTools/" class="nav-link">
  Jenkins
</a></li><li class="dropdown-item"><!----> <a href="/note/Webpack_DevTools/" class="nav-link">
  Webpack
</a></li></ul></div></div> <!----></nav></div></header> <div class="sidebar-mask"></div> <aside class="sidebar"><nav class="nav-links"><div class="nav-item"><a href="/note/" class="nav-link">
  Home
</a></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="FrontEnd" class="dropdown-title"><span class="title">FrontEnd</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/note/JavaScript_FrontEnd/" class="nav-link">
  JavaScript
</a></li><li class="dropdown-item"><!----> <a href="/note/React_FrontEnd/" class="nav-link">
  React
</a></li><li class="dropdown-item"><!----> <a href="/note/TypeScript_FrontEnd/" class="nav-link">
  TypeScript
</a></li><li class="dropdown-item"><!----> <a href="/note/Vue_FrontEnd/" class="nav-link">
  Vue
</a></li></ul></div></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="BackEnd" class="dropdown-title"><span class="title">BackEnd</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/note/Koa_BackEnd/" class="nav-link">
  Koa
</a></li><li class="dropdown-item"><!----> <a href="/note/MySQL_BackEnd/" class="nav-link">
  MySQL
</a></li><li class="dropdown-item"><!----> <a href="/note/Nginx_BackEnd/" class="nav-link">
  Nginx
</a></li><li class="dropdown-item"><!----> <a href="/note/NodeJS_BackEnd/" class="nav-link">
  NodeJS
</a></li></ul></div></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="System" class="dropdown-title"><span class="title">System</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/note/Linux_System/" class="nav-link">
  Linux
</a></li></ul></div></div><div class="nav-item"><div class="dropdown-wrapper"><button type="button" aria-label="DevTools" class="dropdown-title"><span class="title">DevTools</span> <span class="arrow right"></span></button> <ul class="nav-dropdown" style="display:none;"><li class="dropdown-item"><!----> <a href="/note/Git_DevTools/" class="nav-link">
  Git
</a></li><li class="dropdown-item"><!----> <a href="/note/Jenkins_DevTools/" class="nav-link">
  Jenkins
</a></li><li class="dropdown-item"><!----> <a href="/note/Webpack_DevTools/" class="nav-link">
  Webpack
</a></li></ul></div></div> <!----></nav>  <ul class="sidebar-links"><li><a href="/note/ES6标准入门/ES6.html" class="active sidebar-link">ES6标准入门（第三版）</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/note/ES6标准入门/ES6.html#es6-环境配置" class="sidebar-link">ES6 环境配置</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/note/ES6标准入门/ES6.html#配置环境" class="sidebar-link">配置环境</a></li></ul></li><li class="sidebar-sub-header"><a href="/note/ES6标准入门/ES6.html#let-和-const" class="sidebar-link">let 和 const</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/note/ES6标准入门/ES6.html#let" class="sidebar-link">let</a></li><li class="sidebar-sub-header"><a href="/note/ES6标准入门/ES6.html#const" class="sidebar-link">const</a></li><li class="sidebar-sub-header"><a href="/note/ES6标准入门/ES6.html#顶层对象" class="sidebar-link">顶层对象</a></li></ul></li><li class="sidebar-sub-header"><a href="/note/ES6标准入门/ES6.html#变量结构赋值" class="sidebar-link">变量结构赋值</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/note/ES6标准入门/ES6.html#数组的解构赋值" class="sidebar-link">数组的解构赋值</a></li><li class="sidebar-sub-header"><a href="/note/ES6标准入门/ES6.html#对象的解构赋值" class="sidebar-link">对象的解构赋值</a></li><li class="sidebar-sub-header"><a href="/note/ES6标准入门/ES6.html#字符串的解构赋值" class="sidebar-link">字符串的解构赋值</a></li><li class="sidebar-sub-header"><a href="/note/ES6标准入门/ES6.html#数值和布尔值的解构赋值" class="sidebar-link">数值和布尔值的解构赋值</a></li><li class="sidebar-sub-header"><a href="/note/ES6标准入门/ES6.html#函数参数的解构赋值" class="sidebar-link">函数参数的解构赋值</a></li></ul></li><li class="sidebar-sub-header"><a href="/note/ES6标准入门/ES6.html#字符串扩展" class="sidebar-link">字符串扩展</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/note/ES6标准入门/ES6.html#字符的unicode-表示法" class="sidebar-link">字符的Unicode 表示法</a></li><li class="sidebar-sub-header"><a href="/note/ES6标准入门/ES6.html#字符串的遍历接口" class="sidebar-link">字符串的遍历接口</a></li><li class="sidebar-sub-header"><a href="/note/ES6标准入门/ES6.html#直接输入u-20208、u-2029" class="sidebar-link">直接输入U+20208、U+2029</a></li><li class="sidebar-sub-header"><a href="/note/ES6标准入门/ES6.html#json-stringify-的改造" class="sidebar-link">JSON.stringify()的改造</a></li><li class="sidebar-sub-header"><a href="/note/ES6标准入门/ES6.html#模板字符串" class="sidebar-link">模板字符串</a></li></ul></li><li class="sidebar-sub-header"><a href="/note/ES6标准入门/ES6.html#字符串新增方法" class="sidebar-link">字符串新增方法</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/note/ES6标准入门/ES6.html#string-fromcodepoint" class="sidebar-link">String.fromCodePoint()</a></li><li class="sidebar-sub-header"><a href="/note/ES6标准入门/ES6.html#string-raw" class="sidebar-link">String.raw()</a></li><li class="sidebar-sub-header"><a href="/note/ES6标准入门/ES6.html#codepointat" class="sidebar-link">codePointAt()</a></li><li class="sidebar-sub-header"><a href="/note/ES6标准入门/ES6.html#normalize" class="sidebar-link">normalize()</a></li><li class="sidebar-sub-header"><a href="/note/ES6标准入门/ES6.html#includes-startswith-endswith" class="sidebar-link">includes(), startsWith(), endsWith()</a></li><li class="sidebar-sub-header"><a href="/note/ES6标准入门/ES6.html#repeat" class="sidebar-link">repeat()</a></li><li class="sidebar-sub-header"><a href="/note/ES6标准入门/ES6.html#padstart-padend" class="sidebar-link">padStart, padEnd()</a></li><li class="sidebar-sub-header"><a href="/note/ES6标准入门/ES6.html#trimstart-trimend" class="sidebar-link">trimStart(), trimEnd()</a></li><li class="sidebar-sub-header"><a href="/note/ES6标准入门/ES6.html#matchall" class="sidebar-link">matchAll()</a></li></ul></li><li class="sidebar-sub-header"><a href="/note/ES6标准入门/ES6.html#正则扩展" class="sidebar-link">*正则扩展</a></li><li class="sidebar-sub-header"><a href="/note/ES6标准入门/ES6.html#数值扩展" class="sidebar-link">数值扩展</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/note/ES6标准入门/ES6.html#math对象的扩展" class="sidebar-link">Math对象的扩展</a></li><li class="sidebar-sub-header"><a href="/note/ES6标准入门/ES6.html#bigint数据类型" class="sidebar-link">BigInt数据类型</a></li></ul></li><li class="sidebar-sub-header"><a href="/note/ES6标准入门/ES6.html#函数的扩展" class="sidebar-link">函数的扩展</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/note/ES6标准入门/ES6.html#函数参数的默认值" class="sidebar-link">函数参数的默认值</a></li><li class="sidebar-sub-header"><a href="/note/ES6标准入门/ES6.html#rest参数" class="sidebar-link">rest参数</a></li><li class="sidebar-sub-header"><a href="/note/ES6标准入门/ES6.html#严格模式" class="sidebar-link">严格模式</a></li><li class="sidebar-sub-header"><a href="/note/ES6标准入门/ES6.html#name属性" class="sidebar-link">name属性</a></li><li class="sidebar-sub-header"><a href="/note/ES6标准入门/ES6.html#箭头函数" class="sidebar-link">箭头函数</a></li><li class="sidebar-sub-header"><a href="/note/ES6标准入门/ES6.html#尾调优化" class="sidebar-link">尾调优化</a></li><li class="sidebar-sub-header"><a href="/note/ES6标准入门/ES6.html#function-prototype-tostring" class="sidebar-link">Function.prototype.toString()</a></li><li class="sidebar-sub-header"><a href="/note/ES6标准入门/ES6.html#catch命令的参数省略" class="sidebar-link">catch命令的参数省略</a></li></ul></li><li class="sidebar-sub-header"><a href="/note/ES6标准入门/ES6.html#数组的扩展" class="sidebar-link">数组的扩展</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/note/ES6标准入门/ES6.html#array-from" class="sidebar-link">Array.from()</a></li><li class="sidebar-sub-header"><a href="/note/ES6标准入门/ES6.html#array-of" class="sidebar-link">Array.of()</a></li><li class="sidebar-sub-header"><a href="/note/ES6标准入门/ES6.html#数组实例的copywithin" class="sidebar-link">数组实例的copyWithin()</a></li><li class="sidebar-sub-header"><a href="/note/ES6标准入门/ES6.html#数组实例-find-和-findindex" class="sidebar-link">数组实例 find() 和 findIndex()</a></li><li class="sidebar-sub-header"><a href="/note/ES6标准入门/ES6.html#数组实例fill" class="sidebar-link">数组实例fill()</a></li><li class="sidebar-sub-header"><a href="/note/ES6标准入门/ES6.html#数组实例entries-keys-values" class="sidebar-link">数组实例entries(),keys(),values()</a></li><li class="sidebar-sub-header"><a href="/note/ES6标准入门/ES6.html#数组实例inclides" class="sidebar-link">数组实例inclides()</a></li><li class="sidebar-sub-header"><a href="/note/ES6标准入门/ES6.html#数组实例flat-、flatmap" class="sidebar-link">数组实例flat()、flatMap()</a></li><li class="sidebar-sub-header"><a href="/note/ES6标准入门/ES6.html#数组空位" class="sidebar-link">数组空位</a></li><li class="sidebar-sub-header"><a href="/note/ES6标准入门/ES6.html#array-prototype-sort-的排序稳定性" class="sidebar-link">Array.prototype.sort()的排序稳定性</a></li></ul></li><li class="sidebar-sub-header"><a href="/note/ES6标准入门/ES6.html#对象的扩展" class="sidebar-link">对象的扩展</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/note/ES6标准入门/ES6.html#属性的简洁表示法" class="sidebar-link">属性的简洁表示法</a></li><li class="sidebar-sub-header"><a href="/note/ES6标准入门/ES6.html#属性名表达式" class="sidebar-link">属性名表达式</a></li><li class="sidebar-sub-header"><a href="/note/ES6标准入门/ES6.html#方法name属性" class="sidebar-link">方法name属性</a></li><li class="sidebar-sub-header"><a href="/note/ES6标准入门/ES6.html#属性的可枚举性和遍历" class="sidebar-link">属性的可枚举性和遍历</a></li><li class="sidebar-sub-header"><a href="/note/ES6标准入门/ES6.html#super关键字" class="sidebar-link">super关键字</a></li><li class="sidebar-sub-header"><a href="/note/ES6标准入门/ES6.html#对象的扩展运算符" class="sidebar-link">对象的扩展运算符</a></li><li class="sidebar-sub-header"><a href="/note/ES6标准入门/ES6.html#链判断运算符" class="sidebar-link">链判断运算符</a></li><li class="sidebar-sub-header"><a href="/note/ES6标准入门/ES6.html#null判断运算符" class="sidebar-link">Null判断运算符</a></li></ul></li><li class="sidebar-sub-header"><a href="/note/ES6标准入门/ES6.html#对象的新增方法" class="sidebar-link">对象的新增方法</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/note/ES6标准入门/ES6.html#object-is" class="sidebar-link">Object.is()</a></li><li class="sidebar-sub-header"><a href="/note/ES6标准入门/ES6.html#object-assign" class="sidebar-link">Object.assign()</a></li><li class="sidebar-sub-header"><a href="/note/ES6标准入门/ES6.html#object-getownpropertydescriptors" class="sidebar-link">Object.getOwnPropertyDescriptors()</a></li><li class="sidebar-sub-header"><a href="/note/ES6标准入门/ES6.html#proto-属性，object-setprototypeof-object-getprototypeof" class="sidebar-link">__proto__属性，Object.setPrototypeOf(),Object.getPrototypeOf()</a></li><li class="sidebar-sub-header"><a href="/note/ES6标准入门/ES6.html#object-keys-object-values-object-entries" class="sidebar-link">Object.keys(), Object.values(), Object.entries()</a></li></ul></li><li class="sidebar-sub-header"><a href="/note/ES6标准入门/ES6.html#symbol" class="sidebar-link">Symbol</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/note/ES6标准入门/ES6.html#symbol-prototype-description" class="sidebar-link">Symbol.prototype.description</a></li><li class="sidebar-sub-header"><a href="/note/ES6标准入门/ES6.html#作为属性名的symbol" class="sidebar-link">作为属性名的Symbol</a></li><li class="sidebar-sub-header"><a href="/note/ES6标准入门/ES6.html#消除魔术字符串" class="sidebar-link">消除魔术字符串</a></li><li class="sidebar-sub-header"><a href="/note/ES6标准入门/ES6.html#属性的遍历" class="sidebar-link">属性的遍历</a></li><li class="sidebar-sub-header"><a href="/note/ES6标准入门/ES6.html#symbol-for-，symbol-keyfor" class="sidebar-link">Symbol.for()，Symbol.keyFor()</a></li><li class="sidebar-sub-header"><a href="/note/ES6标准入门/ES6.html#模块的singleton模式" class="sidebar-link">模块的Singleton模式</a></li><li class="sidebar-sub-header"><a href="/note/ES6标准入门/ES6.html#内置symbol值" class="sidebar-link">内置Symbol值</a></li></ul></li><li class="sidebar-sub-header"><a href="/note/ES6标准入门/ES6.html#set和map数据结构" class="sidebar-link">Set和Map数据结构</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/note/ES6标准入门/ES6.html#set" class="sidebar-link">Set</a></li><li class="sidebar-sub-header"><a href="/note/ES6标准入门/ES6.html#weakset" class="sidebar-link">WeakSet</a></li><li class="sidebar-sub-header"><a href="/note/ES6标准入门/ES6.html#map" class="sidebar-link">Map</a></li><li class="sidebar-sub-header"><a href="/note/ES6标准入门/ES6.html#weakmap" class="sidebar-link">WeakMap</a></li></ul></li><li class="sidebar-sub-header"><a href="/note/ES6标准入门/ES6.html#proxy" class="sidebar-link">Proxy</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/note/ES6标准入门/ES6.html#proxy实例方法" class="sidebar-link">Proxy实例方法</a></li><li class="sidebar-sub-header"><a href="/note/ES6标准入门/ES6.html#proxy-revocable" class="sidebar-link">Proxy.revocable()</a></li><li class="sidebar-sub-header"><a href="/note/ES6标准入门/ES6.html#this问题" class="sidebar-link">this问题</a></li><li class="sidebar-sub-header"><a href="/note/ES6标准入门/ES6.html#web服务客户端" class="sidebar-link">Web服务客户端</a></li></ul></li><li class="sidebar-sub-header"><a href="/note/ES6标准入门/ES6.html#reflect" class="sidebar-link">Reflect</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/note/ES6标准入门/ES6.html#静态方法" class="sidebar-link">静态方法</a></li><li class="sidebar-sub-header"><a href="/note/ES6标准入门/ES6.html#使用proxy实现观察者模式" class="sidebar-link">使用Proxy实现观察者模式</a></li></ul></li><li class="sidebar-sub-header"><a href="/note/ES6标准入门/ES6.html#promise对象" class="sidebar-link">Promise对象</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/note/ES6标准入门/ES6.html#基本用法" class="sidebar-link">基本用法</a></li><li class="sidebar-sub-header"><a href="/note/ES6标准入门/ES6.html#promise-prototype-then" class="sidebar-link">Promise.prototype.then()</a></li><li class="sidebar-sub-header"><a href="/note/ES6标准入门/ES6.html#promise-prototype-catch" class="sidebar-link">Promise.prototype.catch()</a></li><li class="sidebar-sub-header"><a href="/note/ES6标准入门/ES6.html#promise-prototype-finally" class="sidebar-link">Promise.prototype.finally()</a></li><li class="sidebar-sub-header"><a href="/note/ES6标准入门/ES6.html#promise-all" class="sidebar-link">Promise.all()</a></li><li class="sidebar-sub-header"><a href="/note/ES6标准入门/ES6.html#promise-race" class="sidebar-link">Promise.race()</a></li><li class="sidebar-sub-header"><a href="/note/ES6标准入门/ES6.html#promise-allsettled" class="sidebar-link">Promise.allSettled()</a></li><li class="sidebar-sub-header"><a href="/note/ES6标准入门/ES6.html#promise-any" class="sidebar-link">Promise.any()</a></li><li class="sidebar-sub-header"><a href="/note/ES6标准入门/ES6.html#promise-resolve" class="sidebar-link">Promise.resolve()</a></li><li class="sidebar-sub-header"><a href="/note/ES6标准入门/ES6.html#promise-reject" class="sidebar-link">Promise.reject()</a></li><li class="sidebar-sub-header"><a href="/note/ES6标准入门/ES6.html#应用" class="sidebar-link">应用</a></li><li class="sidebar-sub-header"><a href="/note/ES6标准入门/ES6.html#promise-try" class="sidebar-link">Promise.try()</a></li></ul></li><li class="sidebar-sub-header"><a href="/note/ES6标准入门/ES6.html#iterator和for-of循环" class="sidebar-link">Iterator和for...of循环</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/note/ES6标准入门/ES6.html#默认iterator接口" class="sidebar-link">默认Iterator接口</a></li><li class="sidebar-sub-header"><a href="/note/ES6标准入门/ES6.html#调用iterator接口场合" class="sidebar-link">调用Iterator接口场合</a></li><li class="sidebar-sub-header"><a href="/note/ES6标准入门/ES6.html#字符串iterator接口" class="sidebar-link">字符串Iterator接口</a></li><li class="sidebar-sub-header"><a href="/note/ES6标准入门/ES6.html#iterator接口与generator函数" class="sidebar-link">Iterator接口与Generator函数</a></li><li class="sidebar-sub-header"><a href="/note/ES6标准入门/ES6.html#遍历对象的-return-throw" class="sidebar-link">遍历对象的 return(), throw()</a></li><li class="sidebar-sub-header"><a href="/note/ES6标准入门/ES6.html#for-of循环" class="sidebar-link">for...of循环</a></li></ul></li><li class="sidebar-sub-header"><a href="/note/ES6标准入门/ES6.html#generator-函数的语法" class="sidebar-link">Generator 函数的语法</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/note/ES6标准入门/ES6.html#yield表达式" class="sidebar-link">yield表达式</a></li><li class="sidebar-sub-header"><a href="/note/ES6标准入门/ES6.html#next方法的参数" class="sidebar-link">next方法的参数</a></li><li class="sidebar-sub-header"><a href="/note/ES6标准入门/ES6.html#for-of循环-2" class="sidebar-link">for...of循环</a></li><li class="sidebar-sub-header"><a href="/note/ES6标准入门/ES6.html#generator-prototype-throw" class="sidebar-link">Generator.prototype.throw()</a></li><li class="sidebar-sub-header"><a href="/note/ES6标准入门/ES6.html#generator-prototype-return" class="sidebar-link">Generator.prototype.return()</a></li><li class="sidebar-sub-header"><a href="/note/ES6标准入门/ES6.html#next、throw、return的共同点" class="sidebar-link">next、throw、return的共同点</a></li><li class="sidebar-sub-header"><a href="/note/ES6标准入门/ES6.html#yield-表达式" class="sidebar-link">yield* 表达式</a></li><li class="sidebar-sub-header"><a href="/note/ES6标准入门/ES6.html#作为对象属性的generator函数" class="sidebar-link">作为对象属性的Generator函数</a></li><li class="sidebar-sub-header"><a href="/note/ES6标准入门/ES6.html#generator函数的this" class="sidebar-link">Generator函数的this</a></li><li class="sidebar-sub-header"><a href="/note/ES6标准入门/ES6.html#generator与状态机" class="sidebar-link">Generator与状态机</a></li><li class="sidebar-sub-header"><a href="/note/ES6标准入门/ES6.html#应用-2" class="sidebar-link">应用</a></li></ul></li><li class="sidebar-sub-header"><a href="/note/ES6标准入门/ES6.html#generator函数的异步应用" class="sidebar-link">Generator函数的异步应用</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/note/ES6标准入门/ES6.html#基本概念" class="sidebar-link">基本概念</a></li><li class="sidebar-sub-header"><a href="/note/ES6标准入门/ES6.html#generator函数" class="sidebar-link">Generator函数</a></li><li class="sidebar-sub-header"><a href="/note/ES6标准入门/ES6.html#thunk函数" class="sidebar-link">Thunk函数</a></li><li class="sidebar-sub-header"><a href="/note/ES6标准入门/ES6.html#co模块" class="sidebar-link">co模块</a></li><li class="sidebar-sub-header"><a href="/note/ES6标准入门/ES6.html#co模块的源码" class="sidebar-link">co模块的源码</a></li></ul></li><li class="sidebar-sub-header"><a href="/note/ES6标准入门/ES6.html#async函数" class="sidebar-link">async函数</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/note/ES6标准入门/ES6.html#基本用法-2" class="sidebar-link">基本用法</a></li><li class="sidebar-sub-header"><a href="/note/ES6标准入门/ES6.html#async语法" class="sidebar-link">async语法</a></li><li class="sidebar-sub-header"><a href="/note/ES6标准入门/ES6.html#async函数实现原理" class="sidebar-link">async函数实现原理</a></li><li class="sidebar-sub-header"><a href="/note/ES6标准入门/ES6.html#按顺序完成异步操作" class="sidebar-link">按顺序完成异步操作</a></li></ul></li><li class="sidebar-sub-header"><a href="/note/ES6标准入门/ES6.html#class-的基本语法" class="sidebar-link">Class 的基本语法</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/note/ES6标准入门/ES6.html#简介" class="sidebar-link">简介</a></li><li class="sidebar-sub-header"><a href="/note/ES6标准入门/ES6.html#静态方法-2" class="sidebar-link">静态方法</a></li><li class="sidebar-sub-header"><a href="/note/ES6标准入门/ES6.html#实例属性的新写法" class="sidebar-link">实例属性的新写法</a></li><li class="sidebar-sub-header"><a href="/note/ES6标准入门/ES6.html#静态属性" class="sidebar-link">静态属性</a></li><li class="sidebar-sub-header"><a href="/note/ES6标准入门/ES6.html#私有方法和私有属性" class="sidebar-link">私有方法和私有属性</a></li><li class="sidebar-sub-header"><a href="/note/ES6标准入门/ES6.html#new-target属性" class="sidebar-link">new.target属性</a></li></ul></li><li class="sidebar-sub-header"><a href="/note/ES6标准入门/ES6.html#class的继承" class="sidebar-link">Class的继承</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/note/ES6标准入门/ES6.html#object-getprototypeof" class="sidebar-link">Object.getPrototypeOf()</a></li><li class="sidebar-sub-header"><a href="/note/ES6标准入门/ES6.html#super关键字-2" class="sidebar-link">super关键字</a></li><li class="sidebar-sub-header"><a href="/note/ES6标准入门/ES6.html#类的prototype属性和-proto-属性" class="sidebar-link">类的prototype属性和__proto__属性</a></li><li class="sidebar-sub-header"><a href="/note/ES6标准入门/ES6.html#实例的-proto-属性" class="sidebar-link">实例的__proto__属性</a></li><li class="sidebar-sub-header"><a href="/note/ES6标准入门/ES6.html#原生构造函数的继承" class="sidebar-link">原生构造函数的继承</a></li><li class="sidebar-sub-header"><a href="/note/ES6标准入门/ES6.html#mixin模式的实现" class="sidebar-link">Mixin模式的实现</a></li></ul></li><li class="sidebar-sub-header"><a href="/note/ES6标准入门/ES6.html#module的语法" class="sidebar-link">Module的语法</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/note/ES6标准入门/ES6.html#严格模式-2" class="sidebar-link">严格模式</a></li><li class="sidebar-sub-header"><a href="/note/ES6标准入门/ES6.html#export-命令" class="sidebar-link">export 命令</a></li><li class="sidebar-sub-header"><a href="/note/ES6标准入门/ES6.html#import命令" class="sidebar-link">import命令</a></li><li class="sidebar-sub-header"><a href="/note/ES6标准入门/ES6.html#模块的整体加载" class="sidebar-link">模块的整体加载</a></li><li class="sidebar-sub-header"><a href="/note/ES6标准入门/ES6.html#export-default命令" class="sidebar-link">export default命令</a></li><li class="sidebar-sub-header"><a href="/note/ES6标准入门/ES6.html#export-和-import的复合写法" class="sidebar-link">export 和 import的复合写法</a></li><li class="sidebar-sub-header"><a href="/note/ES6标准入门/ES6.html#模块的继承" class="sidebar-link">模块的继承</a></li><li class="sidebar-sub-header"><a href="/note/ES6标准入门/ES6.html#跨模块常量" class="sidebar-link">跨模块常量</a></li><li class="sidebar-sub-header"><a href="/note/ES6标准入门/ES6.html#import" class="sidebar-link">import()</a></li></ul></li><li class="sidebar-sub-header"><a href="/note/ES6标准入门/ES6.html#module的加载实现" class="sidebar-link">Module的加载实现</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/note/ES6标准入门/ES6.html#es6模块和commonjs模块的差异" class="sidebar-link">ES6模块和CommonJS模块的差异</a></li><li class="sidebar-sub-header"><a href="/note/ES6标准入门/ES6.html#nodejs加载" class="sidebar-link">NodeJS加载</a></li><li class="sidebar-sub-header"><a href="/note/ES6标准入门/ES6.html#循环加载" class="sidebar-link">循环加载</a></li></ul></li></ul></li></ul> </aside> <main class="page"> <div class="theme-default-content content__default"><h1 id="es6标准入门（第三版）"><a href="#es6标准入门（第三版）" class="header-anchor">#</a> ES6标准入门（第三版）</h1> <h2 id="es6-环境配置"><a href="#es6-环境配置" class="header-anchor">#</a> ES6 环境配置</h2> <p>ES6、7、8、9的代码需要转为ES5，才能在老版本的浏览器上执行。Babel是一个广泛使用的转码器。</p> <h3 id="配置环境"><a href="#配置环境" class="header-anchor">#</a> 配置环境</h3> <p>需要在项目目录中，安装Babel</p> <div class="language-shell extra-class"><pre class="language-shell"><code><span class="token function">npm</span> <span class="token function">install</span> @babel/core --save-dev
</code></pre></div><p>配置.babelrc文件，存放在项目的根目录下</p> <div class="language-json extra-class"><pre class="language-json"><code><span class="token punctuation">{</span>
  <span class="token property">&quot;presets&quot;</span><span class="token operator">:</span> <span class="token punctuation">[</span>
    <span class="token string">&quot;@babel/env&quot;</span><span class="token punctuation">,</span>
    <span class="token string">&quot;@bebel/preset-react&quot;</span>
  <span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token comment">//presets字段设定转码规则，官方提供规则集，根据需要安装</span>
  <span class="token property">&quot;plugins&quot;</span><span class="token operator">:</span><span class="token punctuation">[</span><span class="token punctuation">]</span>
<span class="token punctuation">}</span>
</code></pre></div><div class="language-shell extra-class"><pre class="language-shell"><code><span class="token comment">#安装官方规则集</span>
<span class="token comment">#最新转码规则</span>
<span class="token function">npm</span> <span class="token function">install</span> --save-dev @babel/preset-env
<span class="token comment">#react转码规则</span>
<span class="token function">npm</span> installl --save-dev @babel/preset-react
<span class="token comment">#typescript</span>
<span class="token function">npm</span> <span class="token function">install</span> --save-dev @babel/preset-typescript
</code></pre></div><p>@babel/node支持babel-node命令，提供一个支持ES6的REPL环境。</p> <p>@babel/register模块改写了require命令，为它加上一个钩子，当加载.js/.jsx/.es./es6都会先用Babel进行转码。</p> <p><strong>polyfill</strong></p> <p>Babel默认只转换新的句法（Syntax），不会转换新的API，所以需要为当前环境提供一个垫片。</p> <p>新的API有Iterator、Generator、Set、Map、Proxy、Reflect、Symbol、Promise等全局对象。</p> <div class="language-shell extra-class"><pre class="language-shell"><code><span class="token function">npm</span> <span class="token function">install</span> --save @babel/polyfill
</code></pre></div><p><a href="https://www.babeljs.cn/docs/" target="_blank" rel="noopener noreferrer">Babel官方文档<svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a></p> <h2 id="let-和-const"><a href="#let-和-const" class="header-anchor">#</a> let 和 const</h2> <h3 id="let"><a href="#let" class="header-anchor">#</a> let</h3> <p>let命令用来声明变量，所声明的变量只在let命令所在的代码块内有效。允许你声明一个作用域被限制在 <a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/statements/block" target="_blank" rel="noopener noreferrer"><code>块</code><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg></a>级中的变量、语句或者表达式</p> <div class="language-javascript extra-class"><pre class="language-javascript"><code><span class="token punctuation">{</span>
  <span class="token keyword">let</span> a <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>
  <span class="token keyword">var</span> b <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token comment">//代码块外不能访问let声明的变量，但是var声明的变量可以被访问</span>
</code></pre></div><blockquote><p>let是否存在变量提升？</p> <p>个人认为存在变量提升，但是由于暂时性死区，所以let之前使用变量都属于'死区'，本质就是进入当前作用域，使用的变量已经存在，但是不可获取，只有等到声明变量那一行代码出现，才可以获取和使用变量。</p> <div class="language-javascript extra-class"><pre class="language-javascript"><code><span class="token keyword">if</span><span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
  temp <span class="token operator">=</span> <span class="token string">'abc'</span><span class="token punctuation">;</span> <span class="token comment">//ReferenceError</span>
  <span class="token keyword">let</span> temp<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div></blockquote> <p>ES6的块级作用域中，明确了块级作用域中可以声明函数。</p> <p>函数的声明类似于let，对作用域之外的没有影响。（对旧代码印象很大，由于改变了块级作用域内声明函数的处理规则，所以在浏览器环境中，块级作用域内声明函数类似于var）</p> <blockquote><p>在浏览器中有自己的行为方式：</p> <ul><li>允许在块级作用域内声明函数</li> <li>函数声明类似于var，即会提升到全局作用域或函数作用域头部</li> <li>函数声明提升到到所在块级作用域的头部</li></ul></blockquote> <div class="language-javascript extra-class"><pre class="language-javascript"><code><span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
    <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token boolean">false</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
        <span class="token keyword">function</span> <span class="token function">fn</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
    <span class="token function">fn</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token comment">//ES6环境实际执行：</span>
<span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
  <span class="token keyword">var</span> fn <span class="token operator">=</span> <span class="token keyword">undefined</span><span class="token punctuation">;</span>
  <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token boolean">false</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
		<span class="token function-variable function">fn</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">}</span>
  <span class="token punctuation">}</span>
  <span class="token function">fn</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//Type Error,fn is not function</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
</code></pre></div><p>所以，避免在块作用域内声明函数，如果确实需要，可以使用函数表达式。</p> <p>ES6的块作用域允许声明函数的规则只在使用大括号的情况下成立，没有大括号就不成立。</p> <h3 id="const"><a href="#const" class="header-anchor">#</a> const</h3> <p>const声明一个只读的常量，一旦声明，必须立即初始化，常量的值不可改变。</p> <p>const也存在暂时性死区，只能在声明之后使用。</p> <p>const本质是变量指向的那个内存地址不得改变。</p> <p>所以，如果想冻结对象，可以勇士Object.freeze()</p> <div class="language-javascript extra-class"><pre class="language-javascript"><code><span class="token keyword">var</span> <span class="token function-variable function">constantize</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token parameter">obj</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
  Object<span class="token punctuation">.</span><span class="token function">freeze</span><span class="token punctuation">(</span>obj<span class="token punctuation">)</span><span class="token punctuation">;</span>
  Object<span class="token punctuation">.</span><span class="token function">keys</span><span class="token punctuation">(</span>obj<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">forEach</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token parameter">key<span class="token punctuation">,</span>i</span><span class="token punctuation">)</span><span class="token operator">=&gt;</span><span class="token punctuation">{</span>
    <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token keyword">typeof</span> obj<span class="token punctuation">[</span>key<span class="token punctuation">]</span> <span class="token operator">===</span> <span class="token string">'object'</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
      <span class="token function">constantize</span><span class="token punctuation">(</span>obj<span class="token punctuation">[</span>key<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span>
</code></pre></div><p>var、function声明的全局变量依旧是顶层对象的属性</p> <p>let、const、class、import声明的全局变量不在是顶层对象的属性。</p> <p>ES6变量声明的6中方法：</p> <ul><li>var</li> <li>function</li> <li>let</li> <li>const</li> <li>import</li> <li>class</li></ul> <h3 id="顶层对象"><a href="#顶层对象" class="header-anchor">#</a> 顶层对象</h3> <p>在浏览器中，顶层对象是指window对象，Node指gobal对象。</p> <p>ES6中，var和function声明的全局变量依旧属于顶层对象属性，let、const、class声明的全局变量不属于顶层对象的属性。</p> <p>全局变量逐步与顶层对象的属性脱钩。</p> <p>同一段代码在不同环境转给你，都能取到顶层对象，但是有局限性。</p> <p>全局环境中，this会返回顶层对象，但是在Node模块和ES6模块中，this返回的时当前模块。</p> <p>函数中的this，若不作为对象的方法允许，则指向顶层对象，严格模式先为undefined。</p> <p>若浏览器使用了内容安全策略，eval、new Function这些方法都可能无法使用。</p> <div class="language-javascript extra-class"><pre class="language-javascript"><code><span class="token comment">//勉强取顶层对象</span>
<span class="token keyword">var</span> <span class="token function-variable function">getGlobal</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
    <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token keyword">typeof</span> self <span class="token operator">!==</span> <span class="token string">'undefined'</span><span class="token punctuation">)</span><span class="token punctuation">{</span> <span class="token keyword">return</span> self<span class="token punctuation">;</span><span class="token punctuation">}</span>
    <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token keyword">typeof</span> window <span class="token operator">!==</span> <span class="token string">'undefined'</span><span class="token punctuation">)</span><span class="token punctuation">{</span> <span class="token keyword">return</span> window<span class="token punctuation">;</span><span class="token punctuation">}</span>
    <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token keyword">typeof</span> global <span class="token operator">!==</span> <span class="token string">'undefined'</span><span class="token punctuation">)</span><span class="token punctuation">{</span> <span class="token keyword">return</span> global<span class="token punctuation">;</span><span class="token punctuation">}</span>
    <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">Error</span><span class="token punctuation">(</span><span class="token string">'unable to locate global object'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><p>ES2020语言标准层面，引入globalThis作为顶层对象。即在任何环境，都存在globalThis</p> <h2 id="变量结构赋值"><a href="#变量结构赋值" class="header-anchor">#</a> 变量结构赋值</h2> <h3 id="数组的解构赋值"><a href="#数组的解构赋值" class="header-anchor">#</a> 数组的解构赋值</h3> <p>按照一定的模式从数组或对象中提取值，然后对变量进行赋值，称为解构赋值。</p> <div class="language-javascript extra-class"><pre class="language-javascript"><code><span class="token keyword">let</span> <span class="token punctuation">[</span>a<span class="token punctuation">,</span>b<span class="token punctuation">,</span>c<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
</code></pre></div><p>本质上，这种写法是【模式匹配】，只要等号两边的模式相同，左边变量就会被赋对应的值。</p> <p>如果解构不成功，则变量的值为undefined。</p> <p>只要某种数据结构具有 <strong>Iterator</strong>接口，都可以采用<strong>数组形式</strong>的解构赋值。</p> <p>对于Set结构，也可以使用数组的结构赋值</p> <div class="language-javascript extra-class"><pre class="language-javascript"><code><span class="token keyword">let</span> <span class="token punctuation">[</span>x<span class="token punctuation">,</span> y<span class="token punctuation">,</span> z<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Set</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token string">'a'</span><span class="token punctuation">,</span> <span class="token string">'b'</span><span class="token punctuation">,</span> <span class="token string">'c'</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
x <span class="token comment">//'a'</span>
</code></pre></div><div class="language-javascript extra-class"><pre class="language-javascript"><code><span class="token keyword">let</span> <span class="token punctuation">[</span>foo<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>
<span class="token keyword">let</span> <span class="token punctuation">[</span>foo<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token comment">//上述语句会报错，由于等号右边的值或转为对象以后都不具备Iterator接口。</span>
</code></pre></div><p>解构赋值允许取默认值：只有严格等于undefined的时候，才会取默认值</p> <div class="language-javascript extra-class"><pre class="language-javascript"><code><span class="token keyword">let</span> <span class="token punctuation">[</span>foo  <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token comment">//foo = true;</span>
<span class="token keyword">let</span> <span class="token punctuation">[</span>x <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token keyword">null</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token comment">//x = null;//由于null不严格等于undefined。</span>
</code></pre></div><p>如果默认求值是一个表达式，那这个表达式是惰性求值，即只有在用到的时候才会求值。</p> <div class="language-javascript extra-class"><pre class="language-javascript"><code><span class="token keyword">function</span> <span class="token function">fn</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">let</span> <span class="token punctuation">[</span>x <span class="token operator">=</span> <span class="token function">fn</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token comment">//此处函数fn不会执行。</span>
</code></pre></div><h3 id="对象的解构赋值"><a href="#对象的解构赋值" class="header-anchor">#</a> 对象的解构赋值</h3> <p>数组的元素按次序排列，变量的取值由位置决定；</p> <p>对象的属性没有次序，变量必须与属性同名才能取值。</p> <div class="language-javascript extra-class"><pre class="language-javascript"><code><span class="token keyword">let</span> <span class="token punctuation">{</span> baz <span class="token punctuation">}</span> <span class="token operator">=</span> <span class="token punctuation">{</span> foo<span class="token operator">:</span><span class="token string">'a'</span><span class="token punctuation">,</span> bar<span class="token operator">:</span><span class="token string">'b'</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token comment">//baz = undefined</span>
</code></pre></div><p>对象的解构赋值的内部机制：先找到同名属性，再将值赋给对应的变量，真正被赋值的是后者。</p> <div class="language-javascript extra-class"><pre class="language-javascript"><code><span class="token keyword">let</span> <span class="token punctuation">{</span> foo<span class="token operator">:</span> baz <span class="token punctuation">}</span> <span class="token operator">=</span> <span class="token punctuation">{</span> foo<span class="token operator">:</span> <span class="token string">'a'</span><span class="token punctuation">,</span> bar<span class="token operator">:</span><span class="token string">'b'</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token comment">//baz = a;</span>
<span class="token comment">//foo undefined;</span>
<span class="token comment">//模式匹配是foo,真正的变量是baz</span>
</code></pre></div><p>对象解构也可以指定默认值，生效条件是对象的属性值严格等于undefined。</p> <p>对象结构失败，则等于undefined。</p> <p>对象解构可以嵌套，但是结构模式嵌套的是对象，而子对象所在的父属性不存在，则报错。</p> <div class="language-javascript extra-class"><pre class="language-javascript"><code><span class="token keyword">let</span> <span class="token punctuation">{</span> foo<span class="token operator">:</span> <span class="token punctuation">{</span> bar <span class="token punctuation">}</span><span class="token punctuation">}</span> <span class="token operator">=</span> <span class="token punctuation">{</span> baz<span class="token operator">:</span> <span class="token string">'a'</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token comment">//报错</span>
<span class="token comment">//由于foo为undefined，再取undefined的子属性就会报错。</span>
</code></pre></div><p>对象结构赋值可以取到继承的属性。</p> <div class="language-javascript extra-class"><pre class="language-javascript"><code><span class="token keyword">const</span> obj1 <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token keyword">const</span> obj2 <span class="token operator">=</span> <span class="token punctuation">{</span>foo<span class="token operator">:</span> <span class="token string">'bar'</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
Object<span class="token punctuation">.</span><span class="token function">setPrototypeOf</span><span class="token punctuation">(</span>obj1<span class="token punctuation">,</span> obj2<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">const</span> <span class="token punctuation">{</span> foo <span class="token punctuation">}</span> <span class="token operator">=</span> obj1<span class="token punctuation">;</span>
foo <span class="token comment">// 'bar'</span>
</code></pre></div><p>若将一个已经声明的变量用于结构，引擎会认为{ x }是一个代码块，导致错误。</p> <p>将大括号放在行首，解释权认为其实代码块，所以需要添加括号。</p> <div class="language-javascript extra-class"><pre class="language-javascript"><code><span class="token keyword">let</span> x<span class="token punctuation">;</span>
<span class="token punctuation">{</span>x<span class="token punctuation">}</span> <span class="token operator">=</span> <span class="token punctuation">{</span>x<span class="token operator">:</span> <span class="token number">1</span><span class="token punctuation">}</span><span class="token punctuation">;</span><span class="token comment">//syntax error</span>
</code></pre></div><p>解构赋值允许等号左边的模式中不放任何变量名，但是没有任何意义。</p> <p>由于数组本质上是特殊的对象，所以可以对数组进行对象属性的解构</p> <div class="language-javascript extra-class"><pre class="language-javascript"><code><span class="token keyword">let</span> arr <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
<span class="token keyword">let</span> <span class="token punctuation">{</span> <span class="token number">0</span><span class="token operator">:</span> first<span class="token punctuation">,</span> <span class="token punctuation">[</span>arr<span class="token punctuation">.</span>length <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token operator">:</span> last<span class="token punctuation">}</span> <span class="token operator">=</span> arr<span class="token punctuation">;</span>
<span class="token comment">//first = 1;</span>
<span class="token comment">//last = 3;</span>
</code></pre></div><h3 id="字符串的解构赋值"><a href="#字符串的解构赋值" class="header-anchor">#</a> 字符串的解构赋值</h3> <p>字符串也可以解构赋值，此时字符串被转换为一个类似数组的对象。</p> <div class="language-javascript extra-class"><pre class="language-javascript"><code><span class="token keyword">const</span> <span class="token punctuation">[</span>a<span class="token punctuation">,</span>b<span class="token punctuation">,</span>c<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token string">'hello'</span><span class="token punctuation">;</span><span class="token comment">//a = h; b = e; c = l;</span>

<span class="token comment">//类数组对象都有一个length属性，所有可以对这个属性进行解构；</span>
<span class="token keyword">let</span> <span class="token punctuation">[</span>length<span class="token operator">:</span>len<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token string">'hello'</span><span class="token punctuation">;</span>
<span class="token comment">//len = 5;</span>
</code></pre></div><h3 id="数值和布尔值的解构赋值"><a href="#数值和布尔值的解构赋值" class="header-anchor">#</a> 数值和布尔值的解构赋值</h3> <p>如果右边是数值或者布尔值，则会先转为对象。但是undefined和null不能转对象，所以会报错。</p> <div class="language-javascript extra-class"><pre class="language-javascript"><code><span class="token keyword">let</span> <span class="token punctuation">{</span> toString<span class="token operator">:</span> s<span class="token punctuation">}</span> <span class="token operator">=</span> <span class="token number">123</span><span class="token punctuation">;</span>
<span class="token comment">//s === Number.property.toString</span>
</code></pre></div><p><strong>解构赋值规则：只要等号右边的值不是对象或数组，就先转为对象，undefined和null无法转为对象，所以会报错</strong></p> <h3 id="函数参数的解构赋值"><a href="#函数参数的解构赋值" class="header-anchor">#</a> 函数参数的解构赋值</h3> <div class="language-javascript extra-class"><pre class="language-javascript"><code><span class="token keyword">function</span> <span class="token function">move</span><span class="token punctuation">(</span><span class="token parameter"><span class="token punctuation">{</span>x <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">,</span> y <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">}</span></span><span class="token punctuation">)</span><span class="token punctuation">{</span>
  <span class="token keyword">return</span> <span class="token punctuation">[</span>x<span class="token punctuation">,</span>y<span class="token punctuation">]</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">function</span> <span class="token function">move</span><span class="token punctuation">(</span><span class="token parameter"><span class="token punctuation">{</span>x<span class="token punctuation">,</span>y<span class="token punctuation">}</span> <span class="token operator">=</span> <span class="token punctuation">{</span>x<span class="token operator">:</span><span class="token number">0</span><span class="token punctuation">,</span>y<span class="token operator">:</span><span class="token number">0</span><span class="token punctuation">}</span></span><span class="token punctuation">)</span><span class="token punctuation">{</span> <span class="token comment">//此处指定的参数的默认值，不是x,y的</span>
  <span class="token keyword">return</span> <span class="token punctuation">[</span>x<span class="token punctuation">,</span>y<span class="token punctuation">]</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><p><strong>解构赋值的圆括号使用原则：赋值语句的非模式部分可以使用圆括号。</strong></p> <p>解构赋值用途：</p> <ul><li>交换变量</li> <li>函数返回多个值</li> <li>函数参数的定义</li> <li>提取JSON数据</li> <li>函数参数的默认值</li> <li>变量Map解构</li> <li>输入模块的指定方法</li></ul> <p>任何部署了Iterator接口的对象都可以使用for...of循环遍历。</p> <p>Map结构原生支持Iterator接口，所以可以配合变量解构赋值获取键名和键值。</p> <div class="language-javascript extra-class"><pre class="language-javascript"><code><span class="token keyword">var</span> map <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Map</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
map<span class="token punctuation">.</span><span class="token function">set</span><span class="token punctuation">(</span><span class="token string">&quot;first&quot;</span><span class="token punctuation">,</span> <span class="token string">&quot;hello&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
map<span class="token punctuation">.</span><span class="token function">set</span><span class="token punctuation">(</span><span class="token string">&quot;second&quot;</span><span class="token punctuation">,</span> <span class="token string">&quot;world&quot;</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">let</span> <span class="token punctuation">[</span>key<span class="token punctuation">,</span>value<span class="token punctuation">]</span> <span class="token keyword">of</span> map<span class="token punctuation">)</span><span class="token punctuation">{</span>
  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>key<span class="token punctuation">,</span> value<span class="token punctuation">)</span>
<span class="token punctuation">}</span>

</code></pre></div><h2 id="字符串扩展"><a href="#字符串扩展" class="header-anchor">#</a> 字符串扩展</h2> <h3 id="字符的unicode-表示法"><a href="#字符的unicode-表示法" class="header-anchor">#</a> 字符的Unicode 表示法</h3> <p>ES6加强了Unicode支持，只需将码点放在大括号中就能正确解读该字符</p> <div class="language-javascript extra-class"><pre class="language-javascript"><code><span class="token string">'\u{20BB7}'</span>
<span class="token string">'\u{41}\u{42}\u{43}'</span> <span class="token comment">//abc</span>
</code></pre></div><p>大括号表示法与四字节的UTF-16编码是等价的。</p> <blockquote><p>ES5不足：允许是用\uxxxx表示一个字符，这种表示法只限于码点\u0000~\uFFFF之间的字符，超出这个范围需要用两个双字节的形式表示。</p></blockquote> <h3 id="字符串的遍历接口"><a href="#字符串的遍历接口" class="header-anchor">#</a> 字符串的遍历接口</h3> <p>ES6为字符串添加了遍历器接口，使得字符串能够使用<strong>for ...  of循环遍历</strong></p> <p>遍历器最大的优点是可以识别大于0xFFFF的码点。</p> <div class="language-javascript extra-class"><pre class="language-javascript"><code><span class="token keyword">let</span> text <span class="token operator">=</span> String<span class="token punctuation">.</span><span class="token function">fromCodePoint</span><span class="token punctuation">(</span><span class="token number">0x20BB7</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">let</span> i <span class="token keyword">of</span> text<span class="token punctuation">)</span><span class="token punctuation">{</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><h3 id="直接输入u-20208、u-2029"><a href="#直接输入u-20208、u-2029" class="header-anchor">#</a> 直接输入U+20208、U+2029</h3> <p>JavaScript规定5个字符串不能在字符串里面直接使用：</p> <ul><li>U+005C</li> <li>U+000D</li> <li>U+2028</li> <li>U+2029</li> <li>U+000A</li></ul> <p>字符串里面不能直接包含反斜杠，一定要转义写成\\或\u005c。</p> <p>但是对于JSON格式允许字符串直接使用行分隔符U+2028和段分隔符U+2029，JSON.parse解析的时候会报错。</p> <p>ES2019允许直接输入U+2028和U+2029</p> <h3 id="json-stringify-的改造"><a href="#json-stringify-的改造" class="header-anchor">#</a> JSON.stringify()的改造</h3> <p>根据标准，JSON数据必须是UTF-8，但是JSON.stringify()方法有可能返回不符合标准的字符串。即0xD800到0xDFFF之间的码点不能单独使用，必须配对使用。</p> <p>ES2019改变了这个行为，如果遇到单个码点或不存咋的配对形式，会返回转义字符串，可以做进一步处理。</p> <h3 id="模板字符串"><a href="#模板字符串" class="header-anchor">#</a> 模板字符串</h3> <p>增强 的字符串，用反引号标识，可以当普通字符串使用，也可以用来定义多行字符串或在字符串中嵌入变量。</p> <p>嵌入变量需要将变量名写在${}之中。</p> <p>大括号内部可以放任意JavaScript表达式，可以进行运算及引用对象属性</p> <p>模板字符串之中还能调用函数</p> <p>若大括号中的值不是字符串，则按照一般规则转为字符串</p> <p>模板编译：可以通过一个模板字符串，生成正式的模板的实例。</p> <p>标签模板（函数调用的一种特殊形式）：模板字符串可以紧跟在一个函数名后面，该函数将被调用来处理这个模板字符串。</p> <div class="language-javascript extra-class"><pre class="language-javascript"><code>alert<span class="token template-string"><span class="token template-punctuation string">`</span><span class="token string">hello</span><span class="token template-punctuation string">`</span></span>
<span class="token comment">//等同于</span>
<span class="token function">alert</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token string">'hello'</span><span class="token punctuation">]</span><span class="token punctuation">)</span>
</code></pre></div><p><strong>如果模板字符串里面有变量，会将模板字符串先处理成多个参数，再调用函数</strong></p> <div class="language-javascript extra-class"><pre class="language-javascript"><code><span class="token keyword">let</span> a <span class="token operator">=</span> <span class="token number">5</span><span class="token punctuation">;</span>
<span class="token keyword">let</span> b <span class="token operator">=</span> <span class="token number">10</span><span class="token punctuation">;</span>
tag<span class="token template-string"><span class="token template-punctuation string">`</span><span class="token string">Hello </span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span>a<span class="token operator">+</span>b<span class="token interpolation-punctuation punctuation">}</span></span><span class="token string"> world </span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span>a<span class="token operator">*</span>b<span class="token interpolation-punctuation punctuation">}</span></span><span class="token template-punctuation string">`</span></span><span class="token punctuation">;</span>
<span class="token comment">//等同于</span>
<span class="token function">tag</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token string">'Hello'</span><span class="token punctuation">,</span><span class="token string">'world'</span><span class="token punctuation">,</span><span class="token string">''</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token number">15</span><span class="token punctuation">,</span> <span class="token number">50</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><p>标签模板可以嵌入其他语言，但是模板字符串默认会将字符串转义，导致无法嵌入其他语言。</p> <p>为了解决这个问题，ES2018放松了对标签模板里面的字符串转义的限制，若遇到不合法的字符串转义，就返回undefined，而不是报错，且从raw属性上可以得到原始字符串。</p> <h2 id="字符串新增方法"><a href="#字符串新增方法" class="header-anchor">#</a> 字符串新增方法</h2> <h3 id="string-fromcodepoint"><a href="#string-fromcodepoint" class="header-anchor">#</a> String.fromCodePoint()</h3> <p>String.fromCharCode()用于从Unicode码点返回对应的字符，但是这个方法不能识别大于0xFFFF的字符。</p> <p>String.fromCodePoint()可以识别大于0xFFFF的字符。</p> <h3 id="string-raw"><a href="#string-raw" class="header-anchor">#</a> String.raw()</h3> <p>ES6为原生的String对象提供了raw()方法，该方法返回一个斜杠都被转义的字符串，一般用于模板字符串的处理方法。</p> <div class="language-javascript extra-class"><pre class="language-javascript"><code>String<span class="token punctuation">.</span>raw<span class="token template-string"><span class="token template-punctuation string">`</span><span class="token string">Hi\n</span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span><span class="token number">2</span><span class="token operator">+</span><span class="token number">3</span><span class="token interpolation-punctuation punctuation">}</span></span><span class="token string">!</span><span class="token template-punctuation string">`</span></span> 
</code></pre></div><p>如果源字符串的斜杠已经转义，那么String.raw()会进行再次转义</p> <p>String.raw本质上是一个正常的函数，只是用于模板字符串的标签函数。</p> <p>String.raw()方法的第一个参数是一个对象，它的raw属性等同于原始的模板字符串解析后得到的数组。</p> <div class="language-javascript extra-class"><pre class="language-javascript"><code><span class="token comment">//`foo${1+2}bar`</span>
<span class="token comment">//等同于</span>
String<span class="token punctuation">.</span><span class="token function">raw</span><span class="token punctuation">(</span><span class="token punctuation">{</span>raw<span class="token operator">:</span> <span class="token punctuation">[</span><span class="token string">'foo'</span><span class="token punctuation">,</span> <span class="token string">'bar'</span><span class="token punctuation">]</span><span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token number">1</span> <span class="token operator">+</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//'foo3bar'</span>
</code></pre></div><p>第一个参数是一个对象，它的raw属性等同于原始的模板字符串解析后得到的数组。</p> <p>String.raw()的代码实现：</p> <div class="language-javascript extra-class"><pre class="language-javascript"><code>String<span class="token punctuation">.</span><span class="token function-variable function">raw</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">strings<span class="token punctuation">,</span> <span class="token operator">...</span>values</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
    <span class="token keyword">let</span> output <span class="token operator">=</span> <span class="token string">''</span><span class="token punctuation">;</span>
    <span class="token keyword">let</span> index<span class="token punctuation">;</span>
    <span class="token keyword">for</span><span class="token punctuation">(</span>index <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> index <span class="token operator">&lt;</span> values<span class="token punctuation">.</span>length<span class="token punctuation">;</span> index<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
      output <span class="token operator">+=</span> strings<span class="token punctuation">.</span>raw<span class="token punctuation">[</span>index<span class="token punctuation">]</span> <span class="token operator">+</span> values<span class="token punctuation">[</span>index<span class="token punctuation">]</span><span class="token punctuation">;</span>   
    <span class="token punctuation">}</span>
    output <span class="token operator">+=</span> strings<span class="token punctuation">.</span>raw<span class="token punctuation">[</span>index<span class="token punctuation">]</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> output<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><h3 id="codepointat"><a href="#codepointat" class="header-anchor">#</a> codePointAt()</h3> <p>用于正确处理4个字节存储的字符，返回一个字符码点。</p> <p>返回的时一个十进制的值，如果想要十六进制的值，可以使用toString()方法转换。</p> <div class="language-javascript extra-class"><pre class="language-javascript"><code><span class="token keyword">let</span> s <span class="token operator">=</span> <span class="token string">'𠮷a'</span><span class="token punctuation">;</span>
s<span class="token punctuation">.</span><span class="token function">codePointAt</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span><span class="token number">16</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">let</span> ch <span class="token keyword">of</span> s<span class="token punctuation">)</span><span class="token punctuation">{</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>ch<span class="token punctuation">.</span><span class="token function">codePointAt</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span><span class="token number">16</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><p>codePointAt()方法是测试一个字符由两个字节还是四个字节组成的最简单的方法。</p> <div class="language-javascript extra-class"><pre class="language-javascript"><code><span class="token keyword">function</span> <span class="token function">is32Bit</span><span class="token punctuation">(</span><span class="token parameter">c</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
    <span class="token keyword">return</span> c<span class="token punctuation">.</span><span class="token function">codePointAt</span><span class="token punctuation">(</span><span class="token number">0</span><span class="token punctuation">)</span> <span class="token operator">&gt;</span> <span class="token number">0xFFFF</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><h3 id="normalize"><a href="#normalize" class="header-anchor">#</a> normalize()</h3> <p>用来将字符的不同表示方法统一为同样的形式。</p> <p>normalize方法目前不能识别三个火三个以上字符的核查，这种情况，只能使用正则表达式，通过判断Unicode编号区间判断。</p> <h3 id="includes-startswith-endswith"><a href="#includes-startswith-endswith" class="header-anchor">#</a> includes(), startsWith(), endsWith()</h3> <ul><li>includes 返回布尔值，表示是否找到了参数字符串</li> <li>startsWith 返回布尔值，表示参数字符串是否在原字符串的头部</li> <li>endsWith 返回布尔值，表示参数字符串是否在原字符串的尾部</li></ul> <h3 id="repeat"><a href="#repeat" class="header-anchor">#</a> repeat()</h3> <p>repeat方法返回一个新字符串，表示将源字符串重复n次。</p> <p>参数会先取整运算，然后获取重复次数。</p> <h3 id="padstart-padend"><a href="#padstart-padend" class="header-anchor">#</a> padStart, padEnd()</h3> <p>字符串补全长度的功能，如果字符串不够指定长度，会在头部或尾部补全。</p> <p>padStart()的常见用途是为数值补全指定位数。</p> <p>另有一个用途是提示字符串格式。</p> <div class="language-javascript extra-class"><pre class="language-javascript"><code><span class="token string">'12'</span><span class="token punctuation">.</span><span class="token function">padStart</span><span class="token punctuation">(</span><span class="token number">10</span><span class="token punctuation">,</span> <span class="token string">'YYYY-MM-DD'</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// 'YYYY-MM-12'</span>
</code></pre></div><h3 id="trimstart-trimend"><a href="#trimstart-trimend" class="header-anchor">#</a> trimStart(), trimEnd()</h3> <p>消除字符串头部或尾部的空格，返回的都是新字符串，不会修改原始字符串。</p> <h3 id="matchall"><a href="#matchall" class="header-anchor">#</a> matchAll()</h3> <p>matchAll()方法返回一个正则表达式在当前字符串的所有匹配。</p> <h2 id="正则扩展"><a href="#正则扩展" class="header-anchor">#</a> *正则扩展</h2> <h2 id="数值扩展"><a href="#数值扩展" class="header-anchor">#</a> 数值扩展</h2> <p>ES6 提供了二进制和八进制的新写法，前缀用0b或0B 和0o或0O表示。</p> <p>ES5开始，在严格模式中，八进制不可以用前缀0表示，ES6明确了使用0o.</p> <p>ES6在Number对象上，增加了新的方法：</p> <ul><li>Number.isFinite()</li> <li>Number.isNaN()</li></ul> <p>ES6将全局方法移植到了Number对象上，行为完全保持不变</p> <ul><li>Number.parseInt()</li> <li>Number.parseFloat()</li></ul> <p>Number.isInteger()来判断数值是否为一个整数。</p> <p>JavaScript内部，整数和浮点数采用的是同样的存储方法，所以25和25.0被视为同一个值。</p> <div class="language-javascript extra-class"><pre class="language-javascript"><code>Number<span class="token punctuation">.</span><span class="token function">isInteger</span><span class="token punctuation">(</span><span class="token number">25</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// true</span>
Number<span class="token punctuation">.</span><span class="token function">isInteger</span><span class="token punctuation">(</span><span class="token number">25.0</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// true</span>
</code></pre></div><p>由于采用IEEE 754标准，数值存储为64位双精度格式，如果超过了这个限度，地54位后面就会被丢弃，这种情况导致Number.isInteger可能误判。</p> <p>对于数据精度要求较高，不建议用Number.isInteger判断是否为一个整数</p> <p>ES6对象上，新增一个极小常量 Number.EPSILON。表示1与大于1的最小浮点数之间的差。</p> <p><strong>Number.EPSILON实际上是JavaScript能够表示的最小精度</strong>。误差小于这个值，就可以认为额没有意义了。</p> <p>引入个值得目的在于浮点计算，设置一个误差范围。</p> <p>安全整数Number.isSafeInteger(), JavaScript表示-2^53到2^53之间，超过这个范围，无法精确表示这个值。</p> <p>Number.MAX_SAFE_INTEGER 和 Number.MIN_SAFE_INTEGER这两个常量用来表示这个范围的上下限。</p> <h3 id="math对象的扩展"><a href="#math对象的扩展" class="header-anchor">#</a> Math对象的扩展</h3> <p>Math.trunc()方法用于出去一个数的小数部分，返回整数部分。</p> <p>Math.sign()方法用于判断一个数到底是正数、负数还是零，对于非数值，会先转换Wie数值。</p> <p>Math.cbrt()方法用于计算一个数的立方根。</p> <p>Math.clz32()方法用于将参数转32位无符号整数的形式。</p> <p>Math.imul()方法返回两个数以32位带符号整数形式相乘的结果，返回也是一个带符号整数。</p> <p>Math.fround()方法返回一个数的32位单精度浮点数形式。</p> <p>Math.hypot()方法返回所有参数的平方和的平方根。</p> <p>对数方法：</p> <p>Math.expm1()返回e* -1，即Math.exp(x) -1</p> <p>Math.log1p() 方法返回1+x的自然对数，即Math.log(1+x)，放x小于-1，返回NaN。</p> <p>Math.log10()</p> <p>Math.log2()</p> <p>双曲函数方法：</p> <ul><li>Math.sinh(x)</li> <li>Math.cosh(x)</li> <li>Math.tanh(x)</li> <li>Math.asinh(x)</li> <li>Math.acosh(x)</li> <li>Math.acosh(x)</li> <li>Math.atanh(x)</li></ul> <p>指数运算符 **，右结合，多个指数运算符连用时从右边开始计算。</p> <div class="language-javascript extra-class"><pre class="language-javascript"><code><span class="token number">2</span><span class="token operator">**</span><span class="token number">3</span><span class="token operator">**</span><span class="token number">2</span> <span class="token comment">//相当于 2**(3**2); 512</span>
</code></pre></div><h3 id="bigint数据类型"><a href="#bigint数据类型" class="header-anchor">#</a> BigInt数据类型</h3> <p>只用来表示整数，没有位数的限制，任何位数的整数都可以精确表示。</p> <p>与Number类型区别，BigInt类型的数据必须加后缀n。</p> <div class="language-javascript extra-class"><pre class="language-javascript"><code><span class="token keyword">const</span> a <span class="token operator">=</span> <span class="token number">2172141653n</span><span class="token punctuation">;</span>
<span class="token keyword">const</span> b <span class="token operator">=</span> <span class="token number">15346349209n</span><span class="token punctuation">;</span>
a <span class="token operator">*</span> b<span class="token punctuation">;</span>
</code></pre></div><p>BigInt与普通数据类型是两种值，他们之间并不相等。</p> <p>BigInt对象，可以用作构造函数生成的BigIngt类型数值，转换规则基本和Number一致</p> <p>BigInt()构造函数必须有参数，而且参数必须可以正常转为数值。</p> <p>BigInt对象继承了Object对象的两个实例方法：</p> <ul><li>BigInt.prototype.toString()</li> <li>BigInt.prototype.valueOf()</li></ul> <p>还继承了Number的实例方法</p> <ul><li>BigInt.prototype.toLocalString()</li></ul> <p>三个静态方法：</p> <ul><li>BigInt.asUnitN(width, BigInt)</li> <li>BigInt.asIntN(width, BigInt)</li> <li>BigInt.parseInt(string[, radix])</li></ul> <p>可以将BigInt通过使用Boolean、Number、String这三个方法，转为布尔、数值和字符串类型。</p> <p>BigInt类型可以+，-，*，**与Number行为一致。除法会舍去小数部分，返回一个整数。</p> <p>BigInt不能使用：</p> <ul><li>不带符号的右移位运算符&gt;&gt;&gt;</li> <li>一元的求正运算符+</li></ul> <p>BigInt不能与普通数值进行混合运算。</p> <h2 id="函数的扩展"><a href="#函数的扩展" class="header-anchor">#</a> 函数的扩展</h2> <h3 id="函数参数的默认值"><a href="#函数参数的默认值" class="header-anchor">#</a> 函数参数的默认值</h3> <p>ES6之前，不能直接为函数的参数指定默认值，通过变通的方法。</p> <p>ES6允许为函数的参数设置默认值，即直接写在参数定义的后面。</p> <div class="language-javascript extra-class"><pre class="language-javascript"><code><span class="token keyword">function</span> <span class="token function">log</span><span class="token punctuation">(</span>x<span class="token punctuation">,</span> y <span class="token operator">=</span> <span class="token string">'World'</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>x<span class="token punctuation">,</span> y<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><p>注意点：</p> <ul><li><p>参数变量是默认声明的，所以不能用let和const再次声明。</p></li> <li><p>使用参数默认值时，函数不能有同名函数。</p></li> <li><p>参数默认值不是传值，而是每次都重新计算默认值表达式的值，参数默认值是惰性求值的</p></li></ul> <p>参数默认值可以与解构赋值默认值结合使用</p> <div class="language-javascript extra-class"><pre class="language-javascript"><code><span class="token comment">//只有当foo的参数是一个对象时，变量x,y才会通过解构赋值生成。</span>
<span class="token keyword">function</span> <span class="token function">foo</span><span class="token punctuation">(</span><span class="token parameter"><span class="token punctuation">{</span>x<span class="token punctuation">,</span> y <span class="token operator">=</span> <span class="token number">5</span><span class="token punctuation">}</span></span><span class="token punctuation">)</span><span class="token punctuation">{</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>x<span class="token punctuation">,</span>y<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token comment">//提供函数参数的默认值，避免没有参数时报错。</span>
<span class="token keyword">function</span> <span class="token function">foo</span><span class="token punctuation">(</span><span class="token parameter"><span class="token punctuation">{</span>x<span class="token punctuation">,</span> y <span class="token operator">=</span> <span class="token number">5</span><span class="token punctuation">}</span> <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token punctuation">}</span></span><span class="token punctuation">)</span><span class="token punctuation">{</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>x<span class="token punctuation">,</span> y<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><p>通常情况下，定义默认值的参数应该是函数的尾参数，如果非尾部的参数设置默认值，实际上这个参数是不能省略的。</p> <p><strong>函数的length</strong>,指定默认值后，函数的length属性，将返回没有指定默认值的参数个数，即指定了默认值以后，length属性将失真。</p> <div class="language-javascript extra-class"><pre class="language-javascript"><code><span class="token punctuation">(</span><span class="token function">funciton</span><span class="token punctuation">(</span><span class="token parameter">a<span class="token punctuation">,</span>b<span class="token punctuation">,</span>c<span class="token operator">=</span><span class="token number">5</span></span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">.</span>length<span class="token punctuation">;</span> <span class="token comment">//2</span>

<span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter"><span class="token operator">...</span>args</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">.</span>length<span class="token punctuation">;</span> <span class="token comment">//0</span>
</code></pre></div><p>length属性的含义是：<strong>该函数预期传入的参数个数</strong>。同样，rest参数也不会计算length属性。</p> <p>如果设置了默认值的参数不是尾参数，那么length属性也不再计入后面的参数了。</p> <p><strong>作用域</strong>，一旦设置了参数默认值，函数进行声明初始化时，参数就会形成一个单独的作用域，等初始化结束后，这个作用域消失。这种行为，在不设置参数默认值时，不会出现。</p> <div class="language-javascript extra-class"><pre class="language-javascript"><code><span class="token keyword">var</span> x <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>
<span class="token keyword">function</span> <span class="token function">f</span><span class="token punctuation">(</span><span class="token parameter">x<span class="token punctuation">,</span> y <span class="token operator">=</span> x</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>y<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token function">f</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// 2</span>
<span class="token comment">//上述代码由于参数y的默认参数x,调用f时，参数形成一个单独作用域，这个作用域里面，默认值变量x指向第一个参数x,而不是全局变量。</span>


<span class="token keyword">let</span> x <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>
<span class="token keyword">function</span> <span class="token function">f</span><span class="token punctuation">(</span><span class="token parameter">y <span class="token operator">=</span> x</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
    <span class="token keyword">let</span> x <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>y<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token function">f</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//1</span>
<span class="token comment">//函数f调用时，参数y=x形成一个单独的作用域，这个作用域里面，变量x本身没有定义，所以指向外层的全局变量。内部变量x影响不到默认值变量x。</span>
</code></pre></div><p>利用参数默认值，可以指定某一个参数不得省略，如果省略就抛出错误。</p> <h3 id="rest参数"><a href="#rest参数" class="header-anchor">#</a> rest参数</h3> <p>ES6引入rest参数，用于获取函数的多余参数，这样就不需要使用arguments对象了。</p> <p>rest参数搭配的变量是一个数组，改变了将多余的参数放入数组中。</p> <div class="language-javascript extra-class"><pre class="language-javascript"><code><span class="token comment">//可以传入任意数目的参数。</span>
<span class="token keyword">function</span> <span class="token function">add</span><span class="token punctuation">(</span><span class="token parameter"><span class="token operator">...</span>values</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
    <span class="token keyword">let</span> sum <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">var</span> val <span class="token keyword">of</span> values<span class="token punctuation">)</span><span class="token punctuation">{</span>
        sum <span class="token operator">+=</span> val<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">return</span> sum<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><p>rest参数之后不能有其他参数，否则会报错。</p> <p>函数的length属性，不包括rest参数。</p> <h3 id="严格模式"><a href="#严格模式" class="header-anchor">#</a> 严格模式</h3> <p>从ES5开始，函数内部可以设置为严格模式。</p> <p>ES6规定，只要函数参数使用了默认值、解构赋值、或者扩展运算符，那么函数内部不能显示设定了为严格模式。</p> <blockquote><p>这是因为函数内部的严格模式同样适用于函数体和函数参数，但是函数执行的时候，先执行函数参数，然后执行函数体。只有从函数体之中，才能知道参数是否以严格模式执行，但是参数却先于函数体执行。</p></blockquote> <p>两种方法规避这种限制：</p> <ul><li><p>全局设定严格模式</p></li> <li><p>把函数包在一个无参数立即执行的函数里面</p> <div class="language-javascript extra-class"><pre class="language-javascript"><code><span class="token keyword">const</span> doSomthting <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
    <span class="token string">'use strict'</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">value <span class="token operator">=</span> <span class="token number">22</span></span><span class="token punctuation">)</span><span class="token punctuation">{</span>
        <span class="token keyword">return</span> value<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
</code></pre></div></li></ul> <h3 id="name属性"><a href="#name属性" class="header-anchor">#</a> name属性</h3> <p>函数name属性，返回该函数的函数名。</p> <p>ES6对这个属性做了修改，如果一个匿名函数赋值给一个变量，ES5的name属性会返回空字符串</p> <p>ES6的name属性会返回实际的函数名。</p> <div class="language-javascript extra-class"><pre class="language-javascript"><code><span class="token keyword">var</span> <span class="token function-variable function">f</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span>

<span class="token comment">//ES5 </span>
f<span class="token punctuation">.</span>name<span class="token punctuation">;</span> <span class="token comment">//''</span>

<span class="token comment">//ES6</span>
f<span class="token punctuation">.</span>name <span class="token comment">//'f'</span>
</code></pre></div><p>Function构造函数返回函数的实例，name属性的值为 anonymous。</p> <p>bind返回的函数，name属性值会叫上bound前缀</p> <div class="language-javascript extra-class"><pre class="language-javascript"><code><span class="token keyword">function</span> <span class="token function">foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token function">foo</span><span class="token punctuation">.</span><span class="token function">bind</span><span class="token punctuation">(</span><span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">.</span>name<span class="token punctuation">;</span> <span class="token comment">// 'bound foo'</span>
</code></pre></div><h3 id="箭头函数"><a href="#箭头函数" class="header-anchor">#</a> 箭头函数</h3> <p>ES6允许使用箭头定义函数</p> <div class="language-javascript extra-class"><pre class="language-javascript"><code><span class="token keyword">var</span> <span class="token function-variable function">f</span> <span class="token operator">=</span> <span class="token parameter">v</span> <span class="token operator">=&gt;</span> v<span class="token punctuation">;</span>
<span class="token comment">//等同于</span>
<span class="token keyword">var</span> <span class="token function-variable function">f</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">v</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
    <span class="token keyword">return</span> v<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><p>如果箭头函数不需要参数或需要多个参数，就使用一个圆括号代表参数部分。</p> <p>由于大括号被解释为代码块，所以箭头函数返回一个对象，必须在这个对象外面叫上括号。</p> <p>注意：</p> <ol><li>函数体内的this对象，就是定义时所在的对象</li> <li>不可以当做构造函数</li> <li>不可以使用arguments对象，该对象在函数体内不存在，可以用rest代替</li> <li>不可以使用yield命令，即箭头函数不能作为Generator函数</li></ol> <p>箭头函数this指向的固定化是因为箭头函数没有自己的this，导致内部的this就是外层代码块的this.</p> <h3 id="尾调优化"><a href="#尾调优化" class="header-anchor">#</a> 尾调优化</h3> <p>尾调用是指某个函数的最后一步是调用另一个函数。</p> <div class="language-javascript extra-class"><pre class="language-javascript"><code><span class="token keyword">function</span> <span class="token function">f</span><span class="token punctuation">(</span><span class="token parameter">x</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
    <span class="token keyword">return</span> <span class="token function">g</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><p>尾调用与其他调用不同，就是在于它的特殊的调用位置。</p> <p>函数调用会在内存形成一个&quot;调用记录&quot;（调用帧），保存调用位置和内部变量等信息。</p> <p>多个调用帧会形成一个调用栈。</p> <p>尾调用由于是函数的最后一步操作，所以不需要保留外层函数的调用帧，因为调用位置、内部变量等信息都不会再用刀，直接用内层函数的调用帧取代外层函数的调用帧即可。</p> <div class="language-javascript extra-class"><pre class="language-javascript"><code><span class="token keyword">function</span> <span class="token function">f</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
    <span class="token keyword">let</span> m <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>
    <span class="token keyword">let</span> n <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> <span class="token function">g</span><span class="token punctuation">(</span>m<span class="token operator">+</span>n<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token function">f</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">//等同于</span>
<span class="token keyword">function</span> <span class="token function">f</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
    <span class="token keyword">return</span> <span class="token function">g</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token function">f</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">//等同于</span>
<span class="token function">g</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><p>尾调用优化，即只保留内层函数的调用帧。如果所有函数都是尾调用，那么每次执行时，调用帧只有一项，这就节约了内存空间，这就是尾调用优化的意义。</p> <p>函数尾调用自身，就称为尾递归。</p> <p>递归非常耗费内存，这是因为保存很多调用帧，容易发生栈溢出。对于尾递归，只存在一个调用帧，不会发生栈溢出。</p> <div class="language-javascript extra-class"><pre class="language-javascript"><code><span class="token keyword">function</span> <span class="token function">factorial</span><span class="token punctuation">(</span><span class="token parameter">n</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
    <span class="token keyword">if</span><span class="token punctuation">(</span>n <span class="token operator">===</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token keyword">return</span> <span class="token number">1</span><span class="token punctuation">;</span><span class="token punctuation">}</span>
    <span class="token keyword">return</span> n <span class="token operator">*</span> <span class="token function">factorial</span><span class="token punctuation">(</span>n <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token comment">//改成尾递归</span>
<span class="token keyword">function</span> <span class="token function">factorial</span><span class="token punctuation">(</span><span class="token parameter">n<span class="token punctuation">,</span> total</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
    <span class="token keyword">if</span><span class="token punctuation">(</span>n <span class="token operator">===</span> <span class="token number">1</span><span class="token punctuation">)</span> <span class="token keyword">return</span> total<span class="token punctuation">;</span>
    <span class="token keyword">return</span> <span class="token function">factorial</span><span class="token punctuation">(</span>n <span class="token operator">-</span> <span class="token number">1</span><span class="token punctuation">,</span> n <span class="token operator">*</span> total<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token function">factorial</span><span class="token punctuation">(</span><span class="token number">5</span><span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//120</span>

<span class="token comment">//柯里化</span>
<span class="token keyword">function</span> <span class="token function">tailFactorial</span><span class="token punctuation">(</span><span class="token parameter">n</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
    <span class="token keyword">return</span> <span class="token function">factorial</span><span class="token punctuation">(</span>n<span class="token punctuation">,</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token function">taiFactorial</span><span class="token punctuation">(</span><span class="token number">5</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//120</span>
</code></pre></div><blockquote><p>目前只有Safari浏览器支持尾调用优化，Chrome和Firfox都不支持。</p></blockquote> <p>函数式编程柯里化，就是讲多个参数的函数转换成单个参数的形式。</p> <p>ES6的尾调优化只在严格模式下开启，正常模式无效的。这是因为在正常模式下，函数内部的两个边路，可以跟踪函数的调用栈。</p> <ul><li>func.arguments: 返回调用时函数的参数</li> <li>func.caller: 返回调用当前函数的那个函数</li></ul> <p>尾调优化只在严格模式下生效，在正常模式下，可以将循环换掉递归，以达到减少调用栈，这样就不会发生栈溢出</p> <h3 id="function-prototype-tostring"><a href="#function-prototype-tostring" class="header-anchor">#</a> Function.prototype.toString()</h3> <p>ES2019对函数实例的toString方法作出了修改，返回函数diam本身，以前会省略注释与空格。</p> <h3 id="catch命令的参数省略"><a href="#catch命令的参数省略" class="header-anchor">#</a> catch命令的参数省略</h3> <p>ES2019允许catch语句省略参数。</p> <div class="language-javascript extra-class"><pre class="language-javascript"><code><span class="token keyword">try</span><span class="token punctuation">{</span>
    
<span class="token punctuation">}</span><span class="token keyword">catch</span><span class="token punctuation">{</span>
    
<span class="token punctuation">}</span>
</code></pre></div><h2 id="数组的扩展"><a href="#数组的扩展" class="header-anchor">#</a> 数组的扩展</h2> <p>扩展运算符是三个点，好比rest参数的逆运算，将一个数组转为用逗号分隔的参数序列。</p> <p>该运算符主要用于函数的调用，只有在函数调用时，扩展运算符才可以放在圆括号中。</p> <p>由于扩展运算符可以展开数组，所以不需要apply方法，将数组转为函数的参数了。</p> <p>扩展运算符的应用：</p> <ul><li>复制数组</li> <li>合并数组</li> <li>与解构赋值结合</li> <li>字符串转化为真正的数组</li> <li>实现Iterator接口的对象，任何定义了遍历器接口的对象，都可以用扩展运算符转为真正的数组</li> <li>Map和Set结构，Generator函数</li></ul> <h3 id="array-from"><a href="#array-from" class="header-anchor">#</a> Array.from()</h3> <p>该方法用于将两类对象转为真正的数组：</p> <ul><li>类数组对象</li> <li>可遍历对象（Set和Map）</li></ul> <p>Array.from还可以接受第二个参数，作用类似于数组的map方法，用来对每个元素进行处理，将处理后的值放入返回的数组。</p> <p>Array.from可以传入第三个参数，用来绑定this。</p> <h3 id="array-of"><a href="#array-of" class="header-anchor">#</a> Array.of()</h3> <p>该方法用于将一组值，转为数组。</p> <p>该方法的主要目的是弥补数组构造函数Array()的不足，因为参数个数不同，会导致Array()的行为有差异。</p> <blockquote><p>只有当Array方法参数个数不少于2个时，Array()才会返回由参数组成的新数组。</p> <p>参数只有一个时，实际上是指定数组的长度。</p></blockquote> <p>Array.of基本可以替代Array() 或new Array()。总是返回参数组成的数组，没有参数时，返回一个空数组。</p> <div class="language-javascript extra-class"><pre class="language-javascript"><code><span class="token comment">//模拟代码</span>
<span class="token keyword">function</span> <span class="token function">ArrayOf</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
    <span class="token keyword">return</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">slice</span><span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span>arguments<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><h3 id="数组实例的copywithin"><a href="#数组实例的copywithin" class="header-anchor">#</a> 数组实例的copyWithin()</h3> <p>在当前数组内部，将指定位置的成员复制到其他位置（会覆盖原有成员），然后返回当前数组。</p> <p>这个方法会修改当前数组。</p> <p>接受三个参数：</p> <ul><li>target, 从该位置开始替换数据</li> <li>start，从该位置开始读取数据，默认为0，可选</li> <li>end，从该位置停止读取数据，默认等于数组的长度，可选</li></ul> <h3 id="数组实例-find-和-findindex"><a href="#数组实例-find-和-findindex" class="header-anchor">#</a> 数组实例 find() 和 findIndex()</h3> <p>数组实例find方法用于找出第一个符合条件的数组成员，参数是一个回调函数。找到返回该成员，否则返回undefined。</p> <p>find方法的<strong>回调函数</strong>可以接受三个参数：</p> <ul><li>当前值</li> <li>当前位置</li> <li>原数组</li></ul> <p>数组findIndex方法的用法类似，返回第一个负荷条件的数组成员的位置，没有符合，则返回-1.</p> <p>这两个方法都可以接受第二个参数，用来绑定回调函数的this对象</p> <p>这两个方法都可以发现NaN，弥补数组的indexOf方法的不足。</p> <h3 id="数组实例fill"><a href="#数组实例fill" class="header-anchor">#</a> 数组实例fill()</h3> <p>该方法使用给定值，填充一个数组。</p> <p>fill方法可以接受第二个和第三个参数，用于指定填充的起始位置和结束位置。</p> <p>注意：</p> <p>如果填充的类型为对象，那么被赋值的时同一内存地址的对象，而不是深拷贝对象。</p> <h3 id="数组实例entries-keys-values"><a href="#数组实例entries-keys-values" class="header-anchor">#</a> 数组实例entries(),keys(),values()</h3> <p>ES6提供三个新的方法用于遍历数组，他们都返回一个遍历器对象，可以用for...of循环进行遍历。</p> <h3 id="数组实例inclides"><a href="#数组实例inclides" class="header-anchor">#</a> 数组实例inclides()</h3> <p>Array.prototype.includes方法返回一个布尔值，表示某个数组是否包含给定的值。</p> <blockquote><p>indexOf只找出参数值得第一个出现的位置，且内部使用严格相等进行判断，会导致对NaN误判。</p></blockquote> <h3 id="数组实例flat-、flatmap"><a href="#数组实例flat-、flatmap" class="header-anchor">#</a> 数组实例flat()、flatMap()</h3> <p>数组的成员有时还是数组，Array.prototype.flat()用于将嵌套的数组变成一维数组。该方法返回一个新数组，对原数据没有影响。</p> <p>flat()默认是一层，可以设置参数，表示层数。</p> <blockquote><p>Infinity可以作为参数，不管多少层都转成一维数组</p> <p>如果原数组有空位，则会跳过空位</p></blockquote> <p>flatMap方法对原数组的每个成员执行一个函数，然后对返回值组成的数组执行flat()方法，该方法返回一个新数组，不会改变原数组。</p> <p>flatMap方法可以有第二个参数，用来绑定遍历函数里面的this</p> <h3 id="数组空位"><a href="#数组空位" class="header-anchor">#</a> 数组空位</h3> <p>表示数组的某一个位置没有任何值。</p> <p>空位不是undefined，一个位置的值等于undefined，依然是有值的。</p> <p>空位是没有任何值， in运算符可以说明这一点：</p> <div class="language-javascript extra-class"><pre class="language-javascript"><code><span class="token number">0</span> <span class="token keyword">in</span> <span class="token punctuation">[</span><span class="token keyword">undefined</span><span class="token punctuation">,</span> <span class="token keyword">undefined</span><span class="token punctuation">,</span> <span class="token keyword">undefined</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token comment">//true</span>
<span class="token number">0</span> <span class="token keyword">in</span> <span class="token punctuation">[</span><span class="token punctuation">,</span><span class="token punctuation">,</span><span class="token punctuation">,</span><span class="token punctuation">]</span><span class="token comment">//false</span>
</code></pre></div><p>ES5对空位处理很不一致，多数情况下回跳过空位。</p> <p><strong>ES6明确将空位转为undefined</strong></p> <h3 id="array-prototype-sort-的排序稳定性"><a href="#array-prototype-sort-的排序稳定性" class="header-anchor">#</a> Array.prototype.sort()的排序稳定性</h3> <p>排序稳定性指排序关键字相同的项目，排序前后的顺序不变。</p> <p>常见的排序算法中，插入排序、合并排序、冒泡排序等都是稳定的，堆排序、快速排序等都是不稳定的。</p> <p>Array.prototype.sort的稳定性由浏览器自己决定。</p> <h2 id="对象的扩展"><a href="#对象的扩展" class="header-anchor">#</a> 对象的扩展</h2> <p>ES6对对象进行了重大升级</p> <h3 id="属性的简洁表示法"><a href="#属性的简洁表示法" class="header-anchor">#</a> 属性的简洁表示法</h3> <p>ES6允许在大括号里面，直接写入变量和函数，作为对象的属性和方法。</p> <p>除了属性简洁，方法也可以简写。</p> <p>CommonJS模块输出一组变量，适合使用简洁的写法。</p> <p>属性的赋值器和取值器，事实上也是采用这种写法。</p> <h3 id="属性名表达式"><a href="#属性名表达式" class="header-anchor">#</a> 属性名表达式</h3> <p>ES6允许字面量定义对象时， 用[]作为对象的属性名，即把表达式放在中括号内。</p> <p>属性名表达式与简洁表示法不能同时使用，会报错。</p> <p>属性名表达式如果是一个对象，默认情况下会自动将对象转为字符串。</p> <div class="language-javascript extra-class"><pre class="language-javascript"><code><span class="token keyword">const</span> keyA <span class="token operator">=</span> <span class="token punctuation">{</span> a<span class="token operator">:</span> <span class="token number">1</span><span class="token punctuation">}</span>
<span class="token keyword">const</span> keyB <span class="token operator">=</span> <span class="token punctuation">{</span> b<span class="token operator">:</span> <span class="token number">2</span><span class="token punctuation">}</span>
<span class="token keyword">const</span> obj <span class="token operator">=</span> <span class="token punctuation">{</span>
    <span class="token punctuation">[</span>keyA<span class="token punctuation">]</span><span class="token operator">:</span> <span class="token string">'valueA'</span><span class="token punctuation">,</span>
    <span class="token punctuation">[</span>keyB<span class="token punctuation">]</span><span class="token operator">:</span> <span class="token string">'valueB'</span>
<span class="token punctuation">}</span>
obj<span class="token punctuation">;</span><span class="token comment">//[object Object]</span>
</code></pre></div><h3 id="方法name属性"><a href="#方法name属性" class="header-anchor">#</a> 方法name属性</h3> <p>函数name属性返回函数名，对象方法也是函数，因此也有name属性。</p> <p>如果对象的方法使用了取值函数和存值函数，则name属性不是在该方法上面，而是在该方法的属性描述对象的get和set属性上面，返回值是方法名前加上get和set</p> <div class="language-javascript extra-class"><pre class="language-javascript"><code><span class="token keyword">const</span> obj <span class="token operator">=</span> <span class="token punctuation">{</span>
    <span class="token keyword">get</span> <span class="token function">foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">,</span>
    <span class="token keyword">set</span> <span class="token function">foo</span><span class="token punctuation">(</span><span class="token parameter">x</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token keyword">const</span> descriptor <span class="token operator">=</span> Object<span class="token punctuation">.</span><span class="token function">getOwnPropertyDescriptor</span><span class="token punctuation">(</span>obj<span class="token punctuation">,</span> <span class="token string">'foo'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
descriptor<span class="token punctuation">.</span>get<span class="token punctuation">.</span>name <span class="token comment">//get.foo</span>
descriptor<span class="token punctuation">.</span>set<span class="token punctuation">.</span>name <span class="token comment">//set.foo</span>
</code></pre></div><p>有两种特殊情况：</p> <ul><li><p>bind方法创造的函数，name属性返回bound加上原函数的名字；</p></li> <li><p>Function构造函数创造的函数，name属性会返回anonymous</p></li></ul> <p>如果对象方法是一个Symbol值，那么name属性返回的时这个Symbol值得描述</p> <div class="language-javascript extra-class"><pre class="language-javascript"><code><span class="token keyword">const</span> key1 <span class="token operator">=</span> <span class="token function">Symbol</span><span class="token punctuation">(</span><span class="token string">'description'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">const</span> key2 <span class="token operator">=</span> <span class="token function">Symbol</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">let</span> obj <span class="token operator">=</span> <span class="token punctuation">{</span>
    <span class="token punctuation">[</span>key1<span class="token punctuation">]</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">,</span>
    <span class="token punctuation">[</span>key2<span class="token punctuation">]</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token punctuation">}</span>
<span class="token punctuation">}</span>
obj<span class="token punctuation">[</span>key1<span class="token punctuation">]</span><span class="token punctuation">.</span>name<span class="token punctuation">;</span><span class="token comment">//'[description]'</span>
obj<span class="token punctuation">[</span>key2<span class="token punctuation">]</span><span class="token punctuation">.</span>name<span class="token punctuation">;</span><span class="token comment">//''</span>
</code></pre></div><h3 id="属性的可枚举性和遍历"><a href="#属性的可枚举性和遍历" class="header-anchor">#</a> 属性的可枚举性和遍历</h3> <p>可枚举性：对象的每个属性都有一个描述对象，用来控制该属性的行为。</p> <div class="language-javascript extra-class"><pre class="language-javascript"><code><span class="token comment">//Object.getOwnPropertyDescriptor方法可以获取该属性的描述对象</span>
<span class="token keyword">let</span> obj <span class="token operator">=</span> <span class="token punctuation">{</span> foo<span class="token operator">:</span> <span class="token number">123</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
Object<span class="token punctuation">.</span><span class="token function">getOwnPropertyDescriptor</span><span class="token punctuation">(</span>obj<span class="token punctuation">,</span> <span class="token string">'foo'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">/*
{
	value: 123,
	writable: true,
	enumerable: true,
	configurable: true
}
*/</span>
</code></pre></div><p>描述对象的enumerable属性，称为可枚举性，若为false，就表示某些操作会忽略当前属性。</p> <p>目前，有四个操作会忽略enumberable为false的属性：</p> <ul><li>for ... in循环，只遍历对象自身和继承的可枚举的属性</li> <li>Object.keys()： 返回对象自身的所有可枚举的属性的键名</li> <li>JSON.stringify()：只串行化对象自身的可枚举属性</li> <li>Object.assign()：只拷贝对象自身的可枚举属性</li></ul> <p>ES6规定，所有Class的原型方法都是不可枚举的</p> <div class="language-javascript extra-class"><pre class="language-javascript"><code>Object<span class="token punctuation">.</span><span class="token function">getOwnPropertyDescriptor</span><span class="token punctuation">(</span><span class="token keyword">class</span> <span class="token punctuation">{</span> <span class="token function">foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">.</span>prototype<span class="token punctuation">,</span> <span class="token string">'foo'</span><span class="token punctuation">)</span><span class="token punctuation">.</span>enumerable
</code></pre></div><p>在操作中，引入继承属性会让问题复杂化，大多数时只关心对象本身的属性，尽量使用Object.key()代替for ... in。</p> <p><strong>ES6一共有5中方法可以遍历对象的属性</strong></p> <ul><li>for ... in</li> <li>Object.keys(obj) 返回一个数组，包含对象自身所有可枚举属性的键名，不含Symbol</li> <li>Object.getOwnPropertyNames(obj) 返回一个数组，包含对象自身属性的键名，不含Symbol属性，但包括不可枚举</li> <li>Object.getOwnProprttySymbols(obj) 返回一个包含对象自身Symbol属性的键名</li> <li>Reflect.ownKeys(obj) 返回一个数组，包含对象自身所有键名，不管是Symbol还是字符串，也不管是否可枚举</li></ul> <blockquote><p>Reflect.ownKeys 方法的属性顺序是：首先是数值型，其次是字符串属性，最后是Symbol属性</p></blockquote> <h3 id="super关键字"><a href="#super关键字" class="header-anchor">#</a> super关键字</h3> <p>this关键字总是指向函数所在的当前对象，ES6有新增super关键字，指向当前对象的原型对象。</p> <div class="language-javascript extra-class"><pre class="language-javascript"><code><span class="token keyword">const</span> proto <span class="token operator">=</span> <span class="token punctuation">{</span>
    foo<span class="token operator">:</span> <span class="token string">'hello'</span>
<span class="token punctuation">}</span>
<span class="token keyword">const</span> obj <span class="token operator">=</span> <span class="token punctuation">{</span>
    foo<span class="token operator">:</span> <span class="token string">'world'</span><span class="token punctuation">,</span>
    <span class="token function">find</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
        <span class="token keyword">return</span> <span class="token keyword">super</span><span class="token punctuation">.</span>foo<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
Object<span class="token punctuation">.</span><span class="token function">setPrototypeOf</span><span class="token punctuation">(</span>obj<span class="token punctuation">,</span> proto<span class="token punctuation">)</span><span class="token punctuation">;</span>
obj<span class="token punctuation">.</span><span class="token function">find</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//'hello'</span>
</code></pre></div><p>JavaScript引擎内部，super.foo等同于Object.getPrototypeOf(this).foo或Object.getPrototypeOf(this).foo.call(this)</p> <h3 id="对象的扩展运算符"><a href="#对象的扩展运算符" class="header-anchor">#</a> 对象的扩展运算符</h3> <p>ES2018将这个运算符引入了对象。</p> <p>对象解构赋值用于从一个对象取值，相当于将目标对象自身的所有可比案例的，单尚未被读取的属性，分配到指定的对象上面，所有的键和他们的值都被拷贝到新对象上面。</p> <blockquote><p>对象解构赋值要求等号右边是一个对象，所以若等号右边是undefined或null,就会报错，因为无法转为对象</p> <p>等号右边的不是对象，先自动转为对象</p> <p>解构赋值是浅拷贝，如果一个键值是复合类型的值，只拷贝这个值得引用，不是这个值得副本</p> <p>扩展运算符的解构赋值不能复制继承自原型对象的属性</p></blockquote> <div class="language-javascript extra-class"><pre class="language-javascript"><code><span class="token keyword">let</span> aClone <span class="token operator">=</span> <span class="token punctuation">{</span> <span class="token operator">...</span>a<span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token comment">//等同于</span>
<span class="token keyword">let</span> aClone <span class="token operator">=</span> Object<span class="token punctuation">.</span><span class="token function">assign</span><span class="token punctuation">(</span><span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">,</span> a<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><h3 id="链判断运算符"><a href="#链判断运算符" class="header-anchor">#</a> 链判断运算符</h3> <p>ES2020引入了链判断运算符 ?.</p> <div class="language-javascript extra-class"><pre class="language-javascript"><code><span class="token keyword">const</span> firstName <span class="token operator">=</span> message<span class="token operator">?.</span>body<span class="token operator">?.</span>user<span class="token operator">?.</span>firstName <span class="token operator">||</span> <span class="token string">'default'</span><span class="token punctuation">;</span>

<span class="token comment">//判断对象方法是否存在，存在立即执行</span>
iterator<span class="token punctuation">.</span>return<span class="token operator">?.</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
</code></pre></div><p>链判断运算符三种方法：</p> <ul><li>obj?.prop 对象属性</li> <li>obj?.[expr] 对象属性</li> <li>func?.(...args) 函数或对象方法调用</li></ul> <blockquote><p>注意：</p> <ul><li><p>短路机制，?.相当于是一种短路机制，不满足条件，就不会执行了</p></li> <li><p>delete运算符</p> <div class="language-javascript extra-class"><pre class="language-javascript"><code><span class="token keyword">delete</span> a<span class="token operator">?.</span>b
<span class="token comment">//等同于</span>
a <span class="token operator">===</span> <span class="token keyword">null</span> <span class="token operator">?</span> <span class="token keyword">undefined</span> <span class="token operator">:</span> <span class="token keyword">delete</span> a<span class="token punctuation">.</span>b
</code></pre></div></li> <li><p>括号的影响，链判断对圆括号外部没有影响，一般来说，使用?.场合就不应该使用圆括号</p></li> <li><p>右侧不得为十进制数值 ， 会看成小数点</p></li></ul></blockquote> <h3 id="null判断运算符"><a href="#null判断运算符" class="header-anchor">#</a> Null判断运算符</h3> <p>ES2020引入一个新的Null判断运算符??。类似||，但是只有运算符左侧的职位null或undefined才会返回右侧的值。</p> <p>可以配合?.使用，为null或undefined的值设置默认值</p> <div class="language-javascript extra-class"><pre class="language-javascript"><code><span class="token keyword">const</span> animationDuration <span class="token operator">=</span> response<span class="token punctuation">.</span>setting<span class="token operator">?.</span>animationDuration <span class="token operator">??</span> <span class="token number">300</span><span class="token punctuation">;</span>
</code></pre></div><p>这个运算符合适判断函数参数是否赋值</p> <p>与&amp;&amp;或||使用时，必须用括号表明优先级。</p> <h2 id="对象的新增方法"><a href="#对象的新增方法" class="header-anchor">#</a> 对象的新增方法</h2> <h3 id="object-is"><a href="#object-is" class="header-anchor">#</a> Object.is()</h3> <p>ES5比较两个值是否相等，有相等运算符和严格相等运算符。前者会自动转换类型，后者NaN不能等于自身，以及+0等于-0。</p> <p>ES6提出了同值相等算法，Object.is()，用来比较两个值是否严格相等。</p> <p>与===不同之处：+0不等于-0，NaN等于自身</p> <div class="language-javascript extra-class"><pre class="language-javascript"><code><span class="token operator">+</span><span class="token number">0</span> <span class="token operator">===</span> <span class="token operator">-</span><span class="token number">0</span><span class="token punctuation">;</span><span class="token comment">//true</span>
<span class="token number">NaN</span> <span class="token operator">===</span> <span class="token number">NaN</span><span class="token punctuation">;</span> <span class="token comment">//false</span>

Object<span class="token punctuation">.</span><span class="token function">is</span><span class="token punctuation">(</span><span class="token operator">+</span><span class="token number">0</span><span class="token punctuation">,</span> <span class="token operator">-</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// false</span>
Object<span class="token punctuation">.</span><span class="token function">is</span><span class="token punctuation">(</span><span class="token number">NaN</span><span class="token punctuation">,</span> <span class="token number">NaN</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//true</span>
</code></pre></div><p>ES5实现Object.is()</p> <div class="language-javascript extra-class"><pre class="language-javascript"><code>Object<span class="token punctuation">.</span><span class="token function">defineProperty</span><span class="token punctuation">(</span>Object<span class="token punctuation">,</span> <span class="token string">'is'</span><span class="token punctuation">,</span> <span class="token punctuation">{</span>
    <span class="token function-variable function">value</span><span class="token operator">:</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">x<span class="token punctuation">,</span> y</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
        <span class="token keyword">if</span><span class="token punctuation">(</span>x <span class="token operator">===</span> y<span class="token punctuation">)</span><span class="token punctuation">{</span>
            <span class="token comment">//针对+0不等于-0处理</span>
            <span class="token keyword">return</span> x<span class="token operator">!==</span><span class="token number">0</span> <span class="token operator">||</span> <span class="token number">1</span><span class="token operator">/</span>x <span class="token operator">===</span> <span class="token number">1</span><span class="token operator">/</span>y<span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        针对<span class="token number">NaN</span>处理
        <span class="token keyword">return</span> x <span class="token operator">!==</span> x <span class="token operator">&amp;&amp;</span> y <span class="token operator">!==</span> y<span class="token punctuation">;</span>
    <span class="token punctuation">}</span><span class="token punctuation">,</span>
    configurable<span class="token operator">:</span> <span class="token boolean">true</span><span class="token punctuation">,</span>
    enumerable<span class="token operator">:</span> <span class="token boolean">false</span><span class="token punctuation">,</span>
    writable<span class="token operator">:</span> <span class="token boolean">true</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span>
</code></pre></div><h3 id="object-assign"><a href="#object-assign" class="header-anchor">#</a> Object.assign()</h3> <p>Object.assign()方法用于对象的合并，将源对象的所有可枚举属性，复制到目标对象。</p> <p>第一个参数是目标对象，后面的参数都是源对象，后面的属性会覆盖前面的属性。</p> <p>如果不是参数，会先转为对象，对于首参null和undefined无法转对象的，直接报错，对于非首参且无法转对象的则直接跳过。</p> <div class="language-javascript extra-class"><pre class="language-javascript"><code>Object<span class="token punctuation">.</span><span class="token function">assign</span><span class="token punctuation">(</span>obj<span class="token punctuation">,</span> <span class="token keyword">undefined</span><span class="token punctuation">)</span> <span class="token operator">===</span> obj<span class="token punctuation">;</span><span class="token comment">//true</span>
</code></pre></div><p>对于数值、字符串、布尔值不在首参，也不会报错。除了字符串会以数组的形式，拷贝入目标对象，其他值都不会产生效果。</p> <p><strong>Object.assign只能拷贝源对象的自身属性，不能拷贝继承属性，也不能拷贝不可枚举属性</strong></p> <p>属性名为Symbol值得属性，也会被Object.assign拷贝。</p> <p>注意：</p> <ul><li><p>Object.assign是浅拷贝，即源对象某个属性的值是对象，则只拷贝这个对象的引用</p></li> <li><p>同名属性的替换，一旦遇到同名属性，处理方法是替换，而不是添加</p></li> <li><p>可以用来处理数组，将数组视为对象</p> <div class="language-javascript extra-class"><pre class="language-javascript"><code>Object<span class="token punctuation">.</span><span class="token function">assign</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">,</span><span class="token punctuation">[</span><span class="token number">4</span><span class="token punctuation">,</span><span class="token number">5</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//[4,5,3]</span>
</code></pre></div></li> <li><p>取值函数的处理，Object.assign只能进行值赋值，如果要复制的值是一个取值函数，那么将1求值后再复制。</p></li></ul> <p>常见用法：</p> <ol><li><p>为对象添加属性</p></li> <li><p>为对象添加方法</p></li> <li><p>克隆对象</p> <blockquote><p>只能克隆原始对象自身的值，不能克隆继承的值，可以用下面代码实现克隆继承：</p> <div class="language-javascript extra-class"><pre class="language-javascript"><code><span class="token keyword">function</span> <span class="token function">clone</span><span class="token punctuation">(</span><span class="token parameter">origin</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
    <span class="token keyword">let</span> originProto <span class="token operator">=</span> Object<span class="token punctuation">.</span><span class="token function">getPrototypeOf</span><span class="token punctuation">(</span>origin<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> Object<span class="token punctuation">.</span><span class="token function">assign</span><span class="token punctuation">(</span>Object<span class="token punctuation">.</span><span class="token function">create</span><span class="token punctuation">(</span>originPorot<span class="token punctuation">)</span><span class="token punctuation">,</span> origin<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div></blockquote></li> <li><p>合并多个对象</p> <div class="language-javascript extra-class"><pre class="language-javascript"><code><span class="token keyword">const</span> <span class="token function-variable function">merge</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token parameter"><span class="token operator">...</span>sources</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> Object<span class="token punctuation">.</span><span class="token function">assign</span><span class="token punctuation">(</span><span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token operator">...</span>source<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div></li> <li><p>为属性指定默认值</p></li></ol> <h3 id="object-getownpropertydescriptors"><a href="#object-getownpropertydescriptors" class="header-anchor">#</a> Object.getOwnPropertyDescriptors()</h3> <p>ES5中Object.getOwnPropertyDescriptor返回某个对象属性的描述对象。</p> <p>ES2017引入Object.getOwnPropertyDescriptors返回指定对象所有自身属性（非继承）的描述对象。</p> <div class="language-javascript extra-class"><pre class="language-javascript"><code><span class="token keyword">function</span> <span class="token function">getOwnPropertyDescriptors</span><span class="token punctuation">(</span><span class="token parameter">obj</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
    <span class="token keyword">const</span> result <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
    <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">let</span> key <span class="token keyword">of</span> Reflect<span class="token punctuation">.</span><span class="token function">ownKeys</span><span class="token punctuation">(</span>obj<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">{</span> <span class="token comment">//返回一个对象的所有键名</span>
        result<span class="token punctuation">[</span>key<span class="token punctuation">]</span> <span class="token operator">=</span> Object<span class="token punctuation">.</span><span class="token function">getOwnPropertyDescriptor</span><span class="token punctuation">(</span>obj<span class="token punctuation">,</span> key<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">return</span> result<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><p>该方法引入的目的，主要解决Object.assign无法正确拷贝get和set属性的问题：</p> <div class="language-javascript extra-class"><pre class="language-javascript"><code><span class="token keyword">const</span> source <span class="token operator">=</span> <span class="token punctuation">{</span>
    <span class="token keyword">set</span> <span class="token function">foo</span><span class="token punctuation">(</span><span class="token parameter">value</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
        console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>value<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token keyword">const</span> target <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
Object<span class="token punctuation">.</span><span class="token function">defineProperties</span><span class="token punctuation">(</span>target<span class="token punctuation">,</span> Object<span class="token punctuation">.</span><span class="token function">getOwnPropertyDescriptors</span><span class="token punctuation">(</span>source<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
Object<span class="token punctuation">.</span><span class="token function">getOwnPropertyDescriptor</span><span class="token punctuation">(</span>target<span class="token punctuation">,</span> <span class="token string">'foo'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><p>另一个用处是配合Object.create方法，将对象属性克隆岛一个新对象，属于浅拷贝。</p> <div class="language-javascript extra-class"><pre class="language-javascript"><code><span class="token keyword">const</span> clone <span class="token operator">=</span> Object<span class="token punctuation">.</span><span class="token function">create</span><span class="token punctuation">(</span>Object<span class="token punctuation">.</span><span class="token function">getPrototypeOf</span><span class="token punctuation">(</span>obj<span class="token punctuation">)</span><span class="token punctuation">,</span> Object<span class="token punctuation">.</span><span class="token function">getOwnPropertyDescriptors</span><span class="token punctuation">(</span>obj<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><p>Object.getOwnPropertyDescriptors方法可以实现一个对象继承另一个对象。</p> <div class="language-javascript extra-class"><pre class="language-javascript"><code><span class="token comment">//以前写法</span>
<span class="token keyword">const</span> obj <span class="token operator">=</span> Object<span class="token punctuation">.</span><span class="token function">assign</span><span class="token punctuation">(</span>
  	Object<span class="token punctuation">.</span><span class="token function">create</span><span class="token punctuation">(</span>prot<span class="token punctuation">)</span><span class="token punctuation">,</span>
    <span class="token punctuation">{</span>
        foo<span class="token operator">:</span> <span class="token number">123</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">)</span>
<span class="token comment">//现在写法</span>
<span class="token keyword">const</span> obj <span class="token operator">=</span> Object<span class="token punctuation">.</span><span class="token function">create</span><span class="token punctuation">(</span>prot<span class="token punctuation">,</span> Object<span class="token punctuation">.</span><span class="token function">getOwnPropertyDescriptors</span><span class="token punctuation">(</span><span class="token punctuation">{</span>foo<span class="token operator">:</span><span class="token number">123</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><p>实现混入模式Mixin</p> <div class="language-javascript extra-class"><pre class="language-javascript"><code><span class="token keyword">let</span> <span class="token function-variable function">mix</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token parameter">object</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">(</span><span class="token punctuation">{</span>
    <span class="token function-variable function">with</span><span class="token operator">:</span> <span class="token punctuation">(</span><span class="token parameter"><span class="token operator">...</span>mixins</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> mixins<span class="token punctuation">.</span><span class="token function">reduce</span><span class="token punctuation">(</span>
    	<span class="token punctuation">(</span><span class="token parameter">c<span class="token punctuation">,</span> mixin</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> Object<span class="token punctuation">.</span><span class="token function">create</span><span class="token punctuation">(</span>
        	c<span class="token punctuation">,</span> Object<span class="token punctuation">.</span><span class="token function">getOwnPropertyDescriptors</span><span class="token punctuation">(</span>mixin<span class="token punctuation">)</span>
        <span class="token punctuation">)</span><span class="token punctuation">,</span> object<span class="token punctuation">)</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token keyword">let</span> a <span class="token operator">=</span> <span class="token punctuation">{</span> a<span class="token operator">:</span> <span class="token string">'a'</span><span class="token punctuation">}</span>
<span class="token keyword">let</span> b <span class="token operator">=</span> <span class="token punctuation">{</span> b<span class="token operator">:</span> <span class="token string">'b'</span><span class="token punctuation">}</span>
<span class="token keyword">let</span> c <span class="token operator">=</span> <span class="token punctuation">{</span> c<span class="token operator">:</span> <span class="token string">'c'</span><span class="token punctuation">}</span>
<span class="token keyword">let</span> d <span class="token operator">=</span> <span class="token function">mix</span><span class="token punctuation">(</span>c<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">with</span><span class="token punctuation">(</span>a<span class="token punctuation">,</span>b<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><h3 id="proto-属性，object-setprototypeof-object-getprototypeof"><a href="#proto-属性，object-setprototypeof-object-getprototypeof" class="header-anchor">#</a> __proto__属性，Object.setPrototypeOf(),Object.getPrototypeOf()</h3> <p>JavaScript语言的对象继承是通过原型链实现的</p> <p>ES6提供了原型对象的操作方法</p> <p>__proto__是一个内部属性，该属性的值就是对象的原型，一般情况下使用Object.setPrototypeOf、Object.getPrototypeOf()、Object.create()代替。</p> <p>Object.setPrototypeOf方法的作用与__protot__相同，用来设置一个对象的原型对象，返回参数对象本身。</p> <p>这个方法是ES6正式推荐设置原型的方法。</p> <div class="language-javascript extra-class"><pre class="language-javascript"><code>Object<span class="token punctuation">.</span><span class="token function">setPrototypeOf</span><span class="token punctuation">(</span>object<span class="token punctuation">,</span> prototype<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">const</span> o <span class="token operator">=</span> Object<span class="token punctuation">.</span><span class="token function">setPrototypeOf</span><span class="token punctuation">(</span><span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token keyword">null</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><p>Object.getPrototypeOf()用于读取一个对象的原型对象。</p> <div class="language-javascript extra-class"><pre class="language-javascript"><code>Object<span class="token punctuation">.</span><span class="token function">getPtototypeOf</span><span class="token punctuation">(</span>obj<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">//如果参数不是对象，则自动转为对象</span>
<span class="token comment">//如果参数为undefined或null，则报错</span>
</code></pre></div><h3 id="object-keys-object-values-object-entries"><a href="#object-keys-object-values-object-entries" class="header-anchor">#</a> Object.keys(), Object.values(), Object.entries()</h3> <p>Object.keys方法返回一个数组，成员是参数对象自身的所有可比案例属性的键名</p> <p>Object.values和Object.entries作为一个对象的补充手段，供for ...of循环使用。</p> <p>Object.values返回一个数组，成员是参数对象自身所有可遍历（enurmerable）属性的键值</p> <div class="language-javascript extra-class"><pre class="language-javascript"><code><span class="token keyword">const</span> obj <span class="token operator">=</span> Object<span class="token punctuation">.</span><span class="token function">create</span><span class="token punctuation">(</span><span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token punctuation">{</span> p<span class="token operator">:</span> <span class="token punctuation">{</span>value<span class="token operator">:</span><span class="token number">42</span><span class="token punctuation">}</span><span class="token punctuation">}</span><span class="token punctuation">)</span>
</code></pre></div><p>Object.create方法的第二个参数添加的对象属性，如果不显示声明，默认是不可遍历的（enurmerable:fa;se）</p> <p>object.values会过滤属性名为Symbol值得属性</p> <p>Object.entries()返回一个数组，成员是参数对象自身的所有可遍历属性的键值对数组。</p> <p>如果原对象的属性名是一个Symbol值，该属性会被忽略。</p> <p>Object.entries的基本用途是遍历对象属性。</p> <p>Object.entries的另一个用处是将对象转为真正的Map解构：</p> <div class="language-javascript extra-class"><pre class="language-javascript"><code><span class="token keyword">const</span> obj <span class="token operator">=</span> <span class="token punctuation">{</span> foo<span class="token operator">:</span> <span class="token string">'bar'</span><span class="token punctuation">,</span> baz<span class="token operator">:</span> <span class="token number">42</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token keyword">const</span> map <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Map</span><span class="token punctuation">(</span>Object<span class="token punctuation">.</span><span class="token function">entries</span><span class="token punctuation">(</span>obj<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><p>**Object.fromEntries()**是方法Object.entries()的逆操作，用于将一个键值对数组转为对象。</p> <div class="language-javascript extra-class"><pre class="language-javascript"><code><span class="token keyword">const</span> entries <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Map</span><span class="token punctuation">(</span><span class="token punctuation">[</span>
    <span class="token punctuation">[</span><span class="token string">'foo'</span><span class="token punctuation">,</span> <span class="token string">'bar'</span><span class="token punctuation">]</span><span class="token punctuation">,</span>
    <span class="token punctuation">[</span><span class="token string">'baz'</span><span class="token punctuation">,</span> <span class="token number">42</span><span class="token punctuation">]</span>
<span class="token punctuation">]</span><span class="token punctuation">)</span>
Object<span class="token punctuation">.</span><span class="token function">fromEntries</span><span class="token punctuation">(</span>entries<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//{foo: 'bar', baz: 42}</span>

<span class="token keyword">const</span> map <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Map</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">set</span><span class="token punctuation">(</span><span class="token string">'foo'</span><span class="token punctuation">,</span> <span class="token boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">set</span><span class="token punctuation">(</span><span class="token string">'bar'</span><span class="token punctuation">,</span>flase<span class="token punctuation">)</span><span class="token punctuation">;</span>
Object<span class="token punctuation">.</span><span class="token function">fromEntries</span><span class="token punctuation">(</span>map<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><p>配合<strong>URLSearchParams</strong>对象，将查询字符串转为对象</p> <p>Object.fromEntries(new URLSearchParams('foo=bar&amp;baz=que'))</p> <h2 id="symbol"><a href="#symbol" class="header-anchor">#</a> Symbol</h2> <p>ES6引入了一种新的原始数据类型Symbol，表示独一无二的值，是第七种数据类型。</p> <blockquote><ul><li>undefined</li> <li>null</li> <li>boolean</li> <li>string</li> <li>number</li> <li>object</li> <li>symbol</li></ul></blockquote> <p>Symbol的值通过Symbol函数生成，即对象的属性名现在可以有两种类型：</p> <ul><li>字符串类型</li> <li>Symbol类型</li></ul> <div class="language-javascript extra-class"><pre class="language-javascript"><code><span class="token keyword">let</span> s <span class="token operator">=</span> <span class="token function">Symbol</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">typeof</span> s<span class="token punctuation">;</span><span class="token comment">//symbol</span>
</code></pre></div><p>注意：Symbol函数前不能使用new命令，这是因为生成Symbol是一个原始类型的值，不是对象，即Symbol值不是对象，所以不能添加属性。</p> <p>Symbol函数可以接受一个字符串作为参数，表示对Symbol实例的描述，主要是为了控制台显示，转字符串时区分。</p> <p>如果Symbol参数是一个对象，就会调用该对象的toString方法，转为字符串，然后再生成Symbol值。</p> <p>Symbol函数的参数只是表示对当前Symbol值的描述，相同参数的Symbol函数的返回值是不相等的。</p> <div class="language-javascript extra-class"><pre class="language-javascript"><code><span class="token keyword">let</span> s1 <span class="token operator">=</span> <span class="token function">Symbol</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">let</span> s2 <span class="token operator">=</span> <span class="token function">Symbol</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
s1 <span class="token operator">===</span> s2<span class="token punctuation">;</span><span class="token comment">//false</span>
</code></pre></div><p>Symbol值不能与其他类型的值进行运算，但是可以显示转为字符串，布尔值。（不能转为数值）</p> <h3 id="symbol-prototype-description"><a href="#symbol-prototype-description" class="header-anchor">#</a> Symbol.prototype.description</h3> <p>创建Symbol的时候，可以添加一个描述。</p> <p>ES2019提供了一个实例属性的description，直接返回Symbol的描述</p> <div class="language-javascript extra-class"><pre class="language-javascript"><code><span class="token keyword">const</span> sym <span class="token operator">=</span> <span class="token function">Symbol</span><span class="token punctuation">(</span><span class="token string">'foo'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
sym<span class="token punctuation">.</span>description <span class="token comment">//'foo'</span>
</code></pre></div><h3 id="作为属性名的symbol"><a href="#作为属性名的symbol" class="header-anchor">#</a> 作为属性名的Symbol</h3> <p>由于每个Symbol值都是不相等的，就能保证不会出现同名属性，这对于一个对象由多个模块构成，防止某一个键被覆盖。</p> <p>Symbol值作为对象属性名时，不能用电运算符。</p> <p>Symbol类型可以用于定义一组常量，保证这组常量的值都是不相等的。</p> <p>常量使用Symbol值最大的好处，就是任何其他值都不会有相同的值了。</p> <h3 id="消除魔术字符串"><a href="#消除魔术字符串" class="header-anchor">#</a> 消除魔术字符串</h3> <p>魔术字符串是指在代码中多次出现，与代码形成强耦合的某个具体字符串或数值。</p> <h3 id="属性的遍历"><a href="#属性的遍历" class="header-anchor">#</a> 属性的遍历</h3> <p>Symbol作为属性名，遍历对象的时候，该属性不会出现在for...in,for...of循环中，也不会被Object.keys，Object.getOwnPropertyNames()，JSON.stringify()返回。</p> <p>通过Object.getOwnPropertySymbols方法可以获取指定对象的所有Symbol属性名。</p> <p>Reflect.ownKeys()方法可以返回所有类型的键名，包括常规键名和Symbol键名。</p> <p>可以利用Symbol值作为键名不会被常规方法遍历的特性，为对象定义些非私有的，但只用于内部的方法。</p> <h3 id="symbol-for-，symbol-keyfor"><a href="#symbol-for-，symbol-keyfor" class="header-anchor">#</a> Symbol.for()，Symbol.keyFor()</h3> <p>使用同一个Symbol值，Symbol.for()方法可以做到。</p> <p>接受一个字符串作为参数，然后搜索有没有以该参数作为名称的Symbol值。如果有，返回这个Symbol的值，否则新建一个以该字符串为名称的Symbol值，并注册到全局。</p> <div class="language-javascript extra-class"><pre class="language-javascript"><code><span class="token keyword">let</span> s1 <span class="token operator">=</span> Symbol<span class="token punctuation">.</span><span class="token function">for</span><span class="token punctuation">(</span><span class="token string">'foo'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">let</span> s2 <span class="token operator">=</span> Symbol<span class="token punctuation">.</span><span class="token function">for</span><span class="token punctuation">(</span><span class="token string">'foo'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
s1 <span class="token operator">===</span> s2<span class="token punctuation">;</span><span class="token comment">//true</span>
</code></pre></div><h3 id="模块的singleton模式"><a href="#模块的singleton模式" class="header-anchor">#</a> 模块的Singleton模式</h3> <p>Singleton模式指调用一个类，任何时候返回的都是同一个实例。</p> <p>对于Node来说，模块文件可以看出一个类。</p> <div class="language-javascript extra-class"><pre class="language-javascript"><code><span class="token comment">//mod.js</span>
<span class="token keyword">const</span> <span class="token constant">FOO_KEY</span> <span class="token operator">=</span> <span class="token function">Symbol</span><span class="token punctuation">(</span><span class="token string">'foo'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">function</span> <span class="token constant">A</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
	<span class="token keyword">this</span><span class="token punctuation">.</span>foo <span class="token operator">=</span> <span class="token string">'hello'</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token keyword">if</span><span class="token punctuation">(</span><span class="token operator">!</span>global<span class="token punctuation">[</span><span class="token constant">FOO_KEY</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
    global<span class="token punctuation">[</span><span class="token constant">FOO_KEY</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">A</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

module<span class="token punctuation">.</span>export <span class="token operator">=</span> global<span class="token punctuation">[</span><span class="token constant">FOO_KEY</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
</code></pre></div><h3 id="内置symbol值"><a href="#内置symbol值" class="header-anchor">#</a> 内置Symbol值</h3> <ul><li><p>Symbol.hasInstance 指向一个内部方法，当其他对象使用instanceof运算符是，判断是否为该对象实例的时，会调用这个方法。</p></li> <li><p>对象的Symbol.isConcatSpreadable 属性等于一个布尔值，表示该对象用于Array.prototype.concat时，是否可以展开。</p></li> <li><p>对象的Symbol.species属性指向一个构造函数，创建衍生对象时，会使用该对象。</p></li> <li><p>对象的Symbol.match属性指向一个函数，当执行str.match(obj)时，如果该属性存在，会调用它，返回该方法的返回值。</p></li> <li><p>对象Symbol.replace属性，指向一个方法，当该对象被String.prototype.replace方法调用时，会返回该方法的返回值。</p></li> <li><p>对象Symbol.search属性，指向一个方法，当该对象被String.prototype.search方法调用时，返回该方法的返回值</p></li> <li><p>对象Symbol.split属性，指向一个方法，当该对象被String.prototype.split方法调用时，返回该方法的返回值。</p></li> <li><p>对象Symbol.iterator属性，指向该对象的默认遍历器方法。对象进行for...of循环是，会调用Symbol.iterator方法，返回该对象的默认遍历器。</p></li> <li><p>对象Symbol.toPrimitive属性，指向一个方法，该对象被转为原始类型的值时，会调用这个方法，返回该对象对应的原始类型值。</p> <blockquote><p>Symbol.toPrimitive被调用时，会接受一个字符串参数，表示当前的运算模式：</p> <ul><li>Number：该场合需要转为数值</li> <li>String：转为字符串</li> <li>Default：转成数值也可以转为字符串</li></ul></blockquote></li> <li><p>对象Symbol.toStringTag属性，指向一个方法。在该对象上面调用Object.prototype.toString方法时，如果这个属性存在，返回值出现在toString方法返回的字符串中，表示对象类型。这个属性用来定制[object Object]或[object Array]中object后面的那个字符串。</p></li> <li><p>对象Symbol.unscopables属性，指向一个对象，该对象指定使用with关键字时，那些属性被with环境排除。</p> <div class="language-javascript extra-class"><pre class="language-javascript"><code><span class="token class-name">Array</span><span class="token punctuation">.</span>prototype<span class="token punctuation">[</span>Symbol<span class="token punctuation">.</span>unscopables<span class="token punctuation">]</span><span class="token punctuation">;</span>
</code></pre></div></li></ul> <h2 id="set和map数据结构"><a href="#set和map数据结构" class="header-anchor">#</a> Set和Map数据结构</h2> <h3 id="set"><a href="#set" class="header-anchor">#</a> Set</h3> <p>ES6提供了新的数据结构Set，类似于数组，但是成员的值都是唯一的。</p> <p>Set本身是一个构造函数，用来生成Set数据结构。</p> <p>Set函数可以接受一个数组或具有iterable接口的其他数据结构作为参数，用来初始化。</p> <p>向Set加入值的识货，不会发生类型转换，5和'5'是两个不同的值。</p> <p>在Set内部，NaN是相等的，两个对象总是不相等的。</p> <p><strong>Set实例的属性和方法</strong></p> <ul><li>Set.prototype.constructor: 构造函数，默认就是Set函数</li> <li>Set.prototype.size 返回Set实例成员的总数。</li> <li>Set.prototype.add(value) 添加某个值，返回Set结构本身</li> <li>Set.prototype.delete(value) 删除某个值，返回一个布尔值，表示是否删除成功</li> <li>Set.prototype.has(value) 返回一个布尔值，表示该值是否为Set的成员</li> <li>Set.prototype.clear() 清除所有成员，没有返回值</li></ul> <p><strong>遍历操作</strong></p> <p>Set结构的实例有四个遍历方法，可用于遍历成员：</p> <ul><li>Set.prototype.keys</li> <li>Set.prototype.values</li> <li>Set.prototype.entries</li> <li>Set.prototype.forEach</li></ul> <p>Set遍历的顺序就是插入的顺序</p> <p>扩展运算符内部使用for...of循环，所有也可以用于Set结构，所以使用Set容易实现并集、交集、差集。</p> <p>遍历过程中，同步改变原来的Set结构：</p> <ol><li><p>利用原Set结构映射出一个新的结构，然后赋值给原来的Set</p></li> <li><p>利用Array.from方法</p> <div class="language-javascript extra-class"><pre class="language-javascript"><code><span class="token keyword">let</span> set <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Set</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
set <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Set</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token operator">...</span>set<span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">map</span><span class="token punctuation">(</span><span class="token parameter">val</span> <span class="token operator">=&gt;</span> val<span class="token operator">*</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

set <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Set</span><span class="token punctuation">(</span>Array<span class="token punctuation">.</span><span class="token function">from</span><span class="token punctuation">(</span>set<span class="token punctuation">,</span> <span class="token parameter">val</span> <span class="token operator">=&gt;</span>val <span class="token operator">*</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
</code></pre></div></li></ol> <h3 id="weakset"><a href="#weakset" class="header-anchor">#</a> WeakSet</h3> <p>与Set结构类似，区别：</p> <ul><li><p>WeakSet成员只能是对象，不能是其他类型</p></li> <li><p>WeakSet中的对象都是弱引用，即垃圾回收机制会自动回收该对象所用的内存，不考虑该对象还存在WeakSet中</p> <blockquote><p>垃圾回收机制以来引用计数，如果引用次数不为0，就不会释放这块内存。</p> <p>WeakSet里面的引用，都不计入垃圾回收机制</p></blockquote></li></ul> <p>ES6规定WeakSet不可遍历。</p> <p>WeakSet结构方法：</p> <ul><li>WeakSet.prototype.add(value)</li> <li>WeakSet.prototype.delete(value)</li> <li>WeakSet.prototype.has(value)</li></ul> <h3 id="map"><a href="#map" class="header-anchor">#</a> Map</h3> <p>JavaScript的对象Object，本质上是键值对的集合，但是传统上只能用字符串当做键，所以有很大限制。</p> <p>ES6提供了Map数据结构，类似对象，也是键值对的集合。</p> <p>如果需要使用键值对的数据结构，Map比Object更合适。</p> <p>任何具有Iterator接口且每个成员都是一个双元素的数组的数据结构，够可以当做Map构造函数的参数，Set和Map都可以用来生成新的Map。</p> <p>Map的键实际上是和内存地址绑定的，只要内存地址不一样，就视为两个键。</p> <p>若Map的键是一个简单类型的值，则只要两个值严格相等，Map视为一个键，例如：0和-0就是一个键，NaN视为一个键</p> <p><strong>实例的属性和方法</strong></p> <ul><li>size 返回Map结构的成员总数</li> <li>Map.prototype.set(key, value)</li> <li>Map.prototype.get(key)</li> <li>Map.prototype.has(key)</li> <li>Map.prototype.delete(key)</li> <li>Map.prototype.clear()</li></ul> <p><strong>遍历方法</strong></p> <ul><li>Map.prototype.keys()</li> <li>Map.prototype.values()</li> <li>Map.prototype.entries()</li> <li>Map.prototype.forEach()</li></ul> <p>Map的遍历顺序就是插入顺序</p> <p>Map结构转数组结构，比较快速的方法是扩展运算符</p> <p>结合数组map方法，filter方法，可以实现Map的遍历和过滤</p> <p>与其他数据结构相互转换：</p> <ul><li>Map转数组</li> <li>数组转Map</li> <li>Map转对象</li> <li>对象转Map</li> <li>Map转JSON</li> <li>JSON转Map</li></ul> <h3 id="weakmap"><a href="#weakmap" class="header-anchor">#</a> WeakMap</h3> <p>结构与Map类似，用于生产键值对的集合。</p> <p>与Map区别：</p> <ul><li>WeakMap值接受对象作为键名（null除外），不能结构其他类型的值作为键名</li> <li>WeakMap的键名所指向的对象，不计入垃圾回收机制</li></ul> <p>WeakMap设计的目的在于，若想在某个对象上面存放一些数据，但会形成对这个对象的引用，一旦不需要，则必须手动删除这个引用，否则垃圾回收机制不会释放内存。</p> <p>即往对象上添加数据，有不干扰垃圾回收机制，就是用WeakMap。</p> <p>典型应用：在网页DOM元素上添加数据，当DOM元素被清除是，对应的WeakMap记录也自动被移除。</p> <div class="language-javascript extra-class"><pre class="language-javascript"><code><span class="token keyword">const</span> wm <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">WeakMap</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">const</span> element <span class="token operator">=</span> document<span class="token punctuation">.</span><span class="token function">getElementById</span><span class="token punctuation">(</span><span class="token string">'example'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
wm<span class="token punctuation">.</span><span class="token function">set</span><span class="token punctuation">(</span>element<span class="token punctuation">,</span> <span class="token string">'some information'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
wm<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>element<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><p>WeakMap的专用场合就是，它的键所对应的对象，可能会在将来消失。WeakMap结构有助于防止内存泄漏。</p> <h2 id="proxy"><a href="#proxy" class="header-anchor">#</a> Proxy</h2> <p>Proxy用于修改某些操作的默认行为，等同于在语言层面作出修改，属于一种&quot;<strong>元编程</strong>&quot;，即对编程语言进行编程。</p> <p>Proxy在目标对象之前有一层拦截，外界对该对象的访问，都必须通过这层拦截，所以可以对外界的访问进行<strong>过滤和改写</strong>。</p> <div class="language-javascript extra-class"><pre class="language-javascript"><code><span class="token keyword">var</span> obj <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Proxy</span><span class="token punctuation">(</span><span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token punctuation">{</span>
    <span class="token function-variable function">get</span><span class="token operator">:</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">target<span class="token punctuation">,</span> propKey<span class="token punctuation">,</span> receiver</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
        consonle<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token template-string"><span class="token template-punctuation string">`</span><span class="token string">getting </span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span>propKey<span class="token interpolation-punctuation punctuation">}</span></span><span class="token template-punctuation string">`</span></span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">return</span> Reflect<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>target<span class="token punctuation">,</span> propKey<span class="token punctuation">,</span> receiver<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span><span class="token punctuation">,</span>
    <span class="token function-variable function">set</span><span class="token operator">:</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">target<span class="token punctuation">,</span> propKey<span class="token punctuation">,</span>value<span class="token punctuation">,</span> receiver</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
        constole<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token template-string"><span class="token template-punctuation string">`</span><span class="token string">setting </span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span>propKey<span class="token interpolation-punctuation punctuation">}</span></span><span class="token template-punctuation string">`</span></span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">return</span> Relect<span class="token punctuation">.</span><span class="token function">set</span><span class="token punctuation">(</span>target<span class="token punctuation">,</span> propKey<span class="token punctuation">,</span> value<span class="token punctuation">,</span> receiver<span class="token punctuation">)</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token comment">//重新定义了属性的读写行为。</span>
</code></pre></div><p>ES6原生提供了Proxy构造函数，用来生成Proxy实例。</p> <div class="language-javascript extra-class"><pre class="language-javascript"><code><span class="token keyword">var</span> proxy <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Proxy</span><span class="token punctuation">(</span>target<span class="token punctuation">,</span> handler<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">//target参数表示要拦截的目标对象</span>
<span class="token comment">//handler参数是一个对象，用来定义拦截行为</span>
</code></pre></div><p>注意：</p> <ul><li>要使得Proxy起作用，必须针对Proxy实例进行操作，而不是针对目标对象。</li> <li>如果没有handler设置拦截，则直接通向原对象</li></ul> <div class="language-javascript extra-class"><pre class="language-javascript"><code><span class="token keyword">var</span> proxy <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Proxy</span><span class="token punctuation">(</span><span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token punctuation">{</span>
    <span class="token function-variable function">get</span><span class="token operator">:</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">target<span class="token punctuation">,</span> propKey</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
        <span class="token keyword">return</span> <span class="token number">22</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span>
proxy<span class="token punctuation">.</span>time<span class="token comment">//22</span>
proxy<span class="token punctuation">.</span>name<span class="token comment">//22  对proxy实例操作</span>
</code></pre></div><p><strong>技巧</strong>：将Proxy对象，设置到object.proxy属性，从而可以在object对象上调用。</p> <div class="language-javascript extra-class"><pre class="language-javascript"><code><span class="token keyword">var</span> object <span class="token operator">=</span> <span class="token punctuation">{</span> proxy<span class="token operator">:</span> <span class="token keyword">new</span> <span class="token class-name">Proxy</span><span class="token punctuation">(</span>target<span class="token punctuation">,</span> handler<span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre></div><p>Proxy实例也可以作为其他对象的原型对象。</p> <div class="language-javascript extra-class"><pre class="language-javascript"><code><span class="token keyword">var</span> proxy <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Proxy</span><span class="token punctuation">(</span><span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">,</span><span class="token punctuation">{</span>
    <span class="token function-variable function">get</span><span class="token operator">:</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">target<span class="token punctuation">,</span> propKey</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
        <span class="token keyword">return</span> <span class="token number">33</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span>
<span class="token keyword">let</span> obj <span class="token operator">=</span> Object<span class="token punctuation">.</span><span class="token function">create</span><span class="token punctuation">(</span>proxy<span class="token punctuation">)</span><span class="token punctuation">;</span>
obj<span class="token punctuation">.</span>time <span class="token comment">//33</span>
<span class="token comment">//proxy对象是obj对象的原型，obj对象本身没有time属性，根据原型链，会在proxy对象上读取该属性，导致被拦截。</span>
</code></pre></div><p><strong>Proxy支持的拦截操作：</strong></p> <ul><li>get(target, propKey, receiver) 拦截读取对象</li> <li>set(target, propKey, value, receiver) 拦截对象属性的设置</li> <li>has(target, propKey) 拦截prop in proxy操作，返回布尔值</li> <li>deleteProperty(target, propKey) 拦截 delete proxy[propKey]操作，返回布尔值</li> <li>ownKeys(target) 拦截 Object.getOwnPropertyNames(proxy)、Object.getOwnPropertySymbols(proxy)、Object.keys(proxy)、for ... in 循环，返回一个数组。返回目标对象所有自身的属性的属性名。Object.keys()返回结果仅包括目标对象自身可遍历的属性</li> <li>getOwnPropertyDescriptor(target, propKey)拦截Object.getOwnPropertyDescriptor(proxy,propKey)，返回属性的描述对象</li> <li>defineProperty(target, propKey, propDesc) 拦截Object.defineProperty(proxy,propKey,propDesc)、Object.defineProperties(proxy,propDescs) 返回一个布尔值。</li> <li>preventExtensions(target) 拦截Object.preventExtensions(proxy)，返回一个布尔值</li> <li>getPrototypeOf(target) 拦截Object.getPrototypeOf(proxy)，返回一个对象</li> <li>isExtensible(target) 拦截Object.isExtensible(proxy)，返回一个布尔值</li> <li>setPrototypeOd(target,  proto) 拦截Object.setPtototypeOf(proxy,proto)，返回一个布尔值</li> <li>apply(target, object, args) 拦截Proxy实例走位函数调用的操作 proxy(...args)、proxy.call(object, ...args)、proxy.apply(...)</li> <li>construct(target, args) 拦截Proxy实例作为构造函数调用的操作，new proxy(...args)</li></ul> <h3 id="proxy实例方法"><a href="#proxy实例方法" class="header-anchor">#</a> Proxy实例方法</h3> <p>get方法用于拦截某个属性的读取操作，接受三个参数：目标对象，属性名和proxy实例本身（操作行为所针对的对象，可选）</p> <div class="language-javascript extra-class"><pre class="language-javascript"><code><span class="token keyword">var</span> person <span class="token operator">=</span> <span class="token punctuation">{</span>
    name<span class="token operator">:</span> <span class="token string">'larry'</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token keyword">var</span> proxy <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Proxy</span><span class="token punctuation">(</span>person<span class="token punctuation">,</span> <span class="token punctuation">{</span>
    <span class="token function-variable function">get</span><span class="token operator">:</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">target<span class="token punctuation">,</span> propKey<span class="token punctuation">,</span> receiver</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
        <span class="token keyword">if</span><span class="token punctuation">(</span>propKey <span class="token keyword">in</span> target<span class="token punctuation">)</span><span class="token punctuation">{</span>
            <span class="token keyword">return</span> target<span class="token punctuation">[</span>propKey<span class="token punctuation">]</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span><span class="token keyword">else</span><span class="token punctuation">{</span>
            <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">ReferenceError</span><span class="token punctuation">(</span><span class="token template-string"><span class="token template-punctuation string">`</span><span class="token string">Prop name </span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span>propKey<span class="token interpolation-punctuation punctuation">}</span></span><span class="token string"> does not exist.</span><span class="token template-punctuation string">`</span></span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span>
</code></pre></div><div class="language-javascript extra-class"><pre class="language-javascript"><code><span class="token comment">//读取数组的负数索引</span>
<span class="token keyword">function</span> <span class="token function">createArray</span><span class="token punctuation">(</span><span class="token parameter"><span class="token operator">...</span>elements</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
    <span class="token keyword">let</span> handler <span class="token operator">=</span> <span class="token punctuation">{</span>
        <span class="token function">get</span><span class="token punctuation">(</span>target<span class="token punctuation">,</span> propKey<span class="token punctuation">,</span> receiver<span class="token punctuation">)</span><span class="token punctuation">{</span>
            <span class="token keyword">let</span> index <span class="token operator">=</span> <span class="token function">Number</span><span class="token punctuation">(</span>propKey<span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token keyword">if</span><span class="token punctuation">(</span>index <span class="token operator">&lt;</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
                propKey <span class="token operator">=</span> <span class="token function">String</span><span class="token punctuation">(</span>target<span class="token punctuation">.</span>length <span class="token operator">+</span> index<span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
            <span class="token keyword">return</span> Reflect<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>target<span class="token punctuation">,</span> propKey<span class="token punctuation">,</span> receiver<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span><span class="token punctuation">;</span>
    
    <span class="token keyword">let</span> target <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
    target<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span><span class="token operator">...</span>elements<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">Proxy</span><span class="token punctuation">(</span>target<span class="token punctuation">,</span> handler<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">let</span> arr <span class="token operator">=</span> <span class="token function">createArray</span><span class="token punctuation">(</span><span class="token string">'a'</span><span class="token punctuation">,</span><span class="token string">'b'</span><span class="token punctuation">,</span> <span class="token string">'c'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
arr<span class="token punctuation">[</span><span class="token operator">-</span><span class="token number">2</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token comment">//b</span>
</code></pre></div><div class="language-javascript extra-class"><pre class="language-javascript"><code><span class="token comment">//利用Proxy,将读取属性的操作，转变为执行某个函数，实现链式操作</span>
<span class="token keyword">var</span> <span class="token function-variable function">pipe</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">value</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
    <span class="token keyword">var</span> funStack <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
    <span class="token keyword">var</span> oproxy <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Proxy</span><span class="token punctuation">(</span><span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token punctuation">{</span>
        <span class="token function">get</span><span class="token punctuation">(</span>pipeObject<span class="token punctuation">,</span> fnName<span class="token punctuation">)</span><span class="token punctuation">{</span>
            <span class="token keyword">if</span><span class="token punctuation">(</span>fnName <span class="token operator">===</span> <span class="token string">'get'</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
                <span class="token keyword">return</span> funcStack<span class="token punctuation">.</span><span class="token function">reduce</span><span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">val<span class="token punctuation">,</span> fn</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
                    <span class="token keyword">return</span> <span class="token function">fn</span><span class="token punctuation">(</span>val<span class="token punctuation">)</span><span class="token punctuation">;</span>
                <span class="token punctuation">}</span><span class="token punctuation">,</span> value<span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
            funcStack<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>window<span class="token punctuation">[</span>fnName<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token keyword">return</span> oproxy<span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> oproxy<span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">var</span> <span class="token function-variable function">double</span> <span class="token operator">=</span> <span class="token parameter">n</span> <span class="token operator">=&gt;</span>n<span class="token operator">*</span><span class="token number">2</span><span class="token punctuation">;</span>
<span class="token keyword">var</span> <span class="token function-variable function">pow</span> <span class="token operator">=</span> <span class="token parameter">n</span> <span class="token operator">=&gt;</span>n <span class="token operator">*</span>n<span class="token punctuation">;</span>
<span class="token keyword">var</span> <span class="token function-variable function">reverseInt</span> <span class="token operator">=</span> <span class="token parameter">n</span> <span class="token operator">=&gt;</span>n<span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">split</span><span class="token punctuation">(</span><span class="token string">&quot;&quot;</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">reverse</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">join</span><span class="token punctuation">(</span><span class="token string">&quot;&quot;</span><span class="token punctuation">)</span><span class="token operator">|</span><span class="token number">0</span><span class="token punctuation">;</span>
<span class="token function">pipe</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">.</span>double<span class="token punctuation">.</span>pow<span class="token punctuation">.</span>reverseInt<span class="token punctuation">.</span>get<span class="token punctuation">;</span>
</code></pre></div><p>如果一个属性不可配置且不可写，则Proxy不能修该属性，否则通过Proxy对象访问该属性会报错。</p> <p>set方法用来拦截某个属性的赋值操作，可以接受四个参数，依次为目标对象，属性名，属性值，Proxy本身（可选）</p> <div class="language-javascript extra-class"><pre class="language-javascript"><code><span class="token keyword">let</span> validator <span class="token operator">=</span> <span class="token punctuation">{</span>
    <span class="token function">set</span><span class="token punctuation">(</span>obj<span class="token punctuation">,</span> prop<span class="token punctuation">,</span> value<span class="token punctuation">)</span><span class="token punctuation">{</span>
        <span class="token keyword">if</span><span class="token punctuation">(</span>prop <span class="token operator">===</span> <span class="token string">'age'</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
            <span class="token keyword">if</span><span class="token punctuation">(</span>Number<span class="token punctuation">.</span><span class="token function">isInteger</span><span class="token punctuation">(</span>value<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
                <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">TypeError</span><span class="token punctuation">(</span><span class="token string">'The age is not an integer.'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
            <span class="token keyword">if</span><span class="token punctuation">(</span>value <span class="token operator">&gt;</span> <span class="token number">200</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
                <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">RangeError</span><span class="token punctuation">(</span><span class="token string">'the age is invalid.'</span><span class="token punctuation">)</span>
            <span class="token punctuation">}</span>
        <span class="token punctuation">}</span>
        obj<span class="token punctuation">[</span>prop<span class="token punctuation">]</span> <span class="token operator">=</span> value<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token keyword">let</span> person <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Proxy</span><span class="token punctuation">(</span><span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">,</span> validator<span class="token punctuation">)</span><span class="token punctuation">;</span>
person<span class="token punctuation">.</span>age <span class="token operator">=</span> <span class="token number">100</span><span class="token punctuation">;</span>
person<span class="token punctuation">.</span>age <span class="token operator">=</span> <span class="token string">'aa'</span><span class="token punctuation">;</span>
person<span class="token punctuation">.</span>age <span class="token operator">=</span> <span class="token number">300</span><span class="token punctuation">;</span>
</code></pre></div><p>在对象上设置内部属性，属性名的第一个字符使用下划线开头，表示这些属性不应该被外部使用，这时结合get和set方法，可以做到防止这些内部属性被外部读写。</p> <p>注意：如果目标对象自身的某个属性，不可写且不可配置，则set方法将不起作用。</p> <p>严格模式下，set代理如果没有返回true，就会报错。</p> <p>**apply()**方法拦截函数的调用，call和apply操作。</p> <p>Reflect.apply()通过制定的参数列表发起对目标函数的调用，有三个参数：目标函数，函数调用时绑定的this对象，实参列表（类数组对象）</p> <p>apply可以接受三个参数：目标对象，目标对象的上下文（this）,目标对象的参数数组。</p> <div class="language-javascript extra-class"><pre class="language-javascript"><code><span class="token keyword">var</span> handler <span class="token operator">=</span> <span class="token punctuation">{</span>
    <span class="token function">apply</span><span class="token punctuation">(</span><span class="token parameter">target<span class="token punctuation">,</span> ctx<span class="token punctuation">,</span> args</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
        <span class="token keyword">return</span> <span class="token function">Reflect</span><span class="token punctuation">.</span><span class="token function">apply</span><span class="token punctuation">(</span><span class="token operator">...</span>arguments<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><div class="language-javascript extra-class"><pre class="language-javascript"><code><span class="token keyword">var</span> <span class="token function-variable function">target</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span> <span class="token keyword">return</span> <span class="token string">'I am the target'</span><span class="token punctuation">;</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token keyword">var</span> handler <span class="token operator">=</span> <span class="token punctuation">{</span>
    <span class="token function-variable function">apply</span><span class="token operator">:</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
        <span class="token keyword">return</span> <span class="token string">'I am the proxy'</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token keyword">var</span> p <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Proxy</span><span class="token punctuation">(</span>target<span class="token punctuation">,</span> handler<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token function">p</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">//变量p是Proxy的实例，当它作为函数调用的时候，就会被apply拦截，返回一个字符串。</span>
</code></pre></div><div class="language-javascript extra-class"><pre class="language-javascript"><code><span class="token keyword">var</span> twice <span class="token operator">=</span> <span class="token punctuation">{</span>
    <span class="token function">apply</span><span class="token punctuation">(</span><span class="token parameter">target<span class="token punctuation">,</span> ctx<span class="token punctuation">,</span> args</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
        <span class="token keyword">return</span> <span class="token function">Reflect</span><span class="token punctuation">.</span><span class="token function">apply</span><span class="token punctuation">(</span><span class="token operator">...</span>arguments<span class="token punctuation">)</span><span class="token operator">*</span><span class="token number">2</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
<span class="token keyword">function</span> <span class="token function">sum</span><span class="token punctuation">(</span><span class="token parameter">left<span class="token punctuation">,</span> right</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
    <span class="token keyword">return</span> left<span class="token operator">+</span>right<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token keyword">var</span> proxy <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Proxy</span><span class="token punctuation">(</span>sum<span class="token punctuation">,</span> twice<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token function">proxy</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//6</span>
<span class="token function">proxy</span><span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span><span class="token keyword">null</span><span class="token punctuation">,</span> <span class="token number">5</span><span class="token punctuation">,</span> <span class="token number">6</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token function">proxy</span><span class="token punctuation">.</span><span class="token function">apply</span><span class="token punctuation">(</span><span class="token keyword">null</span><span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">8</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">//每当执行proxy函数，就会被apply方法拦截</span>
</code></pre></div><p><strong>has()<strong>方法用来拦截</strong>HasProperty</strong>操作，即判断对象是否具有某个属性时，这个方法会生效。</p> <p>has方法可以接受两个参数，分别是目标对象，需查询的属性名。</p> <p>如果原对象不可配置或禁止扩展，这时has拦截会报错。</p> <p>has方法拦截对for...in 循环不生效。</p> <div class="language-javascript extra-class"><pre class="language-javascript"><code><span class="token keyword">var</span> handler <span class="token operator">=</span> <span class="token punctuation">{</span>
    <span class="token function">has</span><span class="token punctuation">(</span><span class="token parameter">target<span class="token punctuation">,</span> key</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
        <span class="token keyword">if</span><span class="token punctuation">(</span>key<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">===</span> <span class="token string">'_'</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
            <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        <span class="token keyword">return</span> key <span class="token keyword">in</span> target<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
</code></pre></div><p>**construct()**方法用于拦截new命令</p> <p>接受三个参数：</p> <ul><li>target 目标对象</li> <li>args 构造函数的参数对象</li> <li>newTarget 创造实例对象时，new命令作用的构造函数</li></ul> <div class="language-javascript extra-class"><pre class="language-javascript"><code><span class="token keyword">let</span> handler <span class="token operator">=</span> <span class="token punctuation">{</span>
    <span class="token function-variable function">construct</span><span class="token operator">:</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">target<span class="token punctuation">,</span> args</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
        console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'called:'</span> <span class="token operator">+</span> args<span class="token punctuation">.</span><span class="token function">join</span><span class="token punctuation">(</span><span class="token string">','</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">return</span> <span class="token punctuation">{</span> value<span class="token operator">:</span> args<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">*</span><span class="token number">10</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
<span class="token keyword">var</span> p <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Proxy</span><span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">,</span> handler<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">p</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">.</span>value<span class="token punctuation">;</span>
</code></pre></div><p>construct方法必须返回一个对象，否则会报错。</p> <p>**deleteProperty()**方法用于拦截delete操作，如果这个方法抛出错误或返回false，当前属性就无法被delete删除。</p> <p>注意：目标对象自身的不可配置的属性，不能被删除，否则报错。</p> <div class="language-javascript extra-class"><pre class="language-javascript"><code><span class="token keyword">var</span> handler <span class="token operator">=</span> <span class="token punctuation">{</span>
    <span class="token function">deleteProxy</span><span class="token punctuation">(</span><span class="token parameter">target<span class="token punctuation">,</span> key</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
        <span class="token function">invariant</span><span class="token punctuation">(</span>key<span class="token punctuation">,</span> <span class="token string">'delete'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">delete</span> target<span class="token punctuation">[</span>key<span class="token punctuation">]</span><span class="token punctuation">;</span>
        <span class="token keyword">return</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
<span class="token keyword">function</span> <span class="token function">invariant</span><span class="token punctuation">(</span><span class="token parameter">key<span class="token punctuation">,</span> action</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
    <span class="token keyword">if</span><span class="token punctuation">(</span>key<span class="token punctuation">[</span><span class="token number">0</span><span class="token punctuation">]</span> <span class="token operator">===</span> <span class="token string">'_'</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
        <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">Error</span><span class="token punctuation">(</span><span class="token string">'invalid attempt to ${action} private &quot;${key}&quot; property.'</span><span class="token punctuation">)</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
<span class="token keyword">var</span> target <span class="token operator">=</span> <span class="token punctuation">{</span> _prop<span class="token operator">:</span><span class="token string">'foo'</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token keyword">var</span> proxy <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Proxy</span><span class="token punctuation">(</span>target<span class="token punctuation">,</span> handler<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">delete</span> proxy<span class="token punctuation">.</span>_prop<span class="token punctuation">;</span>
</code></pre></div><p>**defineProperty()**方法拦截 Object.defineProperty()操作。</p> <div class="language-javascript extra-class"><pre class="language-javascript"><code><span class="token keyword">var</span> handler <span class="token operator">=</span> <span class="token punctuation">{</span>
    <span class="token function">defineProperty</span><span class="token punctuation">(</span><span class="token parameter">target<span class="token punctuation">,</span> key<span class="token punctuation">,</span> descriptor</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
        <span class="token keyword">return</span> <span class="token boolean">false</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
<span class="token keyword">var</span> target <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token keyword">var</span> proxy <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Proxy</span><span class="token punctuation">(</span>target<span class="token punctuation">,</span> handler<span class="token punctuation">)</span><span class="token punctuation">;</span>
proxy<span class="token punctuation">.</span>foo <span class="token operator">=</span> <span class="token string">'bar'</span><span class="token punctuation">;</span><span class="token comment">//不会生效</span>
</code></pre></div><p>**getOwnPropertyDescriptor()**方法拦截Object.getOwnPropertyDescriptor()，返回一个属性描述对象或undefined。</p> <p>**getPrototypeOf()**方法主要用来拦截获取对象原型，拦截以下操作：</p> <ul><li>Object.prototype.__proto__</li> <li>Object.prototype.isPrototypeOf()</li> <li>Object.getPrototypeOf()</li> <li>Reflect.getPrototypeOf()</li> <li>instanceof</li></ul> <p>**ownKeys()**方法用来拦截对象自身属性的读取操作：</p> <ul><li>Object.getOwnPropertyNames()</li> <li>Object.getOwnPropetySymbols()</li> <li>Object.keys()</li> <li>for ... in循环</li></ul> <h3 id="proxy-revocable"><a href="#proxy-revocable" class="header-anchor">#</a> Proxy.revocable()</h3> <p>该方法返回一个可以取消Proxy的实例</p> <div class="language-javascript extra-class"><pre class="language-javascript"><code><span class="token keyword">let</span> target <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token keyword">let</span> handler <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token keyword">let</span> <span class="token punctuation">{</span> proxy<span class="token punctuation">,</span> revoke <span class="token punctuation">}</span> <span class="token operator">=</span> Proxy<span class="token punctuation">.</span><span class="token function">revocable</span><span class="token punctuation">(</span>target<span class="token punctuation">,</span> handler<span class="token punctuation">)</span><span class="token punctuation">;</span>
proxy<span class="token punctuation">.</span>foo <span class="token operator">=</span> <span class="token number">123</span><span class="token punctuation">;</span>
proxy<span class="token punctuation">.</span>foo<span class="token comment">//123</span>
<span class="token function">revoke</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
proxy<span class="token punctuation">.</span>foo<span class="token comment">//TypeError: Revoked</span>
</code></pre></div><h3 id="this问题"><a href="#this问题" class="header-anchor">#</a> this问题</h3> <p>在Proxy代理的情况下，目标对象内部的this关键字会指向Proxy代理。</p> <div class="language-javascript extra-class"><pre class="language-javascript"><code><span class="token keyword">const</span> target <span class="token operator">=</span> <span class="token punctuation">{</span>
    <span class="token function-variable function">m</span><span class="token operator">:</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
        console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token keyword">this</span> <span class="token operator">===</span> proxy<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
<span class="token keyword">const</span> handler <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>
<span class="token keyword">const</span> proxy <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Proxy</span><span class="token punctuation">(</span>target<span class="token punctuation">,</span> handler<span class="token punctuation">)</span><span class="token punctuation">;</span>
target<span class="token punctuation">.</span><span class="token function">m</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//false</span>
proxy<span class="token punctuation">.</span><span class="token function">m</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//true</span>
</code></pre></div><h3 id="web服务客户端"><a href="#web服务客户端" class="header-anchor">#</a> Web服务客户端</h3> <p>Proxy对象可以拦截目标对象的任意属性，可以写Web服务客户端</p> <div class="language-javascript extra-class"><pre class="language-javascript"><code><span class="token keyword">const</span> service <span class="token operator">=</span> <span class="token function">createWebService</span><span class="token punctuation">(</span><span class="token string">'http://baidu.com'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
service<span class="token punctuation">.</span><span class="token function">employees</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span><span class="token parameter">json</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
    <span class="token keyword">const</span> employees <span class="token operator">=</span> <span class="token constant">JSON</span><span class="token punctuation">.</span><span class="token function">parse</span><span class="token punctuation">(</span>json<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span>
<span class="token comment">//Proxy可以拦截这个对象的任意属性</span>
<span class="token keyword">function</span> <span class="token function">createWebService</span><span class="token punctuation">(</span><span class="token parameter">baseUrl</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
    <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">Proxy</span><span class="token punctuation">(</span><span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token punctuation">{</span>
        <span class="token function">get</span><span class="token punctuation">(</span>target<span class="token punctuation">,</span> propKey<span class="token punctuation">,</span> receiver<span class="token punctuation">)</span><span class="token punctuation">{</span>
            <span class="token keyword">return</span> <span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">=&gt;</span> <span class="token function">httpGet</span><span class="token punctuation">(</span>baseUrl <span class="token operator">+</span> <span class="token string">'/'</span> <span class="token operator">+</span> propKey<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span>
</code></pre></div><p>Proxy也可以实现数据库的ORM层</p> <h2 id="reflect"><a href="#reflect" class="header-anchor">#</a> Reflect</h2> <p>Reflect是ES6为了操作对象提供的新API。Reflect对象的设计目的：</p> <ul><li><p>将Object对象的内部方法比如Object.defineProperty,放到Reflectr对象上，即可以从Reflect对象上拿到语言内部的方法</p></li> <li><p>修改某些Object方法的返回结果，让其更合理。</p> <blockquote><p>Object.definePrperty(obj,name, desc)在无法定义属性时，会抛出一个错误</p> <p>Reflect.defineProperty(obj, name, desc) 则返回false</p></blockquote></li> <li><p>让Object操作变成函数行为</p> <blockquote><p>name in obj =&gt; Reflect.has(obj, name)</p> <p>delete obj[name] =&gt; Reflect.deleteProperty(obj, name)</p></blockquote></li> <li><p>Reflect对象的方法和Proxy对象的方法一一对应。只要是Proxy对象的方法就能在Reflect对象上找到对应的方法。这就使得Proxy对象方便调用Reflect方法，完成默认行为，不管Proxy如何修改默认行为，总可以在Reflect上获取默认行为</p> <div class="language-javascript extra-class"><pre class="language-javascript"><code><span class="token function">Proxy</span><span class="token punctuation">(</span>target<span class="token punctuation">,</span> <span class="token punctuation">{</span>
    <span class="token function">set</span><span class="token punctuation">(</span>target<span class="token punctuation">,</span> name<span class="token punctuation">,</span> value<span class="token punctuation">,</span> receiver<span class="token punctuation">)</span><span class="token punctuation">{</span>
        <span class="token keyword">var</span> success <span class="token operator">=</span> Reflect<span class="token punctuation">.</span><span class="token function">set</span><span class="token punctuation">(</span>target<span class="token punctuation">,</span> name<span class="token punctuation">,</span> value<span class="token punctuation">,</span> receiver<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">if</span><span class="token punctuation">(</span>success<span class="token punctuation">)</span><span class="token punctuation">{</span>
            console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'property'</span> <span class="token operator">+</span> name <span class="token operator">+</span> <span class="token string">' on '</span> <span class="token operator">+</span> target <span class="token operator">+</span> <span class="token string">' set to '</span> <span class="token operator">+</span>value<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        <span class="token keyword">return</span> successs<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span>
<span class="token comment">//Proxy方法拦截target对象的属性赋值行为。</span>
<span class="token comment">//采用Reflect.set方法将值赋值给对象的属性，确保完成原有的行为，再部署额外的功能</span>
</code></pre></div><div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">var</span> loggerObj <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Proxy</span><span class="token punctuation">(</span>obj<span class="token punctuation">,</span> <span class="token punctuation">{</span>
    <span class="token function">get</span><span class="token punctuation">(</span>target<span class="token punctuation">,</span> name<span class="token punctuation">)</span><span class="token punctuation">{</span>
        console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'get'</span><span class="token punctuation">,</span> target<span class="token punctuation">,</span> name<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">return</span> Reflect<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>target<span class="token punctuation">,</span> name<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span><span class="token punctuation">,</span>
    <span class="token function">deleteProperty</span><span class="token punctuation">(</span><span class="token parameter">target<span class="token punctuation">,</span> name</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
        console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'delete'</span> <span class="token operator">+</span> name<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">return</span> Reflect<span class="token punctuation">.</span><span class="token function">deleteProperty</span><span class="token punctuation">(</span>target<span class="token punctuation">,</span> name<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span><span class="token punctuation">,</span>
    <span class="token function">has</span><span class="token punctuation">(</span><span class="token parameter">target<span class="token punctuation">,</span> name</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
        console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'has'</span> <span class="token operator">+</span> name<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">return</span> Reflect<span class="token punctuation">.</span><span class="token function">has</span><span class="token punctuation">(</span>target<span class="token punctuation">,</span> name<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span>
<span class="token comment">//每个Proxy对象的拦截操作，内部都调用对应的Reflect方法，保证原生行为能够正常秩序，只是将每一个操作输出一行日志。</span>

<span class="token class-name">Funcation</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span><span class="token function">apply</span><span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span>Math<span class="token punctuation">.</span>floor<span class="token punctuation">,</span> <span class="token keyword">undefined</span><span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token number">1.75</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">//新写法</span>
<span class="token function">Reflect</span><span class="token punctuation">.</span><span class="token function">apply</span><span class="token punctuation">(</span>Math<span class="token punctuation">.</span>floor<span class="token punctuation">,</span> <span class="token keyword">undefined</span><span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token number">1.75</span><span class="token punctuation">]</span><span class="token punctuation">)</span>
</code></pre></div></li></ul> <h3 id="静态方法"><a href="#静态方法" class="header-anchor">#</a> 静态方法</h3> <p>Reflect对象一共有13个静态方法：</p> <ul><li>Reflect.apply(target, thisArg, args)</li> <li>Reflect.construct(target, args)</li> <li>Reflect.get(target, name, receiver)</li> <li>Reflect.set(target, name, value, receiver)</li> <li>Reflect.defineProperty(target, name, desc)</li> <li>Reflect.deleteProperty(target, name)</li> <li>Reflect.has(target, name)</li> <li>Reflect.ownKeys(target)</li> <li>Reflect.isExtensible(target)</li> <li>Reflect.preventExtensions(target)</li> <li>Reflect.getOwnPropertyDescriptor(target, name)</li> <li>Reflect.getPrototypeOf(target)</li> <li>Reflect.setPrototypeOf(target, prototype)</li></ul> <p>上述犯法大部分与Object对象的同名方法的作用相同，且与Proxy对象的方法是一一对应的。</p> <p><strong>Reflect.get(target, name, receiver)</strong></p> <p>该方法查找并返回target对象的name属性，如果没有，返回undefined。</p> <p>如果name属性部署了读取函数，则读取函数的this绑定receiver</p> <div class="language-javascript extra-class"><pre class="language-javascript"><code><span class="token keyword">var</span> obj <span class="token operator">=</span> <span class="token punctuation">{</span>
    foo<span class="token operator">:</span><span class="token number">1</span><span class="token punctuation">,</span>
    bar<span class="token operator">:</span> <span class="token number">2</span><span class="token punctuation">,</span>
    <span class="token keyword">get</span> <span class="token function">baz</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
        <span class="token keyword">return</span> <span class="token keyword">this</span><span class="token punctuation">.</span>foo<span class="token operator">+</span><span class="token keyword">this</span><span class="token punctuation">.</span>bar<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
Reflect<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>obj<span class="token punctuation">,</span> <span class="token string">'baz'</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//3</span>

<span class="token keyword">var</span> receiverObj <span class="token operator">=</span> <span class="token punctuation">{</span>
    foo<span class="token operator">:</span> <span class="token number">3</span><span class="token punctuation">,</span>
    bar<span class="token operator">:</span> <span class="token number">4</span>
<span class="token punctuation">}</span>
Reflect<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>obj<span class="token punctuation">,</span> <span class="token string">'baz'</span><span class="token punctuation">,</span> receiverObj<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//7</span>
</code></pre></div><p><strong>Reflect.set(target, name, value, receiver)</strong></p> <p>该方法设置targert对象name属性等于value</p> <p>如果name属性设置了赋值函数，则赋值函数的this绑定receiver。</p> <blockquote><p>注意：若Proxy和Reflect对象联合使用，前置拦截赋值操作，后者完成赋值的默认行为</p> <p>当传入receiver时，Reflect.set会触发Proxy.definePropery拦截。</p></blockquote> <div class="language-javascript extra-class"><pre class="language-javascript"><code><span class="token keyword">let</span> p <span class="token operator">=</span> <span class="token punctuation">{</span>
    a<span class="token operator">:</span> <span class="token string">'1'</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token keyword">let</span> handler <span class="token operator">=</span> <span class="token punctuation">{</span>
    <span class="token function">set</span><span class="token punctuation">(</span>target<span class="token punctuation">,</span> name<span class="token punctuation">,</span> value<span class="token punctuation">,</span> receiver<span class="token punctuation">)</span><span class="token punctuation">{</span>
        console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'set'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        Reflect<span class="token punctuation">.</span><span class="token function">set</span><span class="token punctuation">(</span>target<span class="token punctuation">,</span> name<span class="token punctuation">,</span> value<span class="token punctuation">,</span> receiver<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span><span class="token punctuation">,</span>
    
    <span class="token function">defineProperty</span><span class="token punctuation">(</span><span class="token parameter">target<span class="token punctuation">,</span> key<span class="token punctuation">,</span> attribute</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
        console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'defineProperty'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        Reflect<span class="token punctuation">.</span><span class="token function">defineProperty</span><span class="token punctuation">(</span>target<span class="token punctuation">,</span> key<span class="token punctuation">,</span> attribute<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token keyword">let</span> obj <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Proxy</span><span class="token punctuation">(</span>p<span class="token punctuation">,</span> handler<span class="token punctuation">)</span><span class="token punctuation">;</span>
obj<span class="token punctuation">.</span>a <span class="token operator">=</span> <span class="token string">'A'</span><span class="token punctuation">;</span>
<span class="token comment">//set</span>
<span class="token comment">//defineProperty</span>
<span class="token comment">//Reflect.set如果没有传入receiver，就不会触发defineProperty</span>
</code></pre></div><p><strong>Reflect.construct(target, args)</strong></p> <p>该方法等用于new target(...args)， 这提供了一种不使用new，来调用狗仔函数的方法</p> <div class="language-javascript extra-class"><pre class="language-javascript"><code><span class="token keyword">function</span> <span class="token function">Greeting</span><span class="token punctuation">(</span><span class="token parameter">name</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span>name <span class="token operator">=</span> name<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token keyword">const</span> instance <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Greetingz</span><span class="token punctuation">(</span><span class="token string">'larry'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">//Reflect.construct写法</span>
<span class="token keyword">const</span> instance <span class="token operator">=</span> Reflect<span class="token punctuation">.</span><span class="token function">construct</span><span class="token punctuation">(</span>Greeting<span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token string">'larry'</span><span class="token punctuation">]</span><span class="token punctuation">)</span>
</code></pre></div><p><strong>Reflect.getPtototypeOf(obj)</strong></p> <p>该法用于读取对象__protot__属性，对应Object.getPtototypeOf（obj）方法</p> <div class="language-js extra-class"><pre class="language-js"><code>Object<span class="token punctuation">.</span><span class="token function">getPrototypeOf</span><span class="token punctuation">(</span>obj<span class="token punctuation">)</span><span class="token punctuation">;</span>

Reflect<span class="token punctuation">.</span><span class="token function">getPrototype</span><span class="token punctuation">(</span>obj<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">//两者区别：如果参数不是对象，Object.getPrototypeOf(obj)会将参数转为对象，而Relect.getPrototypeOf会报错。</span>
</code></pre></div><p><strong>Reflect.setPrototypeOf(obj, new Proto)</strong></p> <p>该方法用于设置目标对象的原型prototype，对应Object.setPrototypeOf。返回一个布尔值，表示是否成功。</p> <p><strong>Reflect.apply(func, thisArg, args)</strong></p> <p>该方法等同于Function.prototype.apply.call(func, thisArg, args)，用于绑定this对象后执行给定的函数。</p> <p>一般要绑定一个函数的this对象，fn.apply(obj, args)</p> <p>若函数定义了自己的apply方法，只能写成Function.prototype.apply.call(fn, obj, args),简化Reflect.apply</p> <p><strong>Reflect.defineProperty(targrt, propKey, attributes)</strong></p> <p>该方法基本与Object.defineProperty，用来为对象定义属性。</p> <p>未来逐渐废弃，开始使用Reflect.defineProperty</p> <p><strong>Reflect.isExtensible(target)</strong>
该方法返回一个布尔值，表示当前对象是否可扩展，是否可添加新属性</p> <p><strong>Reflect.preventExtensions(target)</strong></p> <p>该方法用于将对象变为一个不可扩展的对象，返回一个布尔值，表示操作是否成功。</p> <h3 id="使用proxy实现观察者模式"><a href="#使用proxy实现观察者模式" class="header-anchor">#</a> 使用Proxy实现观察者模式</h3> <p>观察者模式Observer mode指函数自动观察数据对象，一旦发生变化，函数自动执行。</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">const</span> queuedObservers <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Set</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">const</span> <span class="token function-variable function">observe</span> <span class="token operator">=</span> <span class="token parameter">fn</span> <span class="token operator">=&gt;</span> queuedObservers<span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span>fn<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">const</span> <span class="token function-variable function">observable</span> <span class="token operator">=</span> <span class="token parameter">obj</span> <span class="token operator">=&gt;</span> <span class="token keyword">new</span> <span class="token class-name">Proxy</span><span class="token punctuation">(</span>obj<span class="token punctuation">,</span> handler<span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token keyword">let</span> handler <span class="token operator">=</span> <span class="token punctuation">{</span>
    <span class="token function">set</span><span class="token punctuation">(</span>target<span class="token punctuation">,</span> key<span class="token punctuation">,</span> value<span class="token punctuation">,</span> receiver<span class="token punctuation">)</span><span class="token punctuation">{</span>
        <span class="token keyword">const</span> result <span class="token operator">=</span> Reflect<span class="token punctuation">.</span><span class="token function">set</span><span class="token punctuation">(</span>target<span class="token punctuation">,</span> key<span class="token punctuation">,</span> value<span class="token punctuation">,</span> receiver<span class="token punctuation">)</span><span class="token punctuation">;</span>
        queuedObservers<span class="token punctuation">.</span><span class="token function">forEach</span><span class="token punctuation">(</span><span class="token parameter">observer</span> <span class="token operator">=&gt;</span> <span class="token function">observer</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">return</span> result<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
<span class="token comment">//先定义一个Set集合，所有观察者函数都放入集合。</span>
<span class="token comment">//observable函数返回原始对象的代理，拦截赋值操作</span>
<span class="token comment">//拦截函数set中，会自动执行所有观察者</span>
<span class="token comment">//就是在改变对象是，拦截赋值操作后，执行观察者函数</span>

<span class="token keyword">const</span> person <span class="token operator">=</span> <span class="token function">observable</span><span class="token punctuation">(</span><span class="token punctuation">{</span>
    name<span class="token operator">:</span> <span class="token string">'larry'</span><span class="token punctuation">,</span>
    age<span class="token operator">:</span> <span class="token number">22</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span>

<span class="token keyword">function</span> <span class="token function">print</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token template-string"><span class="token template-punctuation string">`</span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span>person<span class="token punctuation">,</span>name<span class="token interpolation-punctuation punctuation">}</span></span><span class="token string">, </span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span>person<span class="token punctuation">.</span>age<span class="token interpolation-punctuation punctuation">}</span></span><span class="token template-punctuation string">`</span></span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token function">observe</span><span class="token punctuation">(</span>print<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">//数据对象person是观察的目标，函数print是观察者，一旦person变化，print自动执行</span>

</code></pre></div><h2 id="promise对象"><a href="#promise对象" class="header-anchor">#</a> Promise对象</h2> <p>Promise是异步编程的一种解决方案，比回调函数和事件合理。</p> <p>ES6原生提供了Promise对象。</p> <p>所谓Promise对象，就是一个容器，里面保存着某个未来才会结束的事件，通常是一个异步操作的结果。</p> <p>从语法上说，Promise是一个对象，从它可以获取操作的消息。</p> <p>Promise对象有两个特点：</p> <ul><li><p>对象的状态不受外界影响。Promise对象代表一个异步操作，有三种状态：pending、fulfilled、rejected。异步操作的结果可以决定哪一种状态，任何其他操作都无法改变。</p></li> <li><p>一旦状态改变，就不会再变，任何时候都可以得到这个结果。状态改变只有两种可能：</p> <ul><li>pending-&gt;fulfilled</li> <li>pending-&gt;rejected</li></ul> <p>如果改变已经发生，即使再对Promise对象添加回调函数，也会立即得到这个结果，而事件一旦错过，再监听也得不到结果。</p></li></ul> <p>Promise缺点：</p> <ul><li>无法取消Promise，一旦新建会立即执行，无法中途取消</li> <li>若不设置回调函数，Promise内部抛出错误，不会反应到外部</li> <li>当处于pending状态，无法得知目前进入到哪一阶段</li></ul> <h3 id="基本用法"><a href="#基本用法" class="header-anchor">#</a> 基本用法</h3> <p>ES6规定，Promise对象是一个构造函数，用来生成Promise实例。</p> <div class="language-javascript extra-class"><pre class="language-javascript"><code><span class="token keyword">const</span> promise <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Promise</span><span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">resolve<span class="token punctuation">,</span> reject</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
    <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token comment">/*异步成功*/</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
       <span class="token function">resolve</span><span class="token punctuation">(</span>value<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token punctuation">}</span><span class="token keyword">else</span><span class="token punctuation">{</span>
       <span class="token function">reject</span><span class="token punctuation">(</span>error<span class="token punctuation">)</span><span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span>
</code></pre></div><p>Promise构造函数接受一个函数作为参数，该函数两个参数resolve, reject，他们是两个函数，由JavaScript引擎提供。</p> <p>resolve函数的作用，在状态变为resolved，异步操作成功时调用，并将异步操作结果作为参数传递出去；</p> <p>reject函数作用，异步操作失败的时候调用，并将异步操作报错的错误作为参数传递出去。</p> <p>Promise实例生成以后，<strong>可以用then方法分别指定resoved状态和rejected状态的回调函数。</strong></p> <div class="language-js extra-class"><pre class="language-js"><code>promise<span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">value</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">,</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">error</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">)</span>
</code></pre></div><p>then方法接受两个回调函数作为参数，第一个参数是resolved时调用，第二个参数是rejected时调用（可选）</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">function</span> <span class="token function">timeout</span><span class="token punctuation">(</span><span class="token parameter">ms</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
    <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">Promise</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token parameter">resolve<span class="token punctuation">,</span> reject</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
        <span class="token function">setTimeout</span><span class="token punctuation">(</span>resovle<span class="token punctuation">,</span> ms<span class="token punctuation">,</span> <span class="token string">'done'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span>

<span class="token function">timeout</span><span class="token punctuation">(</span><span class="token number">100</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token parameter">value</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>value<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span>
</code></pre></div><div class="language-js extra-class"><pre class="language-js"><code><span class="token comment">//异步加载图片</span>
<span class="token keyword">function</span> <span class="token function">loadImageAsync</span><span class="token punctuation">(</span><span class="token parameter">url</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
    <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">Promise</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token parameter">resolve<span class="token punctuation">,</span> reject</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span><span class="token punctuation">{</span>
        <span class="token keyword">const</span> image <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Image</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        image<span class="token punctuation">.</span><span class="token function-variable function">onload</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
            <span class="token function">resolve</span><span class="token punctuation">(</span>image<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span><span class="token punctuation">;</span>
        
        image<span class="token punctuation">.</span><span class="token function-variable function">onerror</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
            <span class="token function">reject</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Error</span><span class="token punctuation">(</span><span class="token string">'COULD NOT LOAD IMAGE AT '</span><span class="token operator">+</span> url <span class="token punctuation">)</span><span class="token punctuation">)</span>
        <span class="token punctuation">}</span><span class="token punctuation">;</span>
        
        image<span class="token punctuation">.</span>src <span class="token operator">=</span> url<span class="token punctuation">;</span>
    <span class="token punctuation">}</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span>
</code></pre></div><div class="language-javascript extra-class"><pre class="language-javascript"><code><span class="token comment">//Promise实现Ajax请求</span>
<span class="token keyword">const</span> <span class="token function-variable function">getJSON</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">url</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
    <span class="token keyword">const</span> promise <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Promise</span><span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">resolve<span class="token punctuation">,</span> reject</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
        <span class="token keyword">const</span> <span class="token function-variable function">handler</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
            <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>readyState <span class="token operator">!==</span> <span class="token number">4</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
                <span class="token keyword">return</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
            <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>status <span class="token operator">===</span> <span class="token number">200</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
                <span class="token function">resolve</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>response<span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span><span class="token keyword">else</span><span class="token punctuation">{</span>
                <span class="token function">reject</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">Error</span><span class="token punctuation">(</span><span class="token string">'this.statusText'</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
        <span class="token punctuation">}</span><span class="token punctuation">;</span>
        <span class="token keyword">const</span> client <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">XMLHttpRequest</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        client<span class="token punctuation">.</span><span class="token function">open</span><span class="token punctuation">(</span><span class="token string">'GET'</span><span class="token punctuation">,</span> url<span class="token punctuation">)</span><span class="token punctuation">;</span>
        client<span class="token punctuation">.</span>onreadystatechange <span class="token operator">=</span> handler<span class="token punctuation">;</span>
        client<span class="token punctuation">.</span>responseType <span class="token operator">=</span> <span class="token string">'json'</span><span class="token punctuation">;</span>
        client<span class="token punctuation">.</span><span class="token function">setRequestHeader</span><span class="token punctuation">(</span><span class="token string">'Accept'</span><span class="token punctuation">,</span><span class="token string">'application/json'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        client<span class="token punctuation">.</span><span class="token function">send</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
    <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> promise<span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token function">getJSON</span><span class="token punctuation">(</span><span class="token string">'post.json'</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">json</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>json<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">error</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>error<span class="token punctuation">)</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span>
</code></pre></div><p>resolve函数的参数除了正常值以外，还可以是另一个Promise实例。</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">const</span> p1 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Promise</span><span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">resolve<span class="token punctuation">,</span> reject</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
    <span class="token comment">//...</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span>

<span class="token keyword">const</span> p2 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Promise</span><span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">resolve<span class="token punctuation">,</span> reject</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
    <span class="token function">resolve</span><span class="token punctuation">(</span>p1<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span>
<span class="token comment">//p1的状态会传递给p2,即p1的状态决定p2的状态。如果p1为pending,则p2回调函数会等待p1.</span>
</code></pre></div><p>注意：resolve或reject并不会终结Promise的参数函数的执行。</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">new</span> <span class="token class-name">Promise</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token parameter">resolve<span class="token punctuation">,</span> reject</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span><span class="token punctuation">{</span>
    <span class="token function">resolve</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span><span class="token parameter">r</span> <span class="token operator">=&gt;</span><span class="token punctuation">{</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">//2</span>
<span class="token comment">//1</span>
</code></pre></div><p>一般来说，调用resolve或reject以后，Promise的使命就完成了，后续操作应该放到then方法里面，而不是直接写在resolve或reject后面，所以最好加上return语句，后面的语句就不会执行了。</p> <h3 id="promise-prototype-then"><a href="#promise-prototype-then" class="header-anchor">#</a> Promise.prototype.then()</h3> <p>Promise实例具有then方法，即then方法是定义在原型对象Promise.prototype上的，作用是为实例Promise添加状态改变时的回调函数。</p> <p>then方法返回的是一个<strong>新的Promise实例</strong>，所以可以链式写法，即then方法后面再调用另一个then方法。</p> <p>采用链式的then，可以指定一组按照次序调用的回调函数。前一个回调函数返回还是一个Promise对象（即有异步操作），这时后一个回调就会等待Promise对象的状态发生变化才会被调用。</p> <h3 id="promise-prototype-catch"><a href="#promise-prototype-catch" class="header-anchor">#</a> Promise.prototype.catch()</h3> <p>Promise.prototype.catch方法是.then(null, rejection)或.then(undefined, rejection)的别名，用于指定发生错误时的回调函数。</p> <p>Promise对象的错误具有冒泡性质，会一直向后传递，直到被捕获位置。</p> <p>一般来说，不要在then()方法里面定义Reject状态回调函数（即then的第二个参数），总是使用catch方法。</p> <div class="language-javascript extra-class"><pre class="language-javascript"><code>promise
  <span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">data</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">catch</span><span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">err</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">)</span>
</code></pre></div><p>和传统的try/catch代码块不同的是，如果没有catch方法指定错误处理的回调函数，Promise对象抛出的错误不会传递到外层。</p> <p>NodeJs有一个unhandledRejection事件，用于监听未捕获的reject错误。</p> <div class="language-javascript extra-class"><pre class="language-javascript"><code>process<span class="token punctuation">.</span><span class="token function">on</span><span class="token punctuation">(</span><span class="token string">'unhandledRejection'</span><span class="token punctuation">,</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">err<span class="token punctuation">,</span> p</span><span class="token punctuation">)</span><span class="token punctuation">{</span> <span class="token keyword">throw</span> err<span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">)</span>
</code></pre></div><p>注意，未来可能会废除，如有未捕获错误，直接终止进程，且退出码不为0</p> <p>一般建议，Promise对象后面要跟catch方法，这样可以处理Promise内部发生的错误。</p> <p>catch方法返回一个Promise对象，所以后面可以继续掉then方法。如果没有报错，会跳过catch方法，直接执行后面的then方法。</p> <h3 id="promise-prototype-finally"><a href="#promise-prototype-finally" class="header-anchor">#</a> Promise.prototype.finally()</h3> <p>finally方法用于指定不管Promise对象最后状态如何，都会执行的操作。</p> <p>finally方法回调函数不接受任何参数，这就意味着不知道前面Promise状态，所以finally操作应该与状态无关，不依赖与Promise的执行结果。</p> <p>finally本质上是then方法的特例。</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token class-name">Promise</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span><span class="token function-variable function">finally</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">callback</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
    <span class="token keyword">let</span> <span class="token constant">P</span> <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span>constructor<span class="token punctuation">;</span>
    <span class="token keyword">return</span> <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span>
    	<span class="token parameter">value</span> <span class="token operator">=&gt;</span> <span class="token constant">P</span><span class="token punctuation">.</span><span class="token function">resolve</span><span class="token punctuation">(</span><span class="token function">callback</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">=&gt;</span>value<span class="token punctuation">)</span><span class="token punctuation">,</span>
        <span class="token parameter">reason</span> <span class="token operator">=&gt;</span> <span class="token constant">P</span><span class="token punctuation">.</span><span class="token function">resolve</span><span class="token punctuation">(</span><span class="token function">callback</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">=&gt;</span><span class="token punctuation">{</span> <span class="token keyword">throw</span> reason <span class="token punctuation">}</span><span class="token punctuation">)</span>
    <span class="token punctuation">)</span>
<span class="token punctuation">}</span>
</code></pre></div><p>finally总是返回原来的值。</p> <h3 id="promise-all"><a href="#promise-all" class="header-anchor">#</a> Promise.all()</h3> <p>该方法多用于多个Promise实例，包装成一个新的Promise实例。</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">const</span> p <span class="token operator">=</span> Promise<span class="token punctuation">.</span><span class="token function">all</span><span class="token punctuation">(</span><span class="token punctuation">[</span>p1<span class="token punctuation">,</span>p2<span class="token punctuation">,</span>p3<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><p>参数都是Promise的实例，如果不是，会先调用Promise.resolve方法，将参数转换为Promise实例。</p> <p>Promise.all参数可以不是数组，但是必须具有Iterator接口，且返回的每个成员都是Promise的实例。</p> <p>p的状态由p1,p2,p3决定。</p> <ul><li>p1,p2,p3状态都是fulfilled，则p状态为fulfilled，此时返回一个数组，传递给p的回调函数</li> <li>只要有其中一个是rejected，则p状态是rejected,此时第一个被rejected的实例的返回值，会传递给p的回调函数</li></ul> <p>注意：若作为参数的Promise的实例有自己的catch方法，则被rejected时，并不会触发Promise.all的catch方法。</p> <h3 id="promise-race"><a href="#promise-race" class="header-anchor">#</a> Promise.race()</h3> <p>该方法是将多个Promise实例，包装成一个新的Promise实例。</p> <p>只要其中一个实例率先改变状态，p的状态就跟着改变，那个首先改变的Promise实例的返回值，就传递给p的回调函数。</p> <h3 id="promise-allsettled"><a href="#promise-allsettled" class="header-anchor">#</a> Promise.allSettled()</h3> <p>该方法接受一组Promise实例为参数，包装成一个新的Promise实例，只有等到所有这些参数实例都返回结果，不管是fulfilled还是rejected，包装实例才会结束。ES2020引入。</p> <div class="language-javascript extra-class"><pre class="language-javascript"><code><span class="token keyword">const</span> promises <span class="token operator">=</span> <span class="token punctuation">[</span>
    <span class="token function">fetch</span><span class="token punctuation">(</span><span class="token string">'/api-1'</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
    <span class="token function">fetch</span><span class="token punctuation">(</span><span class="token string">'/api-2'</span><span class="token punctuation">)</span><span class="token punctuation">,</span>
	<span class="token function">fetch</span><span class="token punctuation">(</span><span class="token string">'/api-3'</span><span class="token punctuation">)</span>
<span class="token punctuation">]</span>
<span class="token keyword">await</span> Promise<span class="token punctuation">.</span><span class="token function">allSettled</span><span class="token punctuation">(</span>promises<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token function">removeLoading</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">//只有等三个请求都结束，加载的图标消失。</span>
</code></pre></div><p>当不关心异步操作结果，只关心这些操作有没有结束，此时Promise.allSettled方法很有用。</p> <h3 id="promise-any"><a href="#promise-any" class="header-anchor">#</a> Promise.any()</h3> <p>该方法接受一组Promise实例作为参数，包装为一个新的Promise实例，只要参数实例一个变为fulfilled状态，包装实例就会变为fulfilled状态，所有的参数实例都为rejected，包装实例才会变成rejected.</p> <h3 id="promise-resolve"><a href="#promise-resolve" class="header-anchor">#</a> Promise.resolve()</h3> <p>该方法将现有对象转为Promise对象。</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">const</span> jsPromise <span class="token operator">=</span> Promise<span class="token punctuation">.</span><span class="token function">resolve</span><span class="token punctuation">(</span>$<span class="token punctuation">.</span><span class="token function">ajax</span><span class="token punctuation">(</span><span class="token string">'.whatever.json'</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

Promise<span class="token punctuation">.</span><span class="token function">resolve</span><span class="token punctuation">(</span><span class="token string">'foo'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">//等价于</span>
<span class="token keyword">new</span> <span class="token class-name">Promise</span><span class="token punctuation">(</span><span class="token parameter">resove</span> <span class="token operator">=&gt;</span> <span class="token function">resolve</span><span class="token punctuation">(</span><span class="token string">'foo'</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
</code></pre></div><p>参数分为四种情况：</p> <ul><li><p>参数是一个Promise实例，则不作任何更改，返回这个实例</p></li> <li><p>参数是一个thenable对象，Promise.resolve会将这个对象转为Promise实例并立即执行thenable对象的then方法</p> <blockquote><p>thenable对象指具有then方法的对象</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">let</span> thenable <span class="token operator">=</span> <span class="token punctuation">{</span>
    <span class="token function-variable function">then</span><span class="token operator">:</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">resolve<span class="token punctuation">,</span> reject</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
        <span class="token function">resolve</span><span class="token punctuation">(</span><span class="token number">42</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token keyword">let</span> p1 <span class="token operator">=</span> Promise<span class="token punctuation">.</span><span class="token function">resolve</span><span class="token punctuation">(</span>thenable<span class="token punctuation">)</span><span class="token punctuation">;</span>
p<span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">value</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>value<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span>
</code></pre></div></blockquote></li> <li><p>参数不具有then方法的对象或根本就不是对象</p> <blockquote><p>如果参数是一个原始值，或不具有thenable方法的对象，则返回一个新的Promise对象且状态为resolved。</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">const</span> p <span class="token operator">=</span> Promise<span class="token punctuation">.</span><span class="token function">resolve</span><span class="token punctuation">(</span><span class="token string">'hello'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
p<span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">s</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>s<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//hello</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span>
</code></pre></div></blockquote></li> <li><p>不带任何参数，则直接返回一个resolved状态的Promise对象。</p> <blockquote><p>如果希望得到一个新的Promise对象，就可以直接调用Promise.resolve()方法</p> <div class="language-javascript extra-class"><pre class="language-javascript"><code><span class="token keyword">const</span> p <span class="token operator">=</span> Promise<span class="token punctuation">.</span><span class="token function">reslove</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
p<span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">)</span>
</code></pre></div></blockquote></li></ul> <p>注意：立即resolve()的Promise对象，是在本轮&quot;事件循环&quot;的结束时执行，而不是在下一轮事件循环开始。</p> <div class="language-javascript extra-class"><pre class="language-javascript"><code><span class="token function">setTimeout</span><span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'3'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">,</span><span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
Promise<span class="token punctuation">.</span><span class="token function">resolve</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'2'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'1'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><h3 id="promise-reject"><a href="#promise-reject" class="header-anchor">#</a> Promise.reject()</h3> <p>该方法也会返回一个新的Promise实例，状态为rejected，且立即执行回调函数。</p> <div class="language-javascript extra-class"><pre class="language-javascript"><code><span class="token keyword">const</span> p <span class="token operator">=</span> Promise<span class="token punctuation">.</span><span class="token function">reject</span><span class="token punctuation">(</span><span class="token string">'error'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">//等同于</span>
<span class="token keyword">const</span> p <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Promise</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token parameter">resolve<span class="token punctuation">,</span>reject</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token function">reject</span><span class="token punctuation">(</span><span class="token string">'error'</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
p<span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span><span class="token keyword">null</span><span class="token punctuation">,</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">s</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>s<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span>
</code></pre></div><p>注意：该方法的参数会原封不动的作为reject的理由，变成后续方法的参数。</p> <div class="language-javascript extra-class"><pre class="language-javascript"><code><span class="token keyword">const</span> thenable <span class="token operator">=</span> <span class="token punctuation">{</span>
    <span class="token function">then</span><span class="token punctuation">(</span><span class="token parameter">resolve<span class="token punctuation">,</span> reject</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
        <span class="token function">reject</span><span class="token punctuation">(</span><span class="token string">'error'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
Promise<span class="token punctuation">.</span><span class="token function">reject</span><span class="token punctuation">(</span>thenable<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">catch</span><span class="token punctuation">(</span><span class="token parameter">e</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>e <span class="token operator">===</span> thenable<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//true</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span>
</code></pre></div><h3 id="应用"><a href="#应用" class="header-anchor">#</a> 应用</h3> <div class="language-javascript extra-class"><pre class="language-javascript"><code><span class="token comment">//加载图片</span>
<span class="token keyword">const</span> <span class="token function-variable function">preloadImage</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">path</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
    <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">Promise</span><span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">resolve<span class="token punctuation">,</span> reject</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
        <span class="token keyword">const</span> image <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Image</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        image<span class="token punctuation">.</span>onload <span class="token operator">=</span> resolve<span class="token punctuation">;</span>
        image<span class="token punctuation">.</span>onerror <span class="token operator">=</span> reject<span class="token punctuation">;</span>
        image<span class="token punctuation">.</span>src <span class="token operator">=</span> path<span class="token punctuation">;</span>
    <span class="token punctuation">}</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span>
</code></pre></div><h3 id="promise-try"><a href="#promise-try" class="header-anchor">#</a> Promise.try()</h3> <p>有时不想区分，函数f是同步函数还是异步函数，但是想用Promise处理，都用then方法指定下一步流程，用catch方法处理f抛出的错误。</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">const</span> <span class="token function-variable function">f</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'now'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
Promise<span class="token punctuation">.</span><span class="token function">resolve</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span>f<span class="token punctuation">)</span><span class="token punctuation">;</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'next'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><p>让同步函数同步执行，异步函数异步执行，并且具有统一的API</p> <div class="language-javascript extra-class"><pre class="language-javascript"><code><span class="token keyword">const</span> <span class="token function-variable function">f</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'now'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">(</span><span class="token keyword">async</span> <span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">=&gt;</span> <span class="token function">f</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//立即执行，会立即执行async函数，如果f是同步的，会立即同步执行，如果f是异步的，就可以用下一步.then方法</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'next'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token comment">//方法二</span>
<span class="token keyword">const</span> <span class="token function-variable function">f</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'now'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">(</span>
	<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">=&gt;</span><span class="token keyword">new</span> <span class="token class-name">Promise</span><span class="token punctuation">(</span><span class="token parameter">resolve</span> <span class="token operator">=&gt;</span> <span class="token function">resolve</span><span class="token punctuation">(</span><span class="token function">f</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span>
<span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'next'</span><span class="token punctuation">)</span>
</code></pre></div><p>Promise.try方法就是替代上面的写法：</p> <div class="language-javascript extra-class"><pre class="language-javascript"><code><span class="token keyword">const</span> <span class="token function-variable function">f</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'now'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
Promise<span class="token punctuation">.</span><span class="token function">try</span><span class="token punctuation">(</span>f<span class="token punctuation">)</span><span class="token punctuation">;</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'next'</span><span class="token punctuation">)</span>
</code></pre></div><p>由于Promise.try为所有操作提供了统一的处理机制，所以若想用then方法管理流程，最好都用Promise.try包装一下。</p> <div class="language-javascript extra-class"><pre class="language-javascript"><code>Promise<span class="token punctuation">.</span><span class="token function">try</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">=&gt;</span>database<span class="token punctuation">.</span>users<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span><span class="token punctuation">{</span>id<span class="token operator">:</span> userId<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span><span class="token operator">...</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">catch</span><span class="token punctuation">(</span><span class="token operator">...</span><span class="token punctuation">)</span>
</code></pre></div><p>事实上，Promise.try就是模拟try代码块</p> <h2 id="iterator和for-of循环"><a href="#iterator和for-of循环" class="header-anchor">#</a> Iterator和for...of循环</h2> <p>JavaScript表示集合的数据结构：</p> <ul><li>Array</li> <li>Object</li> <li>Map</li> <li>Set</li></ul> <p>所以需要统一的接口机制来处理所有不同的数据结构。</p> <p>遍历器Iterator就是这样一种机制。它是一种借口，为各种不同的数据结构提供统一的访问机制，任何数据结构只要部署Iterator接口，就可以完成遍历操作。</p> <p>Iterator的作用：</p> <ul><li>为各种数据结构提供统一、简便的访问接口</li> <li>使得数据结构的成员能够按照某种次序排列</li> <li>Iterator接口主要供ES6的for...of消费</li></ul> <p>Iterator的遍历过程：</p> <ol><li><p>创建一个指针对象，指向当前数据结构的起始位置。</p> <blockquote><p>遍历器的本质就是一个只针对象</p></blockquote></li> <li><p>第一次调用指针对象的next方法，可以将指针指向数据结构的第一个成员</p></li> <li><p>不断调用指针对象的next方法，直到指向数据结构的结束为止</p></li></ol> <p>每一次调用next方法，都会返回数据结构的当前成员的信息。</p> <div class="language-javascript extra-class"><pre class="language-javascript"><code><span class="token keyword">function</span> <span class="token function">makeIterator</span><span class="token punctuation">(</span><span class="token parameter">array</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
    <span class="token keyword">var</span> nextIndex <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> <span class="token punctuation">{</span>
        <span class="token function-variable function">next</span><span class="token operator">:</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
            <span class="token keyword">return</span> nextIndex <span class="token operator">&lt;</span> array<span class="token punctuation">.</span>length <span class="token operator">?</span> 
                <span class="token punctuation">{</span> value<span class="token operator">:</span> array<span class="token punctuation">[</span>nextIndex<span class="token operator">++</span><span class="token punctuation">]</span><span class="token punctuation">,</span> done<span class="token operator">:</span> <span class="token boolean">false</span><span class="token punctuation">}</span><span class="token operator">:</span>
            	<span class="token punctuation">{</span> value<span class="token operator">:</span> <span class="token keyword">undefined</span><span class="token punctuation">,</span> done<span class="token operator">:</span> <span class="token boolean">true</span> <span class="token punctuation">}</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token keyword">var</span> it <span class="token operator">=</span> <span class="token function">makeIterator</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token string">'a'</span><span class="token punctuation">,</span> <span class="token string">'b'</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
it<span class="token punctuation">.</span><span class="token function">next</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
it<span class="token punctuation">.</span><span class="token function">next</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
it<span class="token punctuation">.</span><span class="token function">next</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><h3 id="默认iterator接口"><a href="#默认iterator接口" class="header-anchor">#</a> 默认Iterator接口</h3> <p>当使用for...of循环遍历某种数据结构时，该循环会自动寻找Iterator接口</p> <p>一种数据结构只要部署了Iterator接口，就可以认为这种数据接口是可遍历的</p> <p>ES6规定，默认的Iterator接口部署在数据结构Symbol.iterator属性，或者说，一个数据结构只要具有Symbol.iterator属性，就可以认为是可遍历的</p> <p>原生具备Iterator接口的数据结构：</p> <ul><li>Array</li> <li>Map</li> <li>Set</li> <li>String</li> <li>TypedArray</li> <li>函数的arguments对象</li> <li>NodeList对象</li></ul> <div class="language-javascript extra-class"><pre class="language-javascript"><code><span class="token keyword">let</span> arr <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token string">'a'</span><span class="token punctuation">,</span> <span class="token string">'b'</span><span class="token punctuation">,</span> <span class="token string">'c'</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
<span class="token keyword">let</span> iter <span class="token operator">=</span> arr<span class="token punctuation">[</span>Symbol<span class="token punctuation">.</span>iterator<span class="token punctuation">]</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
iter<span class="token punctuation">.</span><span class="token function">next</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
iter<span class="token punctuation">.</span><span class="token function">next</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token operator">...</span>
</code></pre></div><p>对象没有默认部署Iterator接口，因为不确定属性遍历的先后顺序，本质上，遍历器是一种线性处理。</p> <p>对于任何非线性的数据接口，部署遍历器接口，就等于部署一种线性转换。</p> <div class="language-javascript extra-class"><pre class="language-javascript"><code><span class="token keyword">function</span> <span class="token function">Obj</span><span class="token punctuation">(</span><span class="token parameter">value</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">this</span><span class="token punctuation">.</span>value <span class="token operator">=</span> value<span class="token punctuation">;</span>
  <span class="token keyword">this</span><span class="token punctuation">.</span>next <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token class-name">Obj</span><span class="token punctuation">.</span>prototype<span class="token punctuation">[</span>Symbol<span class="token punctuation">.</span>iterator<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">var</span> iterator <span class="token operator">=</span> <span class="token punctuation">{</span> next<span class="token operator">:</span> next <span class="token punctuation">}</span><span class="token punctuation">;</span>

  <span class="token keyword">var</span> current <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">;</span>

  <span class="token keyword">function</span> <span class="token function">next</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>current<span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token keyword">var</span> value <span class="token operator">=</span> current<span class="token punctuation">.</span>value<span class="token punctuation">;</span>
      current <span class="token operator">=</span> current<span class="token punctuation">.</span>next<span class="token punctuation">;</span>
      <span class="token keyword">return</span> <span class="token punctuation">{</span> done<span class="token operator">:</span> <span class="token boolean">false</span><span class="token punctuation">,</span> value<span class="token operator">:</span> value <span class="token punctuation">}</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
      <span class="token keyword">return</span> <span class="token punctuation">{</span> done<span class="token operator">:</span> <span class="token boolean">true</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>
  <span class="token keyword">return</span> iterator<span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">var</span> one <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Obj</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">var</span> two <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Obj</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">var</span> three <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Obj</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

one<span class="token punctuation">.</span>next <span class="token operator">=</span> two<span class="token punctuation">;</span>
two<span class="token punctuation">.</span>next <span class="token operator">=</span> three<span class="token punctuation">;</span>

<span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">var</span> i <span class="token keyword">of</span> one<span class="token punctuation">)</span><span class="token punctuation">{</span>
  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 1, 2, 3</span>
<span class="token punctuation">}</span>
</code></pre></div><h3 id="调用iterator接口场合"><a href="#调用iterator接口场合" class="header-anchor">#</a> 调用Iterator接口场合</h3> <p>除了for...of，还有以下几个场合调用Iterator接口：</p> <ul><li><p>解构赋值</p> <div class="language-javascript extra-class"><pre class="language-javascript"><code><span class="token comment">//对数组和Set结构进行解构赋值时，会默认调用Symbol.iterator方法</span>
<span class="token keyword">let</span> set <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Set</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token string">'a'</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token string">'b'</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">add</span><span class="token punctuation">(</span><span class="token string">'c'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">let</span> <span class="token punctuation">[</span>x<span class="token punctuation">,</span>y<span class="token punctuation">]</span> <span class="token operator">=</span> set<span class="token punctuation">;</span>
<span class="token keyword">let</span> <span class="token punctuation">[</span>first<span class="token punctuation">,</span> <span class="token operator">...</span>rest<span class="token punctuation">]</span> <span class="token operator">=</span> set<span class="token punctuation">;</span>
</code></pre></div></li> <li><p>扩展运算符</p> <div class="language-javascript extra-class"><pre class="language-javascript"><code><span class="token keyword">var</span> str <span class="token operator">=</span> <span class="token string">'hello'</span><span class="token punctuation">;</span>
<span class="token punctuation">[</span><span class="token operator">...</span>str<span class="token punctuation">]</span><span class="token punctuation">;</span>
</code></pre></div></li> <li><p>yield*</p> <p>yield*后面跟的时一个可遍历的结构，会调用该结构的遍历器接口</p></li> <li><p>由于数组的遍历会调用遍历器接口，所以任何接受数组作为参数的场合，其实都调用了遍历器接口</p> <ul><li>for ... of</li> <li>Array.from()</li> <li>Map()，Set()，WeakMap()，WeakSet()</li> <li>Promise.all()</li> <li>Promise.race()</li></ul></li></ul> <h3 id="字符串iterator接口"><a href="#字符串iterator接口" class="header-anchor">#</a> 字符串Iterator接口</h3> <p>字符串是一个类似数组的对象，也具有原生的Iterator接口</p> <p>可以覆盖原生的Symbol.iterator方法，达到修改遍历器行为的母的：</p> <div class="language-javascript extra-class"><pre class="language-javascript"><code><span class="token keyword">var</span> str <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">String</span><span class="token punctuation">(</span><span class="token string">'hi'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">[</span><span class="token operator">...</span>str<span class="token punctuation">]</span><span class="token punctuation">;</span>
str<span class="token punctuation">[</span>Symbol<span class="token punctuation">.</span>iterator<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
    <span class="token keyword">return</span> <span class="token punctuation">{</span>
        <span class="token function-variable function">next</span><span class="token operator">:</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
            <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>_first<span class="token punctuation">)</span><span class="token punctuation">{</span>
                <span class="token keyword">this</span><span class="token punctuation">.</span>_first <span class="token operator">=</span> <span class="token boolean">false</span><span class="token punctuation">;</span>
                <span class="token keyword">return</span> <span class="token punctuation">{</span> value<span class="token operator">:</span> <span class="token string">'bye'</span><span class="token punctuation">,</span> done<span class="token operator">:</span> <span class="token boolean">false</span><span class="token punctuation">}</span>
            <span class="token punctuation">}</span><span class="token keyword">else</span><span class="token punctuation">{</span>
                <span class="token keyword">return</span> <span class="token punctuation">{</span> done<span class="token operator">:</span> <span class="token boolean">true</span><span class="token punctuation">}</span>
            <span class="token punctuation">}</span>
        <span class="token punctuation">}</span><span class="token punctuation">,</span>
        _fisrt<span class="token operator">:</span> <span class="token boolean">true</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
<span class="token punctuation">[</span><span class="token operator">...</span>str<span class="token punctuation">]</span>
</code></pre></div><h3 id="iterator接口与generator函数"><a href="#iterator接口与generator函数" class="header-anchor">#</a> Iterator接口与Generator函数</h3> <p>Symbol.iterator方法的最简单实现，还是使用Generator函数</p> <div class="language-javascript extra-class"><pre class="language-javascript"><code><span class="token keyword">let</span> iterable <span class="token operator">=</span> <span class="token punctuation">{</span>
    <span class="token punctuation">[</span>Symbol<span class="token punctuation">.</span>iterator<span class="token punctuation">]</span><span class="token operator">:</span> <span class="token keyword">function</span><span class="token operator">*</span> <span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
        <span class="token keyword">yield</span> <span class="token number">1</span><span class="token punctuation">;</span>
        <span class="token keyword">yield</span> <span class="token number">2</span><span class="token punctuation">;</span>
        <span class="token keyword">yield</span> <span class="token number">3</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
<span class="token punctuation">[</span><span class="token operator">...</span>itarable<span class="token punctuation">]</span><span class="token punctuation">;</span>
</code></pre></div><p>上述代码只要用yield命令给出每一步的返回值即可。</p> <h3 id="遍历对象的-return-throw"><a href="#遍历对象的-return-throw" class="header-anchor">#</a> 遍历对象的 return(), throw()</h3> <p>遍历器对象除了next方法，还具有return和throw方法</p> <p>return方法的使用场合：</p> <ul><li>若for...of循环提前退出，就会调用return方法</li> <li>若一个对象在完成遍历前，需要清理或释放资源，就可以部署return方法</li></ul> <div class="language-javascript extra-class"><pre class="language-javascript"><code><span class="token keyword">function</span> <span class="token function">readLinesSync</span><span class="token punctuation">(</span><span class="token parameter">file</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
    <span class="token keyword">return</span> <span class="token punctuation">{</span>
        <span class="token punctuation">[</span>Symbol<span class="token punctuation">.</span>iterator<span class="token punctuation">]</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
            <span class="token keyword">return</span> <span class="token punctuation">{</span>
                <span class="token function">next</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
                    <span class="token keyword">return</span> <span class="token punctuation">{</span>done<span class="token operator">:</span> <span class="token boolean">false</span><span class="token punctuation">}</span>
                <span class="token punctuation">}</span><span class="token punctuation">,</span>
                <span class="token keyword">return</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
                    file<span class="token punctuation">.</span><span class="token function">close</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
                    <span class="token keyword">return</span> <span class="token punctuation">{</span>done<span class="token operator">:</span> <span class="token boolean">true</span><span class="token punctuation">}</span>
                <span class="token punctuation">}</span>
            <span class="token punctuation">}</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token comment">//情况一</span>
<span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">let</span> line <span class="token keyword">of</span> <span class="token function">readLinesSync</span><span class="token punctuation">(</span>fileName<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>line<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">break</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token comment">//情况二</span>
<span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">let</span> line <span class="token keyword">of</span> <span class="token function">readLinesSync</span><span class="token punctuation">(</span>fileName<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>line<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">Error</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span>
</code></pre></div><p>注意： return方法必须返回一个对象，这是Generator决定的</p> <h3 id="for-of循环"><a href="#for-of循环" class="header-anchor">#</a> for...of循环</h3> <p>ES6引入for...of循环，遍历所有数据结构的统一方法。</p> <p>一个数据结构只要部署了Symbol.iterator属性，就被视为具有iterator接口</p> <p>数组原生具备iterator接口，可以用for...of替换数组实例的forEach</p> <p>Set和Map结构也具有原生的Iterator接口，可以直接使用for...of</p> <p>计算生成的数据结构，比如ES6的数组、Set、Map都部署了以下三个方法，调用后都返回遍历器对象。</p> <ul><li>entries()返回一个遍历器对象</li> <li>keys()返回一个遍历器对象，用来遍历所有键名</li> <li>values()返回一个遍历器对象，用来遍历所有键值</li></ul> <p>类数组的对象，包括字符串、DOM、 NodeList对象、arguments对象。</p> <p>并不是所有类数组的对象都具有Iterator接口，可以通过Array.from方法将其转为数组。</p> <p>对于普通对象，for...of结构不能直接使用，必须部署iterator接口后才能使用。</p> <p>可以通过使用Object.keys方法将对象的键名生成一个数组，然后遍历这个数组</p> <div class="language-javascript extra-class"><pre class="language-javascript"><code><span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">var</span> key <span class="token keyword">of</span> Object<span class="token punctuation">.</span><span class="token function">keys</span><span class="token punctuation">(</span>obj<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>key <span class="token operator">+</span> <span class="token string">':'</span> <span class="token operator">+</span> obj<span class="token punctuation">[</span>key<span class="token punctuation">]</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span>
</code></pre></div><p>使用Generator函数将对象重新包装：</p> <div class="language-javascript extra-class"><pre class="language-javascript"><code><span class="token keyword">function</span><span class="token operator">*</span> <span class="token function">entries</span><span class="token punctuation">(</span><span class="token parameter">obj</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
    <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">let</span> key <span class="token keyword">of</span> Object<span class="token punctuation">.</span><span class="token function">keys</span><span class="token punctuation">(</span>obj<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
        <span class="token keyword">yield</span><span class="token punctuation">[</span>key<span class="token punctuation">,</span> obj<span class="token punctuation">[</span>key<span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">let</span> <span class="token punctuation">[</span>key<span class="token punctuation">,</span> value<span class="token punctuation">]</span> <span class="token keyword">of</span> <span class="token function">entries</span><span class="token punctuation">(</span>obj<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>key<span class="token punctuation">,</span> <span class="token string">'-&gt;'</span><span class="token punctuation">,</span> value<span class="token punctuation">)</span>
<span class="token punctuation">}</span>
</code></pre></div><p>与其他遍历比较：</p> <ul><li>原始遍历方法for循环</li> <li>数组内置forEach方法</li> <li>for..in循环遍历数组的键名（主要为遍历对象设计，不适用于遍历数组）</li></ul> <h2 id="generator-函数的语法"><a href="#generator-函数的语法" class="header-anchor">#</a> Generator 函数的语法</h2> <p>Generator函数是ES6提供的一种异步编程解决方案，语法行为与传统函数完全不同。</p> <p>从语法上，可以将Generator理解为一个状态机，封装了多个内部状态，执行Generator函数会返回一个遍历器对象。</p> <p>形式上，Generator函数是一个普通函数，有两个特征：</p> <ul><li>function关键字和函数名之间有星号</li> <li>函数体内使用yield表达式，定义不同的内部状态</li></ul> <div class="language-javascript extra-class"><pre class="language-javascript"><code><span class="token keyword">function</span><span class="token operator">*</span> <span class="token function">helloWorldGenerator</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
    <span class="token keyword">yield</span> <span class="token string">'hello'</span><span class="token punctuation">;</span>
    <span class="token keyword">yield</span> <span class="token string">'world'</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> <span class="token string">'ending'</span>
<span class="token punctuation">}</span>
<span class="token keyword">var</span> hw <span class="token operator">=</span> <span class="token function">hellowWorldGenerator</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><p>调用Generator函数后，该函数并不执行，返回的也不是函数允许的结果，而是一个指向内部状态的指针。</p> <p>下一步必须调用遍历器对象的next方法，使得指针移向下一个状态。</p> <p>每次调用next方法，内部指针就会从函数头部或上一次停下的地方开始执行，知道遇到下一个yield表达式或return语句为止。</p> <p>Generator函数时分段执行的，yield表达式是暂停执行的标记，next方法是恢复执行。</p> <p>调用Generator函数，返回一个遍历器对象，代表函数内部指针。</p> <h3 id="yield表达式"><a href="#yield表达式" class="header-anchor">#</a> yield表达式</h3> <p>yield表达式就是暂停标志。</p> <p>遍历器对象的next方法的逻辑：</p> <ol><li>遇到yield表达式就暂停后面的操作，并将紧跟在yield后面的那个表达式的值，作为返回的对象的value属性值。</li> <li>下一次调用next方法时，继续执行，直到遇到下一个yield表达式。</li> <li>如果没有遇到新的yield表达式，就一直执行到函数结束，return语句，并将return语句后面的表达式作为返回对象的value属性值。</li> <li>如果没有return语句，则返回对象的value属性值为undefined。</li></ol> <p>注意： yield表达式后面的表达式，只有当调用next方法、内部指针指向该语句时才会指向，等于手动提供了惰性求值。</p> <p>yield表达式与return语句相似之处是都能返回语句后面的表达式，区别是每次遇到yield，函数暂停，而return不具备位置记忆功能。</p> <p>Generator函数可以不用yield表达式，这样就编程一个单纯的暂缓执行函数。</p> <p>普通函数中不能使用yield表达式。</p> <p>yield表达式如果用在另一个表达式之中，必须放在圆括号里面。</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">function</span><span class="token operator">*</span> <span class="token function">f</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'执行了'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token keyword">var</span> generator <span class="token operator">=</span> <span class="token function">f</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token function">setTimeout</span><span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
    generator<span class="token punctuation">.</span><span class="token function">next</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">,</span><span class="token number">2000</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">//如果是普通函数，在为遍历generator赋值的时候就会立即执行，但是这里的f是Generator函数，只有调用next方法时，函数f才会执行。</span>
</code></pre></div><p>任意一个对象的Symbol.iterator方法，等于该对象的遍历器生成函数，调用该函数会返回该对象的一个遍历器对象。</p> <p>由于Generator函数就是遍历器生成的函数，因此可以把Generator赋值给对象Symbol.iterator属性，使得该对象拥有Iterator接口。</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">var</span> iterable <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
iterable<span class="token punctuation">[</span>Symbol<span class="token punctuation">.</span>iterator<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token operator">*</span> <span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
    <span class="token keyword">yield</span> <span class="token number">1</span><span class="token punctuation">;</span>
    <span class="token keyword">yield</span> <span class="token number">2</span><span class="token punctuation">;</span>
    <span class="token keyword">yield</span> <span class="token number">3</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token punctuation">[</span><span class="token operator">...</span>iterable<span class="token punctuation">]</span><span class="token punctuation">;</span>
</code></pre></div><p>Generator函数执行后，返回一个遍历器对象，该对象本身也具有Symbol.iterator属性，执行后返回自身。</p> <h3 id="next方法的参数"><a href="#next方法的参数" class="header-anchor">#</a> next方法的参数</h3> <p><strong>yield表达式本身没有返回值，或者说总是返回undefined,</strong></p> <p><strong>next方法可以带一个参数，该参数就会被当做上一个yield表达式返回值。</strong></p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">function</span><span class="token operator">*</span> <span class="token function">f</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
    <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">var</span> i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span> <span class="token boolean">true</span><span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
        <span class="token keyword">var</span> reset <span class="token operator">=</span> <span class="token keyword">yield</span> i<span class="token punctuation">;</span>
        <span class="token keyword">if</span><span class="token punctuation">(</span>reset<span class="token punctuation">)</span><span class="token punctuation">{</span> i<span class="token operator">=</span> <span class="token operator">-</span><span class="token number">1</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token keyword">var</span> g <span class="token operator">=</span> <span class="token function">f</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
g<span class="token punctuation">.</span><span class="token function">next</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//{value:0, done: false}</span>
g<span class="token punctuation">.</span><span class="token function">next</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//{value: 1, done:false}</span>
g<span class="token punctuation">.</span><span class="token function">next</span><span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//{value: 0, done: false}</span>
</code></pre></div><p>Generator函数从暂停状态到恢复运行，上下文状态是不变的，通过next方法的参数，就可以在Generator函数开始运行之后，继续向函数体内部注入值。</p> <p>可以在Generator函数运行的不同阶段，从外部向内部注入不同的值，从而调整函数行为。</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">function</span><span class="token operator">*</span> <span class="token function">foo</span><span class="token punctuation">(</span><span class="token parameter">x</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
    <span class="token keyword">var</span> y <span class="token operator">=</span> <span class="token number">2</span><span class="token operator">*</span><span class="token punctuation">(</span><span class="token keyword">yield</span><span class="token punctuation">(</span>x<span class="token operator">+</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">var</span> z <span class="token operator">=</span> <span class="token keyword">yield</span><span class="token punctuation">(</span>y<span class="token operator">/</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> <span class="token punctuation">(</span>x <span class="token operator">+</span> y <span class="token operator">+</span> z<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">var</span> a <span class="token operator">=</span> <span class="token function">foo</span><span class="token punctuation">(</span><span class="token number">5</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
a<span class="token punctuation">.</span><span class="token function">next</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//{value: 6, done: false}</span>
a<span class="token punctuation">.</span><span class="token function">next</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//{value: NaN, done: false}</span>
a<span class="token punctuation">.</span><span class="token function">next</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//{value: NaN, done: true}</span>

<span class="token keyword">var</span> b <span class="token operator">=</span> <span class="token function">foo</span><span class="token punctuation">(</span><span class="token number">5</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
b<span class="token punctuation">.</span><span class="token function">next</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//{value: 6, done: false}</span>
b<span class="token punctuation">.</span><span class="token function">next</span><span class="token punctuation">(</span><span class="token number">12</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//{value: 8, done: false}</span>
b<span class="token punctuation">.</span><span class="token function">next</span><span class="token punctuation">(</span><span class="token number">13</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//{value: 42: done: true}</span>
</code></pre></div><p>注意：由于next方法的参数表示上一个yield表达式的返回值，所以在第一次使用next方法的时，传递参数是无效的。V8引擎直接忽略了第一次使用next方法时的参数。</p> <p>若想要在第一次调用next方法时，就能够输入值，可以在Generator函数外再包一层：</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">function</span> <span class="token function">wrapper</span><span class="token punctuation">(</span><span class="token parameter">generatorFunction</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
    <span class="token keyword">return</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter"><span class="token operator">...</span>args</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
        <span class="token keyword">let</span> generatorObject <span class="token operator">=</span> <span class="token function">generatorFunction</span><span class="token punctuation">(</span><span class="token operator">...</span>args<span class="token punctuation">)</span><span class="token punctuation">;</span>
        generatorObject<span class="token punctuation">.</span><span class="token function">next</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">return</span> generatorObject<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token keyword">const</span> wrapped <span class="token operator">=</span> <span class="token function">wrapper</span><span class="token punctuation">(</span><span class="token keyword">function</span><span class="token operator">*</span> <span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'First input:'</span> <span class="token operator">+</span> <span class="token keyword">yield</span> <span class="token punctuation">;</span>
	<span class="token keyword">return</span> <span class="token string">'done'</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token function">wrapped</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">next</span><span class="token punctuation">(</span><span class="token string">'hello~'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><h3 id="for-of循环-2"><a href="#for-of循环-2" class="header-anchor">#</a> for...of循环</h3> <p>for...of循环可以自动遍历Generator函数运行时生成的Iterator对象，且此时不再需要调用next方法。</p> <div class="language-javascript extra-class"><pre class="language-javascript"><code><span class="token keyword">function</span><span class="token operator">*</span> <span class="token function">foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
    <span class="token keyword">yield</span> <span class="token number">1</span><span class="token punctuation">;</span>
    <span class="token keyword">yield</span> <span class="token number">2</span><span class="token punctuation">;</span>
    <span class="token keyword">yield</span> <span class="token number">3</span><span class="token punctuation">;</span>
    <span class="token keyword">yield</span> <span class="token number">4</span><span class="token punctuation">;</span>
    <span class="token keyword">yield</span> <span class="token number">5</span><span class="token punctuation">;</span>
    <span class="token keyword">yield</span> <span class="token number">6</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> <span class="token number">7</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">let</span> v <span class="token keyword">of</span> <span class="token function">foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>v<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// 1 2 3 4 5 6</span>
<span class="token punctuation">}</span>
</code></pre></div><p>一旦next方法的返回对象的done属性为true，for...of循环就会中止，且不包含返回对象，所以上面代码return语句返回的6，不包括在for...of循环中。</p> <p>利用for...of循环，可以写出遍历任意对象的方法（原生对象没有遍历接口，无法使用for...of循环），通过Generator函数为它加上这个接口，就可以了。</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">function</span><span class="token operator">*</span> <span class="token function">objectEntries</span><span class="token punctuation">(</span><span class="token parameter">obj</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
    <span class="token keyword">let</span> propKeys <span class="token operator">=</span> Reflect<span class="token punctuation">.</span><span class="token function">ownKeys</span><span class="token punctuation">(</span>obj<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">let</span> propKey <span class="token keyword">of</span> propKeys<span class="token punctuation">)</span><span class="token punctuation">{</span>
        <span class="token keyword">yield</span><span class="token punctuation">[</span>propKey<span class="token punctuation">,</span> obj<span class="token punctuation">[</span>propKey<span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token keyword">let</span> obj <span class="token operator">=</span> <span class="token punctuation">{</span> <span class="token constant">A</span><span class="token operator">:</span> <span class="token string">'a'</span><span class="token punctuation">,</span> <span class="token constant">B</span><span class="token operator">:</span> <span class="token string">'b'</span> <span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">let</span> <span class="token punctuation">[</span>key<span class="token punctuation">,</span>value<span class="token punctuation">]</span> <span class="token keyword">of</span> <span class="token function">objectEntries</span><span class="token punctuation">(</span>obj<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token template-string"><span class="token template-punctuation string">`</span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span>key<span class="token interpolation-punctuation punctuation">}</span></span><span class="token string">:</span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span>value<span class="token interpolation-punctuation punctuation">}</span></span><span class="token template-punctuation string">`</span></span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><p>对象加上遍历器的另一种写法：</p> <div class="language-javascript extra-class"><pre class="language-javascript"><code><span class="token keyword">let</span> obj <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token constant">A</span><span class="token operator">:</span> <span class="token string">'a'</span><span class="token punctuation">,</span> <span class="token constant">B</span><span class="token operator">:</span><span class="token string">'b'</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
obj<span class="token punctuation">[</span>Symbol<span class="token punctuation">.</span>iterator<span class="token punctuation">]</span> <span class="token operator">=</span> objectEntries<span class="token punctuation">;</span>
<span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">let</span> <span class="token punctuation">[</span>key<span class="token punctuation">,</span> value<span class="token punctuation">]</span> <span class="token keyword">of</span> obj<span class="token punctuation">)</span><span class="token punctuation">{</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token template-string"><span class="token template-punctuation string">`</span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span>key<span class="token interpolation-punctuation punctuation">}</span></span><span class="token string">:</span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span>value<span class="token interpolation-punctuation punctuation">}</span></span><span class="token template-punctuation string">`</span></span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><p>除for...of循环以外，扩展运算符，解构赋值，Array.from方法内部调用的，都是遍历器接口。这意味着，他们够可以将Generator函数返回的Iterator对象，作为参数。</p> <div class="language-javascript extra-class"><pre class="language-javascript"><code><span class="token keyword">function</span> <span class="token operator">*</span> <span class="token function">numbers</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
    <span class="token keyword">yield</span> <span class="token number">1</span><span class="token punctuation">;</span>
    <span class="token keyword">yield</span> <span class="token number">2</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> <span class="token number">3</span><span class="token punctuation">;</span>
    <span class="token keyword">yield</span> <span class="token number">4</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token punctuation">[</span><span class="token operator">...</span><span class="token function">numbers</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token comment">//1 2</span>
Array<span class="token punctuation">.</span><span class="token function">from</span><span class="token punctuation">(</span><span class="token function">numbers</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// 1 2</span>
<span class="token keyword">let</span> <span class="token punctuation">[</span>x<span class="token punctuation">,</span>y<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">numbers</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><h3 id="generator-prototype-throw"><a href="#generator-prototype-throw" class="header-anchor">#</a> Generator.prototype.throw()</h3> <p>Generator函数返回的遍历器对象，都有一个throw方法，可以在函数体外抛出错误，然后再函数体内捕获。</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">var</span> <span class="token function-variable function">g</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token operator">*</span> <span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
    <span class="token keyword">try</span><span class="token punctuation">{</span>
        <span class="token keyword">yield</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span><span class="token keyword">catch</span><span class="token punctuation">(</span>e<span class="token punctuation">)</span><span class="token punctuation">{</span>
        console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'内部捕获'</span><span class="token punctuation">,</span>e<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token keyword">var</span> i <span class="token operator">=</span> <span class="token function">g</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
i<span class="token punctuation">.</span><span class="token function">next</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
<span class="token keyword">try</span><span class="token punctuation">{</span>
    i<span class="token punctuation">.</span><span class="token function">throw</span><span class="token punctuation">(</span><span class="token string">'a'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    i<span class="token punctuation">.</span><span class="token function">throw</span><span class="token punctuation">(</span><span class="token string">'b'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token keyword">catch</span><span class="token punctuation">(</span>e<span class="token punctuation">)</span><span class="token punctuation">{</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">&quot;外部捕获&quot;</span><span class="token punctuation">,</span>e<span class="token punctuation">)</span>
<span class="token punctuation">}</span>
</code></pre></div><p>throw方法可以接受一个参数，该参数会被catch语句接收，建议抛出Error对象实例。</p> <p>不要混淆遍历器对象的throw方法和全局throw命令。</p> <p>若Generator函数内部和外部，都没有部署try...catch代码块，则程序将报错，直接中断执行。</p> <p>throw方法抛出的错误要被内部捕获，必须至少执行过一次next方法</p> <p>throw方法被捕获后，会附带执行下一条yield表达式，即会附带执行一次next方法。</p> <div class="language-javascript extra-class"><pre class="language-javascript"><code><span class="token keyword">var</span> <span class="token function-variable function">gen</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token operator">*</span> <span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
    <span class="token keyword">try</span><span class="token punctuation">{</span>
        <span class="token keyword">yield</span> console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'a'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span><span class="token keyword">catch</span><span class="token punctuation">(</span>e<span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token punctuation">}</span>
    <span class="token keyword">yield</span> console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'b'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">yield</span> console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'c'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">var</span> g <span class="token operator">=</span> <span class="token function">gen</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
g<span class="token punctuation">.</span><span class="token function">next</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//a</span>
g<span class="token punctuation">.</span><span class="token function">throw</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//b</span>
g<span class="token punctuation">.</span><span class="token function">next</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//c</span>
</code></pre></div><p>g.throw方法被捕获以后，自动执行了一次next方法，所以会打印b。只要Generator函数内部部署了try...catch代码块，那么遍历器的throw方法抛出的错误，不影响下一次遍历。</p> <p>throw和g.throw方法是无关的，两者互不影响。</p> <div class="language-javascript extra-class"><pre class="language-javascript"><code><span class="token keyword">var</span> <span class="token function-variable function">gen</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token operator">*</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
    <span class="token keyword">yield</span> console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'hello'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">yield</span> console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'world'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">var</span> g <span class="token operator">=</span> <span class="token function">gen</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
g<span class="token punctuation">.</span><span class="token function">next</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">try</span><span class="token punctuation">{</span>
    <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">Error</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token keyword">catch</span><span class="token punctuation">(</span>e<span class="token punctuation">)</span><span class="token punctuation">{</span>
    g<span class="token punctuation">.</span><span class="token function">next</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><p>上述代码中，throw命令抛出的错误不会影响到遍历器的状态，所以两次执行next方法，都进行了正确的操作。</p> <p>这种函数体内捕获错误的机制，大大方便了错误的处理。</p> <p>多个yield表达式，可以只用一个try...catch代码块来捕获错误。</p> <p>Generator函数体外抛出错误，可以在函数体内不过，反之同也可以。</p> <p>一旦Generator执行过程中抛出错误且没有被内部捕获，就不会再执行下去，再调用next方法，返回一个value为undefined，done为true的对象。</p> <h3 id="generator-prototype-return"><a href="#generator-prototype-return" class="header-anchor">#</a> Generator.prototype.return()</h3> <p>Generator函数返回的遍历器对象，还有一个return方法，可以返回给定的值，且终结遍历Generator函数。</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">function</span><span class="token operator">*</span> <span class="token function">gen</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
    <span class="token keyword">yield</span> <span class="token number">1</span><span class="token punctuation">;</span>
    <span class="token keyword">yield</span> <span class="token number">2</span><span class="token punctuation">;</span>
    <span class="token keyword">yield</span> <span class="token number">3</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token keyword">var</span> g <span class="token operator">=</span> <span class="token function">gen</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
g<span class="token punctuation">.</span><span class="token function">next</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//{ value: 1, done: false }</span>
g<span class="token punctuation">.</span><span class="token function">return</span><span class="token punctuation">(</span><span class="token string">'foo'</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//{ value: 'foo', done: true }</span>
g<span class="token punctuation">.</span><span class="token function">next</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//{ value: undefined, done: true }</span>
</code></pre></div><p>若return方法调用时，不提供参数，则返回值的value属性为undefined.</p> <p>若Generator函数内部有try...finally代码块且正在执行try代码块，那么return方法会导致立即进入finally代码块，执行完后，整个函数才会结束。</p> <div class="language-javascript extra-class"><pre class="language-javascript"><code><span class="token keyword">function</span><span class="token operator">*</span> <span class="token function">numbers</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
    <span class="token keyword">yield</span> <span class="token number">1</span><span class="token punctuation">;</span>
    <span class="token keyword">try</span><span class="token punctuation">{</span>
        <span class="token keyword">yield</span> <span class="token number">2</span><span class="token punctuation">;</span>
        <span class="token keyword">yield</span> <span class="token number">3</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span> <span class="token keyword">finally</span><span class="token punctuation">{</span>
        <span class="token keyword">yield</span> <span class="token number">4</span><span class="token punctuation">;</span>
        <span class="token keyword">yield</span> <span class="token number">5</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">yield</span> <span class="token number">6</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token keyword">var</span> g <span class="token operator">=</span> <span class="token function">number</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
g<span class="token punctuation">.</span><span class="token function">next</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//{value:1, done:false}</span>
g<span class="token punctuation">.</span><span class="token function">next</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//{value: 2, done: false}</span>
g<span class="token punctuation">.</span><span class="token function">return</span><span class="token punctuation">(</span><span class="token number">7</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//{value: 4, done: false}</span>
g<span class="token punctuation">.</span><span class="token function">next</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//{value:5, done: false}</span>
g<span class="token punctuation">.</span><span class="token function">next</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//{value: 7, done: true}</span>
<span class="token comment">//等到finally代码块执行完毕，再返回return方法指定的返回值</span>
</code></pre></div><h3 id="next、throw、return的共同点"><a href="#next、throw、return的共同点" class="header-anchor">#</a> next、throw、return的共同点</h3> <p>他们的作用就是让Generator函数恢复执行，且使用不同的语句替换yield表达式。</p> <p>next是将yield表达式替换成一个值。</p> <p>throw是将yield表达式替换成一个throw语句。</p> <p>return是将yield表达式替换成一个return语句。</p> <h3 id="yield-表达式"><a href="#yield-表达式" class="header-anchor">#</a> yield* 表达式</h3> <p>如果在Generator函数内部，调用另一个Generator函数，需要在前者的函数体内部，手动完成遍历。</p> <div class="language-javascript extra-class"><pre class="language-javascript"><code><span class="token keyword">function</span><span class="token operator">*</span> <span class="token function">foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
    <span class="token keyword">yield</span> <span class="token string">'a'</span><span class="token punctuation">;</span>
    <span class="token keyword">yield</span> <span class="token string">'b'</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">function</span><span class="token operator">*</span> <span class="token function">bar</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
    <span class="token keyword">yield</span> <span class="token string">'x'</span><span class="token punctuation">;</span>
    <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">let</span> i <span class="token keyword">of</span> <span class="token function">foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
        console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>i<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">yield</span> <span class="token string">'y'</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">let</span> v <span class="token keyword">of</span> bar<span class="token punctuation">)</span><span class="token punctuation">{</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>v<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token comment">//x a b y</span>
</code></pre></div><p>如果多个Generator函数嵌套，就比较麻烦，需要用yield*表达式，用来在一个Generator函数里面执行另一个Generator函数。</p> <div class="language-javascript extra-class"><pre class="language-javascript"><code><span class="token keyword">function</span><span class="token operator">*</span> <span class="token function">bar</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
    <span class="token keyword">yield</span> <span class="token string">'x'</span><span class="token punctuation">;</span>
    <span class="token keyword">yield</span><span class="token operator">*</span> <span class="token function">foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">yield</span> <span class="token string">'y'</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><p>从语法角度来看，如果yield表达式后面跟的是一个遍历器对象，需要在yield表达式后面加上星号，表明它返回的时一个遍历器对象。这个被称为yield*表达式。</p> <p>yield*后面的Generator函数（没有return语句时），等同于在Generator函数内部，部署了一个for...of循环。</p> <p>实际上，任何数据结构，只要有iterator接口，就可以被yield*遍历。</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">let</span> read <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token keyword">function</span><span class="token operator">*</span> <span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
    <span class="token keyword">yield</span> <span class="token string">'hello'</span><span class="token punctuation">;</span>
    <span class="token keyword">yield</span><span class="token operator">*</span> <span class="token string">'hello'</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

read<span class="token punctuation">.</span><span class="token function">next</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span>value<span class="token punctuation">;</span><span class="token comment">//'hello'</span>
read<span class="token punctuation">.</span><span class="token function">next</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span>value<span class="token punctuation">;</span><span class="token comment">//'h'</span>
</code></pre></div><p>如果被代理的Generator函数有return语句，则就可以向代理它的Generator函数返回数据。</p> <div class="language-javascript extra-class"><pre class="language-javascript"><code><span class="token keyword">function</span><span class="token operator">*</span> <span class="token function">foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
    <span class="token keyword">yield</span> <span class="token number">2</span><span class="token punctuation">;</span>
    <span class="token keyword">yield</span> <span class="token number">3</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> <span class="token string">'foo'</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">function</span><span class="token operator">*</span> <span class="token function">bar</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
    <span class="token keyword">yield</span> <span class="token number">1</span><span class="token punctuation">;</span>
    <span class="token keyword">var</span> v <span class="token operator">=</span> <span class="token keyword">yield</span><span class="token operator">*</span> <span class="token function">foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>v<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">yield</span> <span class="token number">4</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token keyword">var</span> it <span class="token operator">=</span> <span class="token function">bar</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
it<span class="token punctuation">.</span><span class="token function">next</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
it<span class="token punctuation">.</span><span class="token function">next</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
it<span class="token punctuation">.</span><span class="token function">next</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
it<span class="token punctuation">.</span><span class="token function">next</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// 'foo' {value:4, done: false}</span>
it<span class="token punctuation">.</span><span class="token function">next</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><p>yield*命令可以很方便的去除嵌套数组的所有成员。</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">function</span> <span class="token operator">*</span> <span class="token function">iterTree</span><span class="token punctuation">(</span><span class="token parameter">tree</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
    <span class="token keyword">if</span><span class="token punctuation">(</span>Array<span class="token punctuation">.</span><span class="token function">isArray</span><span class="token punctuation">(</span>tree<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
        <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">let</span> i<span class="token operator">=</span><span class="token number">0</span><span class="token punctuation">;</span> i<span class="token operator">&lt;</span> tree<span class="token punctuation">.</span>length<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
            <span class="token keyword">yield</span><span class="token operator">*</span> <span class="token function">iterTree</span><span class="token punctuation">(</span>tree<span class="token punctuation">[</span>i<span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span><span class="token keyword">else</span><span class="token punctuation">{</span>
        <span class="token keyword">yield</span> tree<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token keyword">const</span> tree <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token string">'a'</span><span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token string">'b'</span><span class="token punctuation">,</span> <span class="token string">'c'</span><span class="token punctuation">]</span><span class="token punctuation">,</span> <span class="token punctuation">[</span><span class="token string">'d'</span><span class="token punctuation">,</span> <span class="token string">'e'</span><span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
<span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">let</span> x <span class="token keyword">of</span> <span class="token function">iterTree</span><span class="token punctuation">(</span>tree<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><h3 id="作为对象属性的generator函数"><a href="#作为对象属性的generator函数" class="header-anchor">#</a> 作为对象属性的Generator函数</h3> <div class="language-javascript extra-class"><pre class="language-javascript"><code><span class="token keyword">let</span> obj <span class="token operator">=</span> <span class="token punctuation">{</span>
    <span class="token operator">*</span> <span class="token function">myGeneratorMethod</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token operator">...</span><span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><h3 id="generator函数的this"><a href="#generator函数的this" class="header-anchor">#</a> Generator函数的this</h3> <p>Generator总是返回一个遍历器，ES6规定这个遍历器是Generator函数的实例，也继承了Generator函数的prototype对象上的方法。</p> <div class="language-javascript extra-class"><pre class="language-javascript"><code><span class="token keyword">function</span><span class="token operator">*</span> <span class="token function">g</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token punctuation">}</span>
g<span class="token punctuation">.</span>prototype<span class="token punctuation">.</span><span class="token function-variable function">hello</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
    <span class="token keyword">return</span> <span class="token string">'hi'</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token keyword">let</span> obj <span class="token operator">=</span> <span class="token function">g</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
obj <span class="token keyword">instanceof</span> <span class="token class-name">g</span><span class="token comment">//true</span>
obj<span class="token punctuation">.</span><span class="token function">hello</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//'hi'</span>
</code></pre></div><p>Generator函数g返回的遍历器obj，是g的实例，且继承了g.prototype。如果将g当做普通的构造函数，不会生效，g返回的总是遍历器对象，而不是this。</p> <h3 id="generator与状态机"><a href="#generator与状态机" class="header-anchor">#</a> Generator与状态机</h3> <p>Generator是实现状态机的最佳结构。</p> <div class="language-javascript extra-class"><pre class="language-javascript"><code><span class="token keyword">var</span> ticking <span class="token operator">=</span> <span class="token boolean">true</span><span class="token punctuation">;</span>
<span class="token keyword">var</span> <span class="token function-variable function">clock</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
    <span class="token keyword">if</span><span class="token punctuation">(</span>ticking<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'Tick!'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span><span class="token keyword">else</span><span class="token punctuation">{</span>
        console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'Tock!'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    ticking <span class="token operator">=</span> <span class="token operator">!</span>ticking<span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">var</span> <span class="token function-variable function">clock</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token operator">*</span> <span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
    <span class="token keyword">while</span><span class="token punctuation">(</span><span class="token boolean">true</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
        console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'Tick!'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">yield</span><span class="token punctuation">;</span>
        console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'Tock!'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">yield</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><p>Generator与协程</p> <p>协程是一种程序的运行方式，可以理解为协作的线程或协作的函数。</p> <p>Generator与上下文</p> <p>JavaScript代码运行时，会产生一个全局的上下文环境（context，运行环境），包含了当前所有的变量和对象。当执行函数或代码块时，会在当前上下文环境的上次，产生一个函数运行的上下文，变成当前的上下文，由此形成一个上下文环境的堆栈。</p> <p>Generator函数不是这样，它产生的上下文环境，一旦遇到yield命令，就会暂时退出堆栈，并不消失，里面所有的变量和对象会冻结在当前状态，等到对它执行next时，这个上下文环境会重新加入调用栈，恢复执行。</p> <h3 id="应用-2"><a href="#应用-2" class="header-anchor">#</a> 应用</h3> <p>Generator可以暂停函数执行，返回任意表达式的值。</p> <h2 id="generator函数的异步应用"><a href="#generator函数的异步应用" class="header-anchor">#</a> Generator函数的异步应用</h2> <p>ES6之前，异步编程的方法：</p> <ul><li>回调函数</li> <li>事件监听</li> <li>发布/订阅</li> <li>Promise对象</li></ul> <p>Generator函数将JS异步编程带入一个全新阶段。</p> <h3 id="基本概念"><a href="#基本概念" class="header-anchor">#</a> 基本概念</h3> <p>所谓异步，简单的就是说一个任务不是连续完成的，一个任务被认为分为两个阶段，先执行第一阶段，然后执行其他任务，等做好准备了，再回过头执行第二阶段。</p> <p>有个任务是读取文件进行处理，任务的第一阶段是向操作系统发出请求，然后执行其他任务，等操作系统返回文件，再执行第二阶段处理文件。</p> <p>所谓回调函数，就是把任务的第二阶段写在一个函数里面，等重新执行这个任务的时候，直接调用这个函数。</p> <blockquote><p>Node约定，回调函数的第一个参数，必须是错误对象err（如果没有错误，该参数就是null&gt;</p> <p>原因是执行分成两个阶段后，第一阶段执行后，任务所在的上下文环境结束了，在这个以后抛出的错误，原来的上下文环境无法不作，只能当做参数，传入第二阶段。</p></blockquote> <p>回调函数的问题在于多个回调函数嵌套，Promise就是为了解决这个问题提出的，不是新的语法功能，是一种新的写法，允许将回调函数的嵌套改为链式调用。</p> <p>Promise的写法只是回调函数的改进，使用then方法后，异步任务的两阶段很明确。</p> <p>Promise的最大问题是代码冗余。</p> <h3 id="generator函数"><a href="#generator函数" class="header-anchor">#</a> Generator函数</h3> <p>传统的编程语言，早就有异步编程的解决方案，其中一种就是协程，多个线程互相协作，完成异步任务。</p> <p>协程有点像函数，又有点像线程，允许流程：</p> <ol><li>协程A开始执行</li> <li>协程A执行到一半，进入暂停，执行权转移协程B</li> <li>协程B交还执行权</li> <li>协程A恢复执行</li></ol> <div class="language-js extra-class"><pre class="language-js"><code><span class="token comment">//读取文件的协程写法</span>
<span class="token keyword">function</span><span class="token operator">*</span> <span class="token function">asyncJob</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
    <span class="token comment">//...</span>
    <span class="token keyword">var</span> f <span class="token operator">=</span> <span class="token keyword">yield</span> <span class="token function">readFile</span><span class="token punctuation">(</span>fileA<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token comment">//...</span>
<span class="token punctuation">}</span>
</code></pre></div><p>asynJob是一个协程，奥妙之处就在于yield命令。它表示执行到此处，执行权交个其他协程，即yield命令是异步两个阶段的分界线。</p> <p>协程遇到yield命令就暂停，等执行权返回，再从暂停的地方继续执行。最大有点就是：代码的写法非常相同步，如果除去yield命令，简直一样。</p> <p>Generator函数是协程在ES6的实现，最大的特点就是交出了函数的执行权。</p> <p>整个Generator函数就是一个封装的异步任务，或是异步任务容器。</p> <p>next方法的作用就是分阶段执行Generator函数。</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">var</span> fetch <span class="token operator">=</span> <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">'node-fetch'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">function</span><span class="token operator">*</span> <span class="token function">gen</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
    <span class="token keyword">var</span> url<span class="token operator">=</span><span class="token string">'http://xxxx'</span><span class="token punctuation">;</span>
    <span class="token keyword">var</span> result <span class="token operator">=</span> <span class="token keyword">yield</span> <span class="token function">fetch</span><span class="token punctuation">(</span>url<span class="token punctuation">)</span><span class="token punctuation">;</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>result<span class="token punctuation">.</span>bio<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">var</span> g <span class="token operator">=</span> <span class="token function">gen</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">var</span> result <span class="token operator">=</span> g<span class="token punctuation">.</span><span class="token function">next</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
result<span class="token punctuation">.</span>value<span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">data</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
    <span class="token keyword">return</span> data<span class="token punctuation">.</span>json<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">data</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
    g<span class="token punctuation">.</span><span class="token function">next</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span>
</code></pre></div><p>首先执行Generator函数，获取遍历器对象，使用nextf方法，执行异步任务的第一阶段。由于Fetch模块返回一个Promise对象，所以需要用then方法调用下一个next方法。</p> <h3 id="thunk函数"><a href="#thunk函数" class="header-anchor">#</a> Thunk函数</h3> <p>该函数是自动执行Generator函数的一种方法。</p> <p>编译器的&quot;传名调用&quot;实现，往往是就那个参数放到一个临时函数中，再将这个临时函数传入函数，这个临时函数就叫做Thunk函数。</p> <div class="language-javascript extra-class"><pre class="language-javascript"><code><span class="token keyword">function</span> <span class="token function">f</span><span class="token punctuation">(</span><span class="token parameter">m</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
    <span class="token keyword">return</span> m<span class="token operator">*</span><span class="token number">2</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token function">f</span><span class="token punctuation">(</span>x<span class="token operator">+</span><span class="token number">5</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">//等同于</span>
<span class="token keyword">var</span> <span class="token function-variable function">thunk</span><span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
    <span class="token keyword">return</span> x<span class="token operator">+</span><span class="token number">5</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">thunk</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
    <span class="token keyword">return</span> <span class="token function">thunk</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">*</span><span class="token number">2</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><p>函数f的参数x+5被一个函数替换，凡是用到原参数的edifice，用Thunk函数求值即可。</p> <p>这个就是Tunkh函数的定义，是'传名调用'的一种策略，用来替换这个表达式。</p> <p>JavaScrip语言是传值调用的，它的Thunk函数含义有所不同。</p> <p>在JavaScript中，Thunk函数替换的不是表达式，而是多参数函数，将其替换成一个只接受回调函数作为参数的单参数函数。</p> <div class="language-javascript extra-class"><pre class="language-javascript"><code><span class="token keyword">var</span> <span class="token function-variable function">Thunk</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">fileName</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
    <span class="token keyword">return</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">callback</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
        <span class="token keyword">return</span> fs<span class="token punctuation">.</span><span class="token function">readFile</span><span class="token punctuation">(</span>fileName<span class="token punctuation">,</span> callback<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
<span class="token keyword">var</span> readFileThunk <span class="token operator">=</span> <span class="token function">Thunk</span><span class="token punctuation">(</span>fileName<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token function">readFileThunk</span><span class="token punctuation">(</span>callback<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><p>一个单参数函数，只接受回调函数作为参数，这个单参数版本就叫做Thunk函数。</p> <p>任何函数，只要参数有回调函数，就能写出Thunk函数形式。</p> <p>Thunk函数转换器</p> <div class="language-javascript extra-class"><pre class="language-javascript"><code><span class="token comment">//ES5</span>
<span class="token keyword">var</span> <span class="token function-variable function">Thunk</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">fn</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
    <span class="token keyword">return</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
        <span class="token keyword">var</span> args <span class="token operator">=</span> <span class="token class-name">Array</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span><span class="token function">slice</span><span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span>arguments<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">return</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">callback</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
            args<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>callback<span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token keyword">return</span> <span class="token function">fn</span><span class="token punctuation">.</span><span class="token function">apply</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span> args<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
<span class="token comment">//ES6</span>
<span class="token keyword">const</span> <span class="token function-variable function">Thunk</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">fn</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
    <span class="token keyword">return</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter"><span class="token operator">...</span>args</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
        <span class="token keyword">return</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">callback</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
            <span class="token keyword">return</span> <span class="token function">fn</span><span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span> <span class="token operator">...</span>args<span class="token punctuation">,</span>callback<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><p>实际生产环境的转换器，建议使用Thunkify模块</p> <div class="language-javascript extra-class"><pre class="language-javascript"><code><span class="token keyword">var</span> thunkify <span class="token operator">=</span> <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">'thunkify'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">var</span> fs <span class="token operator">=</span> <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">'fs'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">var</span> read <span class="token operator">=</span> <span class="token function">thunkify</span><span class="token punctuation">(</span>fs<span class="token punctuation">.</span>readFIile<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token function">read</span><span class="token punctuation">(</span><span class="token string">'package.json'</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">err<span class="token punctuation">,</span>str</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
    <span class="token comment">//...</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span>
</code></pre></div><p>Generator函数的流程管理</p> <p>Thunk函数可以用于Generator函数的自动流程管理。</p> <p>Generator函数可以自动执行完成所有步骤，但是不适合异步操作，若必须保证前一步执行完成，才能后一步，Thunk函数就能派上用处。Thunk函数的真正威力，在于可以自动执行Generator函数。</p> <h3 id="co模块"><a href="#co模块" class="header-anchor">#</a> co模块</h3> <p>用于Generator函数的自动执行。</p> <p>co模块可以让你不用编写Generator函数的执行器。</p> <div class="language-javascript extra-class"><pre class="language-javascript"><code><span class="token keyword">var</span> co <span class="token operator">=</span> <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">'co'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token function">co</span><span class="token punctuation">(</span>gen<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><p>Generator函数只要传入co函数，就会自动执行。</p> <p>co函数返回一个Promise对象，可以用then方法添加回调函数。</p> <p>co原理就是讲两种执行权Thunk函数和Promise对象，包装成一个模块，使用co的前提条件是，Generator函数的yield命令后面，只能是Thunk函数或Promise对象，若是数组或对象的成员，全部是Promise对象，也可以使用co。</p> <p>基于Promise对象的自动执行</p> <div class="language-javascript extra-class"><pre class="language-javascript"><code><span class="token keyword">var</span> fs <span class="token operator">=</span> <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">'fs'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">var</span> <span class="token function-variable function">readFile</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">fileName</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
    <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">Promise</span><span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">resolve<span class="token punctuation">,</span> reject</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
        fs<span class="token punctuation">.</span><span class="token function">readFile</span><span class="token punctuation">(</span>fileName<span class="token punctuation">,</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">error<span class="token punctuation">,</span>data</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
            <span class="token keyword">if</span><span class="token punctuation">(</span>error<span class="token punctuation">)</span><span class="token punctuation">{</span>
                <span class="token keyword">return</span> <span class="token function">reject</span><span class="token punctuation">(</span>error<span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span><span class="token keyword">else</span><span class="token punctuation">{</span>
                <span class="token function">resolve</span><span class="token punctuation">(</span>data<span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
        <span class="token punctuation">}</span><span class="token punctuation">)</span>
    <span class="token punctuation">}</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span>

<span class="token keyword">var</span> <span class="token function-variable function">gen</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token operator">*</span> <span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
    <span class="token keyword">var</span> f1 <span class="token operator">=</span> <span class="token keyword">yield</span> <span class="token function">readFile</span><span class="token punctuation">(</span><span class="token string">'xxx'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">var</span> f2 <span class="token operator">=</span> <span class="token keyword">yield</span> <span class="token function">readFile</span><span class="token punctuation">(</span><span class="token string">'xxxx'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>f1<span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>f2<span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token comment">//手动执行,其实就是用then方法，层层添加回调函数</span>
<span class="token keyword">var</span> g <span class="token operator">=</span> <span class="token function">gen</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
g<span class="token punctuation">.</span><span class="token function">next</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span>value<span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">data</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
    g<span class="token punctuation">.</span><span class="token function">next</span><span class="token punctuation">(</span>data<span class="token punctuation">)</span><span class="token punctuation">.</span>value<span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">data</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
        g<span class="token punctuation">.</span><span class="token function">next</span><span class="token punctuation">(</span>data<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span>

<span class="token comment">//自动执行器(理解上面手动执行原理)</span>
<span class="token keyword">function</span> <span class="token function">run</span><span class="token punctuation">(</span><span class="token parameter">gen</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
    <span class="token keyword">var</span> g <span class="token operator">=</span> <span class="token function">gen</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">function</span> <span class="token function">next</span><span class="token punctuation">(</span><span class="token parameter">data</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
        <span class="token keyword">var</span> result <span class="token operator">=</span> g<span class="token punctuation">.</span><span class="token function">next</span><span class="token punctuation">(</span>data<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">if</span><span class="token punctuation">(</span>result<span class="token punctuation">.</span>done<span class="token punctuation">)</span><span class="token punctuation">{</span>
            <span class="token keyword">return</span> result<span class="token punctuation">.</span>value<span class="token punctuation">;</span>
        <span class="token punctuation">}</span><span class="token keyword">else</span><span class="token punctuation">{</span>
            result<span class="token punctuation">.</span>value<span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">data</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
                <span class="token function">next</span><span class="token punctuation">(</span>data<span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span><span class="token punctuation">)</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
    <span class="token function">next</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token function">run</span><span class="token punctuation">(</span>gen<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><h3 id="co模块的源码"><a href="#co模块的源码" class="header-anchor">#</a> co模块的源码</h3> <h2 id="async函数"><a href="#async函数" class="header-anchor">#</a> async函数</h2> <p>ES2017引入async函数，使得异步操作变得更加方便。</p> <p>async函数时Generator函数的语法糖。</p> <p>对于Generator函数，依次读取两个文件，可以将gen写成async函数</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">const</span> <span class="token function-variable function">asyncReadFile</span> <span class="token operator">=</span> <span class="token keyword">async</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
    <span class="token keyword">const</span> f1 <span class="token operator">=</span> <span class="token keyword">await</span> <span class="token function">readFile</span><span class="token punctuation">(</span><span class="token string">'xxx'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">const</span> f2 <span class="token operator">=</span> <span class="token keyword">await</span> <span class="token function">readFile</span><span class="token punctuation">(</span><span class="token string">'xxxx'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>f1<span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>f2<span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><p>async函数将Generator函数的星号替换为async，将yield替换为await，对Genertor改进体现在：</p> <ol><li><p>内置执行器</p> <blockquote><p>Generator函数的执行必须靠执行器，所以有了co模块，而async函数自带执行器，即async函数执行与普通函数一样。</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token function">asyncReadFile</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><p>自动执行，输出最后结果。Generator函数，需要调用next方法，或用co模块。</p></blockquote></li> <li><p>更好的语义</p> <p>async表示函数里有异步操作，await表示紧跟在后面的表达式需要等待结果。</p></li> <li><p>更广的使用性</p> <p>co模块约定，yield命令后面只能是Thunk函数或Promise对象</p> <p>async函数的await命令后面，可以是Promise对象和原始类型的值（数值、字符串、布尔值，都会立即转成立即resolved的Promise对象）</p></li> <li><p>返回值是Promise</p> <p>async函数返回值是Promise对象，这边Generator函数返回值是Iterator对象方便，可以用then方法指定下一步操作。</p></li></ol> <p>async函数完全可以看做多个异步操作，包装成一个Promise对象，而await命令就是内部then命令的语法糖。</p> <h3 id="基本用法-2"><a href="#基本用法-2" class="header-anchor">#</a> 基本用法</h3> <p>async函数返回一个Promise对象，可以使用then方法添加回调函数。<strong>当函数执行的时候，一旦遇到await就会先返回，等到异步操作完成，再接着执行函数体后面的语句。</strong></p> <div class="language-javascript extra-class"><pre class="language-javascript"><code><span class="token keyword">async</span> <span class="token keyword">function</span> <span class="token function">getStockPriceByName</span><span class="token punctuation">(</span><span class="token parameter">name</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
    <span class="token keyword">const</span> symbol <span class="token operator">=</span> <span class="token keyword">await</span> <span class="token function">getStockSymbol</span><span class="token punctuation">(</span>name<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">const</span> stockPrice <span class="token operator">=</span> <span class="token keyword">await</span> <span class="token function">getStockPrice</span><span class="token punctuation">(</span>symbol<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> stockPrice<span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token function">getStockPriceByName</span><span class="token punctuation">(</span><span class="token string">'goog'</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">result</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>result<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">//调用该函数，会立即返回一个Promise对象。</span>
</code></pre></div><div class="language-javascript extra-class"><pre class="language-javascript"><code><span class="token keyword">function</span> <span class="token function">timeouit</span><span class="token punctuation">(</span><span class="token parameter">ms</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
    <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">Promise</span><span class="token punctuation">(</span><span class="token parameter">resolve</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
        <span class="token function">setTimeout</span><span class="token punctuation">(</span>resolve<span class="token punctuation">,</span> ms<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token keyword">async</span> <span class="token keyword">function</span> <span class="token function">asyncPrint</span><span class="token punctuation">(</span><span class="token parameter">value<span class="token punctuation">,</span> ms</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
    <span class="token keyword">await</span> <span class="token function">timeout</span><span class="token punctuation">(</span>ms<span class="token punctuation">)</span><span class="token punctuation">;</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>value<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>

<span class="token function">asyncPrint</span><span class="token punctuation">(</span><span class="token string">'hello world'</span><span class="token punctuation">,</span> <span class="token number">50</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><p>async函数有多种形式：</p> <div class="language-javascript extra-class"><pre class="language-javascript"><code><span class="token keyword">async</span> <span class="token keyword">function</span> <span class="token function">foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token punctuation">}</span> <span class="token comment">//函数声明</span>
<span class="token keyword">const</span> <span class="token function-variable function">foo</span> <span class="token operator">=</span> <span class="token keyword">async</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token punctuation">}</span> <span class="token comment">//函数表达式</span>

<span class="token keyword">let</span> obj <span class="token operator">=</span> <span class="token punctuation">{</span> <span class="token keyword">async</span> <span class="token function">foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token punctuation">}</span> <span class="token punctuation">}</span><span class="token comment">//对象的方法</span>
obj<span class="token punctuation">.</span><span class="token function">foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span><span class="token comment">/*...*/</span><span class="token punctuation">)</span>
               
<span class="token comment">//Class 的方法</span>
<span class="token keyword">class</span> <span class="token class-name">Storage</span><span class="token punctuation">{</span>
    <span class="token function">constructor</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
        <span class="token keyword">this</span><span class="token punctuation">.</span>cachePromise <span class="token operator">=</span> caches<span class="token punctuation">.</span><span class="token function">open</span><span class="token punctuation">(</span><span class="token string">'avatars'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    
    <span class="token keyword">async</span> <span class="token function">getAvatar</span><span class="token punctuation">(</span><span class="token parameter">name</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
        <span class="token keyword">const</span> cache <span class="token operator">=</span> <span class="token keyword">await</span> <span class="token keyword">this</span><span class="token punctuation">.</span>cachePromise<span class="token punctuation">;</span>
        <span class="token keyword">return</span> cache<span class="token punctuation">.</span><span class="token function">match</span><span class="token punctuation">(</span><span class="token template-string"><span class="token template-punctuation string">`</span><span class="token string">/avatars/</span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span>name<span class="token interpolation-punctuation punctuation">}</span></span><span class="token string">.jpg</span><span class="token template-punctuation string">`</span></span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token keyword">const</span> storage <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Storage</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
storage<span class="token punctuation">.</span><span class="token function">getAvatar</span><span class="token punctuation">(</span><span class="token string">'jake'</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span><span class="token comment">/**/</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token comment">//箭头函数</span>
<span class="token keyword">const</span> <span class="token function-variable function">foo</span> <span class="token operator">=</span> <span class="token keyword">async</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>

</code></pre></div><h3 id="async语法"><a href="#async语法" class="header-anchor">#</a> async语法</h3> <p>难点是错误处理机制</p> <p>async函数返回一个Promise对象。</p> <p>async函数内部return语句返回的值，会成为then方法回调函数的参数。</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">async</span> <span class="token keyword">function</span> <span class="token function">f</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
    <span class="token keyword">return</span> <span class="token string">'hello world'</span><span class="token punctuation">;</span> <span class="token comment">//return命令返回值，会被then方法回调函数接收</span>
<span class="token punctuation">}</span>

<span class="token function">f</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span><span class="token parameter">v</span> <span class="token operator">=&gt;</span> console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>v<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><p>async函数内部抛出错误，会导致返回的Promise对象变为reject状态。抛出的错误对象会被catch方法回调函数接收到。</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">async</span> <span class="token keyword">function</span> <span class="token function">f</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
    <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">Error</span><span class="token punctuation">(</span><span class="token string">'error'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token function">f</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span><span class="token parameter">v</span><span class="token operator">=&gt;</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>v<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token parameter">e</span> <span class="token operator">=&gt;</span> console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>e<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><p>async函数返回的Promise对象，必须等到内部所有的await命令后面的Promise对象执行完，才会发生状态改变，除非遇到return语句或抛出错误，即只有函数async函数内部的异步操作执行完成，才会执行then方法指定的回调函数。</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">async</span> <span class="token keyword">function</span> <span class="token function">getTitle</span><span class="token punctuation">(</span><span class="token parameter">url</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
    <span class="token keyword">let</span> response <span class="token operator">=</span> <span class="token keyword">await</span> <span class="token function">fetch</span><span class="token punctuation">(</span>url<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">let</span> html <span class="token operator">=</span> <span class="token keyword">await</span> response<span class="token punctuation">.</span><span class="token function">text</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">return</span> html<span class="token punctuation">.</span><span class="token function">match</span><span class="token punctuation">(</span><span class="token regex">/&lt;title&gt;([\s\S]+)&lt;\/title&gt;/i</span><span class="token punctuation">)</span><span class="token punctuation">[</span><span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token function">getTitle</span><span class="token punctuation">(</span><span class="token string">'http://xxxx'</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span>console<span class="token punctuation">.</span>log<span class="token punctuation">)</span>
</code></pre></div><p>上述代码，函数内部有三个操作，要等全部完成后，才会执行then方法里面的console.log</p> <p><strong>正常情况下，await命令后面是一个Promise对象，返回该对象的结果</strong>。如果不是，就直接返回对应的值。</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">async</span> <span class="token keyword">function</span> <span class="token function">f</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
    <span class="token keyword">return</span> <span class="token keyword">await</span> <span class="token number">123</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token function">f</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span><span class="token parameter">v</span> <span class="token operator">=&gt;</span> console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>v<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><p>另一种情况，await命令后面是一个thenable对象，那么await会将其等同于Promise对象</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">class</span> <span class="token class-name">Sleep</span><span class="token punctuation">{</span>
    <span class="token function">constructor</span><span class="token punctuation">(</span><span class="token parameter">timeout</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
        <span class="token keyword">this</span><span class="token punctuation">.</span>timeout <span class="token operator">=</span> timeout<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token function">then</span><span class="token punctuation">(</span><span class="token parameter">resolve<span class="token punctuation">,</span> reject</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
        <span class="token keyword">const</span> startTime <span class="token operator">=</span> Date<span class="token punctuation">.</span><span class="token function">now</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token function">setTimeout</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">=&gt;</span><span class="token function">resolve</span><span class="token punctuation">(</span>Date<span class="token punctuation">.</span><span class="token function">now</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">-</span> startTime<span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token keyword">this</span><span class="token punctuation">.</span>timeout<span class="token punctuation">)</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token punctuation">(</span><span class="token keyword">async</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
    <span class="token keyword">const</span> sleepTime <span class="token operator">=</span> <span class="token keyword">await</span> <span class="token keyword">new</span> <span class="token class-name">Sleep</span><span class="token punctuation">(</span><span class="token number">1000</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>sleepTime<span class="token punctuation">)</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><p>await命令后面的Promise对象如果变为reject状态，则reject参数会被catch方法的回调函数接收。</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">async</span> <span class="token keyword">function</span> <span class="token function">f</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
    <span class="token keyword">await</span> Promise<span class="token punctuation">.</span><span class="token function">reject</span><span class="token punctuation">(</span><span class="token string">'Error'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token function">f</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span><span class="token parameter">v</span><span class="token operator">=&gt;</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>v<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">catch</span><span class="token punctuation">(</span><span class="token parameter">e</span> <span class="token operator">=&gt;</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>e<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">//reject方法的参数传入catch方法的回调函数，这里在await前面加上return 一样。</span>
</code></pre></div><p>任何一个await语句后面的Promise对象变为reject状态，那么整个async函数都会中断执行。</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">async</span> <span class="token keyword">function</span> <span class="token function">f</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
    <span class="token keyword">await</span> Promise<span class="token punctuation">.</span><span class="token function">reject</span><span class="token punctuation">(</span><span class="token string">'error'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">await</span> Promise<span class="token punctuation">.</span><span class="token function">resolve</span><span class="token punctuation">(</span><span class="token string">'123'</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//不会执行了</span>
<span class="token punctuation">}</span>
</code></pre></div><p>若不希望中断，则可以将第一个await放在try...catch结构里面，这样不论前面是够成功，下面的await会执行。</p> <p>另一种方法就是在第一个await后面Promise对象再跟一个catch方法，处理前面可能出现的错误。</p> <p>如果await后面的异步操作出错，那么等同于async函数返回的Promise对象被reject。</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">async</span> <span class="token keyword">function</span> <span class="token function">f</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
    <span class="token keyword">await</span> <span class="token keyword">new</span> <span class="token class-name">Promise</span><span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">resolve<span class="token punctuation">,</span> reject</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
        <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">Error</span><span class="token punctuation">(</span><span class="token string">'error'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span>
<span class="token function">f</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span><span class="token parameter">v</span> <span class="token operator">=&gt;</span> console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>v<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">catch</span><span class="token punctuation">(</span><span class="token parameter">e</span><span class="token operator">=&gt;</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>e<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><p>防止出错的方法，就是将await放在try...catch中。</p> <p>如果多个await，可以统一放在try...catch结构中。</p> <blockquote><p>注意点：</p> <p>await命令后面是Promise对象，可能会rejected,所以做好将await放在try...catch中</p> <p>多个await命令后面的异步操作，如果不存咋继发关系，最好同时触发</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token comment">//写法一</span>
<span class="token keyword">let</span> <span class="token punctuation">[</span>foo<span class="token punctuation">,</span> bar<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token keyword">await</span> Promise<span class="token punctuation">.</span><span class="token function">all</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token function">getFoo</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">,</span> <span class="token function">getBar</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">//写法二</span>
<span class="token keyword">let</span> fooPromise <span class="token operator">=</span> <span class="token function">getFoo</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">let</span> barPromise <span class="token operator">=</span> <span class="token function">getBar</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">let</span> foo <span class="token operator">=</span> <span class="token keyword">await</span> fooPromise<span class="token punctuation">;</span>
<span class="token keyword">let</span> bar <span class="token operator">=</span> <span class="token keyword">await</span> <span class="token operator">=</span> barPromise<span class="token punctuation">;</span>
</code></pre></div><p>await命令只能用在async函数中</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">async</span> <span class="token keyword">function</span> <span class="token function">dbFun</span><span class="token punctuation">(</span><span class="token parameter">db</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
    <span class="token keyword">let</span> docs <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">,</span><span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">,</span><span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
    <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">let</span> doc <span class="token keyword">of</span> docs<span class="token punctuation">)</span><span class="token punctuation">{</span>
        <span class="token keyword">await</span> db<span class="token punctuation">.</span><span class="token function">post</span><span class="token punctuation">(</span>doc<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><p>async函数可以保留运行堆栈。</p></blockquote> <h3 id="async函数实现原理"><a href="#async函数实现原理" class="header-anchor">#</a> async函数实现原理</h3> <p>实现原理就是将Generator函数和自动执行器，包装在一个函数里。</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">async</span> <span class="token keyword">function</span> <span class="token function">fn</span><span class="token punctuation">(</span><span class="token parameter">args</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token punctuation">}</span>
<span class="token comment">//等同于</span>
<span class="token keyword">function</span> <span class="token function">fn</span><span class="token punctuation">(</span><span class="token parameter">args</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
    <span class="token keyword">return</span> <span class="token function">spawn</span><span class="token punctuation">(</span><span class="token keyword">function</span><span class="token operator">*</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
        <span class="token comment">//....</span>
    <span class="token punctuation">}</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span>
<span class="token comment">//spawn函数时自动执行器</span>

<span class="token keyword">function</span> <span class="token function">spawn</span><span class="token punctuation">(</span><span class="token parameter">genF</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
    <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">Promise</span><span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">resolve<span class="token punctuation">,</span> reject</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
        <span class="token keyword">const</span> gen <span class="token operator">=</span> <span class="token function">genF</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">function</span> <span class="token function">step</span><span class="token punctuation">(</span><span class="token parameter">nextF</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
            <span class="token keyword">let</span> next<span class="token punctuation">;</span>
            <span class="token keyword">try</span><span class="token punctuation">{</span>
                next <span class="token operator">=</span> <span class="token function">nextF</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span><span class="token keyword">catch</span><span class="token punctuation">(</span>e<span class="token punctuation">)</span><span class="token punctuation">{</span>
                <span class="token keyword">return</span> <span class="token function">reject</span><span class="token punctuation">(</span>e<span class="token punctuation">)</span>
            <span class="token punctuation">}</span>
            
            <span class="token keyword">if</span><span class="token punctuation">(</span>next<span class="token punctuation">.</span>done<span class="token punctuation">)</span><span class="token punctuation">{</span>
                <span class="token keyword">return</span> <span class="token function">resolve</span><span class="token punctuation">(</span>next<span class="token punctuation">.</span>value<span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
            Promise<span class="token punctuation">.</span><span class="token function">resolve</span><span class="token punctuation">(</span>next<span class="token punctuation">.</span>value<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">v</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
                <span class="token function">step</span><span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token keyword">return</span> gen<span class="token punctuation">.</span><span class="token function">next</span><span class="token punctuation">(</span>v<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span><span class="token punctuation">,</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">e</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
                <span class="token function">step</span><span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token keyword">return</span> gen<span class="token punctuation">.</span><span class="token function">throw</span><span class="token punctuation">(</span>e<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
        <span class="token function">step</span><span class="token punctuation">(</span><span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token keyword">return</span> gen<span class="token punctuation">.</span><span class="token function">next</span><span class="token punctuation">(</span><span class="token keyword">undefined</span><span class="token punctuation">)</span><span class="token punctuation">}</span><span class="token punctuation">)</span>
    <span class="token punctuation">}</span><span class="token punctuation">)</span>
<span class="token punctuation">}</span>
</code></pre></div><h3 id="按顺序完成异步操作"><a href="#按顺序完成异步操作" class="header-anchor">#</a> 按顺序完成异步操作</h3> <p>Promise的写法</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">function</span> <span class="token function">logInOrder</span><span class="token punctuation">(</span><span class="token parameter">urls</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
    <span class="token comment">//远程读取所有URL</span>
    <span class="token keyword">const</span> textPromises <span class="token operator">=</span> urls<span class="token punctuation">.</span><span class="token function">map</span><span class="token punctuation">(</span><span class="token parameter">url</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
        <span class="token keyword">return</span> <span class="token function">fetch</span><span class="token punctuation">(</span>url<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span><span class="token parameter">response</span> <span class="token operator">=&gt;</span> reponse<span class="token punctuation">.</span><span class="token function">text</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    
    <span class="token comment">//按次序输出</span>
    textPromises<span class="token punctuation">.</span><span class="token function">reduce</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token parameter">chain<span class="token punctuation">,</span>textPromise</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
        <span class="token keyword">return</span> chain<span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">=&gt;</span> textPromise<span class="token punctuation">)</span>
        	<span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span><span class="token parameter">text</span> <span class="token operator">=&gt;</span> console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>text<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span><span class="token punctuation">,</span> Promise<span class="token punctuation">.</span><span class="token function">resolve</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><p>async写法</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">async</span> <span class="token keyword">function</span> <span class="token function">logInOrder</span><span class="token punctuation">(</span><span class="token parameter">urls</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
    <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">const</span> url <span class="token keyword">of</span> urls<span class="token punctuation">)</span><span class="token punctuation">{</span>
        <span class="token keyword">const</span> response <span class="token operator">=</span> <span class="token keyword">await</span> <span class="token function">fetch</span><span class="token punctuation">(</span>url<span class="token punctuation">)</span><span class="token punctuation">;</span>
        console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token keyword">await</span> response<span class="token punctuation">.</span><span class="token function">text</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
<span class="token comment">//存在所有远程操作都是继发操作，只有前一个URL返回结果，才会读取下一个，需要并发发出远程请求</span>

<span class="token keyword">async</span> <span class="token keyword">function</span> <span class="token function">logInOrder</span><span class="token punctuation">(</span><span class="token parameter">urls</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
    <span class="token comment">//并发读取远程URL</span>
    <span class="token keyword">const</span> textPromises <span class="token operator">=</span> urls<span class="token punctuation">.</span><span class="token function">map</span><span class="token punctuation">(</span><span class="token keyword">async</span> <span class="token parameter">url</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
        <span class="token keyword">const</span> response <span class="token operator">=</span> <span class="token keyword">await</span> <span class="token function">fetch</span><span class="token punctuation">(</span>url<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">return</span> response<span class="token punctuation">.</span><span class="token function">text</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    
    <span class="token comment">//按次序输出</span>
    <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">const</span> textPromise <span class="token keyword">of</span> textPromises<span class="token punctuation">)</span><span class="token punctuation">{</span>
        console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token keyword">await</span> textPromise<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><h2 id="class-的基本语法"><a href="#class-的基本语法" class="header-anchor">#</a> Class 的基本语法</h2> <h3 id="简介"><a href="#简介" class="header-anchor">#</a> 简介</h3> <p>在JavaScript语言中，生成实例对象的传统方法是通过构造函数。</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">function</span> <span class="token function">Point</span><span class="token punctuation">(</span><span class="token parameter">x<span class="token punctuation">,</span> y</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span>x <span class="token operator">=</span> x<span class="token punctuation">;</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span>y <span class="token operator">=</span> y<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token class-name">Point</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span><span class="token function-variable function">toString</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
    <span class="token keyword">return</span> <span class="token template-string"><span class="token template-punctuation string">`</span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span><span class="token keyword">this</span><span class="token punctuation">.</span>x<span class="token interpolation-punctuation punctuation">}</span></span><span class="token string">,</span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span><span class="token keyword">this</span><span class="token punctuation">.</span>y<span class="token interpolation-punctuation punctuation">}</span></span><span class="token template-punctuation string">`</span></span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token keyword">var</span> p <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Point</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">,</span> <span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><p>ES6提供了更接近传统语言的写法，引入了Class类的概念，作为对象的模板。</p> <p>基本上ES6的class可以看做是一个语法糖。</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">class</span> <span class="token class-name">Point</span><span class="token punctuation">{</span>
    <span class="token function">constructor</span><span class="token punctuation">(</span><span class="token parameter">x<span class="token punctuation">,</span> y</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
        <span class="token keyword">this</span><span class="token punctuation">.</span>x <span class="token operator">=</span> x<span class="token punctuation">;</span>
        <span class="token keyword">this</span><span class="token punctuation">.</span>y <span class="token operator">=</span> y<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
        <span class="token keyword">return</span> <span class="token template-string"><span class="token template-punctuation string">`</span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span><span class="token keyword">this</span><span class="token punctuation">.</span>x<span class="token interpolation-punctuation punctuation">}</span></span><span class="token string">, </span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span><span class="token keyword">this</span><span class="token punctuation">.</span>y<span class="token interpolation-punctuation punctuation">}</span></span><span class="token template-punctuation string">`</span></span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><p>调用constructor方法，这就是构造方法，而this关键字则代表实例对象。</p> <p>ES5的构造函数Point，对应ES6的Point类的构造方法。</p> <p>Point类除了构造方法，还定义了一个toString方法。</p> <p>ES6的类，完全可以看做构造函数的另一种写法</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">class</span> <span class="token class-name">Point</span><span class="token punctuation">{</span>
    <span class="token comment">//...</span>
<span class="token punctuation">}</span>
<span class="token keyword">typeof</span> Point<span class="token punctuation">;</span> <span class="token comment">//'function'</span>
Point <span class="token operator">===</span> <span class="token class-name">Point</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span>constructor <span class="token comment">//true</span>
</code></pre></div><p>类的数据类型就是函数，类本身就指向构造函数。</p> <p>构造函数的prototype属性，在ES6的类上继续存在，类的所有方法都定义在类的prototype属性上面。</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">class</span> <span class="token class-name">Point</span><span class="token punctuation">{</span>
    <span class="token function">constructor</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
        <span class="token comment">//...</span>
    <span class="token punctuation">}</span>
    <span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
        <span class="token comment">//...</span>
    <span class="token punctuation">}</span>
    <span class="token function">toValue</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
        <span class="token comment">//...</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
<span class="token comment">//等同于</span>
<span class="token class-name">Point</span><span class="token punctuation">.</span>prototype <span class="token operator">=</span> <span class="token punctuation">{</span>
    <span class="token function">constructor</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">,</span>
    <span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">,</span>
    <span class="token function">toValue</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><p>在类的实例上调用方法，其实就是调用原型上的方法。</p> <div class="language-javascript extra-class"><pre class="language-javascript"><code><span class="token keyword">class</span> <span class="token class-name">B</span><span class="token punctuation">{</span><span class="token punctuation">}</span>
<span class="token keyword">let</span> b <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">B</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
b<span class="token punctuation">.</span>constructor <span class="token operator">===</span> <span class="token class-name">B</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span>constructor <span class="token comment">//true</span>
</code></pre></div><p>由于类的方法都定义在prototype对象上，所以类的新方法可以添加在prototype对象上面。</p> <p>Object.assign方法可以方便的一次向类添加多个方法。</p> <div class="language-javascript extra-class"><pre class="language-javascript"><code><span class="token keyword">class</span> <span class="token class-name">Point</span><span class="token punctuation">{</span>
    <span class="token function">constructor</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token punctuation">}</span>
<span class="token punctuation">}</span>
Object<span class="token punctuation">.</span><span class="token function">assgin</span><span class="token punctuation">(</span><span class="token class-name">Point</span><span class="token punctuation">.</span>prototype<span class="token punctuation">,</span> <span class="token punctuation">{</span>
    <span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">,</span>
    <span class="token function">toValue</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token punctuation">}</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span>
</code></pre></div><p>prototype对象的constructor属性直接指向类的本身。</p> <p>类内部所有定义的方法，都是不可枚举的，这是和ES5有区别的。</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">class</span> <span class="token class-name">Point</span><span class="token punctuation">{</span>
    <span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token punctuation">}</span>
<span class="token punctuation">}</span>
Object<span class="token punctuation">.</span><span class="token function">keys</span><span class="token punctuation">(</span><span class="token class-name">Point</span><span class="token punctuation">.</span>prototype<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//[]</span>

<span class="token keyword">function</span> <span class="token function">Point</span><span class="token punctuation">(</span><span class="token parameter">x<span class="token punctuation">,</span>y</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token punctuation">}</span>
<span class="token class-name">Point</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span><span class="token function-variable function">toString</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token punctuation">}</span>
Object<span class="token punctuation">.</span><span class="token function">keys</span><span class="token punctuation">(</span><span class="token class-name">Point</span><span class="token punctuation">.</span>prototype<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//['string']</span>
</code></pre></div><p><strong>constructor方法</strong>是类的默认方法，通过new命令生成对象实例，自动调用该方法。</p> <p>constructor方法默认返回实例对象（即this）,完全可以指定返回另一个对象。</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">class</span> <span class="token class-name">Foo</span><span class="token punctuation">{</span>
    <span class="token function">constructor</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
        <span class="token keyword">return</span> Object<span class="token punctuation">.</span><span class="token function">create</span><span class="token punctuation">(</span><span class="token keyword">null</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
<span class="token keyword">new</span> <span class="token class-name">Foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token keyword">instanceof</span> <span class="token class-name">Foo</span><span class="token punctuation">;</span><span class="token comment">//false</span>
<span class="token comment">//返回以个新对象，导致实例对象不是Foo类的实例</span>
</code></pre></div><p>类必须使用new功能，否则报错，这个和普通构造函数的区别，后者不用new也可以执行。</p> <p><strong>类的实例</strong>：用new命令生成类的实例。</p> <p>实例的属性除了显示定义在其本身，即this对象上，否则都是定义在原型上，即class上。</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token comment">//定义类</span>
<span class="token keyword">class</span> <span class="token class-name">Point</span><span class="token punctuation">{</span>
    <span class="token function">constructor</span><span class="token punctuation">(</span><span class="token parameter">x<span class="token punctuation">,</span> y</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
        <span class="token keyword">this</span><span class="token punctuation">.</span>x <span class="token operator">=</span> x<span class="token punctuation">;</span>
        <span class="token keyword">this</span><span class="token punctuation">.</span>y <span class="token operator">=</span> y
    <span class="token punctuation">}</span>
    <span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
        <span class="token keyword">return</span> <span class="token template-string"><span class="token template-punctuation string">`</span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span><span class="token keyword">this</span><span class="token punctuation">.</span>x<span class="token interpolation-punctuation punctuation">}</span></span><span class="token string">, </span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span><span class="token keyword">this</span><span class="token punctuation">.</span>y<span class="token interpolation-punctuation punctuation">}</span></span><span class="token template-punctuation string">`</span></span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token keyword">var</span> point <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Point</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
point<span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>

point<span class="token punctuation">.</span><span class="token function">hasOwnProperty</span><span class="token punctuation">(</span><span class="token string">'x'</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//true</span>
point<span class="token punctuation">.</span><span class="token function">hasOwnProperty</span><span class="token punctuation">(</span><span class="token string">'toString'</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// false</span>
point<span class="token punctuation">.</span>__proto__<span class="token punctuation">.</span><span class="token function">hasOwnProperty</span><span class="token punctuation">(</span><span class="token string">'toString'</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">// true</span>
</code></pre></div><p>x,y都是实例对象point自身的属性（因为定义在this变量上），toString是原型对象的属性。</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">let</span> p1 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Point</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">let</span> p2 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Point</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
p1<span class="token punctuation">.</span>__proto__ <span class="token operator">===</span> p2<span class="token punctuation">.</span>__proto__<span class="token punctuation">;</span><span class="token comment">//true,原型都是Point.prototype.</span>
<span class="token comment">//当改变p1的原型是，p2的原型也随着改变</span>
</code></pre></div><p>生成环境中，我们可以通过Object.getPrototypeOf方法来获取实例对象的原型，然后再为原型添加方法和属性。</p> <p>类的内部也可以使用<strong>get</strong>和<strong>set</strong>关键字，对某个属性设置存值函数和取值函数，拦截该属性的存取行为。</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">class</span> <span class="token class-name">MyClass</span><span class="token punctuation">{</span>
    <span class="token function">constructor</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token punctuation">}</span>
    <span class="token keyword">get</span> <span class="token function">prop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
        <span class="token keyword">return</span> <span class="token string">'getter'</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">set</span> <span class="token function">prop</span><span class="token punctuation">(</span><span class="token parameter">value</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
        console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>value<span class="token punctuation">)</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
<span class="token keyword">let</span> instance <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">MyClass</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">//prop属性有对应的存值函数和取值函数，因此赋值和读取行为都被自定义了。</span>
</code></pre></div><p>存值函数和取值函数时设置在属性的Descriptor对象上。</p> <p><strong>属性表达式</strong>,类的属性名可以采用表达式。</p> <p>与函数一样，类也可以使用表达式的形式定义。</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">const</span> MyClass <span class="token operator">=</span> <span class="token keyword">class</span> <span class="token class-name">Me</span><span class="token punctuation">{</span>
    <span class="token function">getClassName</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
        <span class="token keyword">return</span> Me<span class="token punctuation">.</span>name<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><p>需要注意这个类的名字是Me，但是Me只能在Class内部可用，指代当前类，在Class外部，这个类只能使用MyClass引用。</p> <p>如果内部没有用到，可以省略Me。</p> <p>注意：</p> <ol><li><p>严格模式，类和模块的内部默认就是严格模式。</p></li> <li><p>类不存在变量提升</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">new</span> <span class="token class-name">Foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//ReferenceError</span>
<span class="token keyword">class</span> <span class="token class-name">Foo</span><span class="token punctuation">{</span><span class="token punctuation">}</span>
<span class="token comment">//ES6不会把类的声明提升到代码头部，这只要是因为与下文继承有关，必须保证子类在父类之后定义。</span>
</code></pre></div></li> <li><p>name属性，由于本质上ES6的类只是ES5构造函数的一层包装，所以函数的许多特性都被Class继承，包括name属性。总是返回紧跟在class关键字后面的类名。</p></li> <li><p>Generator方法:类的Symbol.iterator方法前有一个星号，表示Generator函数，返回一个类的默认遍历器。</p></li> <li><p>this指向，类的方法内部如果包含this，默认指向类的实例。一旦单独使用，可能报错</p> <blockquote><p>如果需要将方法单独提出来，this指向该方法运行时所在的环境，由于class内部时严格模式，所以this实际指向undefined，从而报错。</p> <p>解决方法一：在构造函数中绑定this.</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">class</span> <span class="token class-name">A</span><span class="token punctuation">{</span>
    <span class="token function">constructor</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
        <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token constant">B</span> <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token constant">B</span><span class="token punctuation">.</span><span class="token function">bind</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><p>方法二：使用箭头函数</p> <p>方法三：使用Proxy，获取方法的时候，自动绑定this</p></blockquote></li></ol> <h3 id="静态方法-2"><a href="#静态方法-2" class="header-anchor">#</a> 静态方法</h3> <p>类相当于实例的原型，所有在类中定义的方法，都会被实例继承。如果在一个方法前加上static关键字，表示该方法不会被实例继承，而是直接通过类调用。</p> <p>注意：如果静态方法包含this关键字，这个this指向的时类，而不是实例。</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">class</span> <span class="token class-name">Foo</span><span class="token punctuation">{</span>
    <span class="token keyword">static</span> <span class="token function">bar</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
        <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">baz</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">static</span> <span class="token function">baz</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
        console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'hello'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token function">baz</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
        console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'world'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
Foo<span class="token punctuation">.</span><span class="token function">bar</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//hello</span>
</code></pre></div><p><strong>父类的静态方法可以被子类继承</strong></p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">class</span> <span class="token class-name">Foo</span><span class="token punctuation">{</span>
    <span class="token keyword">static</span> <span class="token function">classMethod</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
        
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token keyword">class</span> <span class="token class-name">Bar</span> <span class="token keyword">extends</span> <span class="token class-name">Foo</span><span class="token punctuation">{</span>
    <span class="token keyword">return</span> <span class="token keyword">super</span><span class="token punctuation">.</span><span class="token function">classMethod</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token operator">+</span> <span class="token string">'too'</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
Bar<span class="token punctuation">.</span><span class="token function">classMethod</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><p>静态方法也可以从super对象上调用</p> <h3 id="实例属性的新写法"><a href="#实例属性的新写法" class="header-anchor">#</a> 实例属性的新写法</h3> <p>实例出现除了定义在constructor方法里面的this上，也可以定义在类的最顶层。</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">class</span> <span class="token class-name">Counter</span><span class="token punctuation">{</span>
    _count <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span>
	<span class="token keyword">get</span> <span class="token function">value</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
        <span class="token keyword">return</span> <span class="token keyword">this</span><span class="token punctuation">.</span>_count<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
	<span class="token function">increment</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
        <span class="token keyword">this</span><span class="token punctuation">.</span>_count<span class="token operator">++</span><span class="token punctuation">;</span>
	<span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><h3 id="静态属性"><a href="#静态属性" class="header-anchor">#</a> 静态属性</h3> <p>静态属性指的时Class本身属性，即Class.propName，而不是定义在实例对象this上的属性。</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">class</span> <span class="token class-name">Foo</span><span class="token punctuation">{</span><span class="token punctuation">}</span>
Foo<span class="token punctuation">.</span>prop <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span><span class="token comment">//为类Foo定义了一个静态属性prop</span>
</code></pre></div><p>ES6明确规定，Class内部只有静态方法，没有静态属性。</p> <p>新提案是在实例前面加上static关键字。</p> <h3 id="私有方法和私有属性"><a href="#私有方法和私有属性" class="header-anchor">#</a> 私有方法和私有属性</h3> <p>私有方法和私有属性，只能类内部访问的方法和属性，有利于代码的封装，ES6不支持，只能变通实现。</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">class</span> <span class="token class-name">Widget</span><span class="token punctuation">{</span>
    <span class="token comment">//public</span>
    <span class="token function">foo</span><span class="token punctuation">(</span><span class="token parameter">baz</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
        <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">_bar</span><span class="token punctuation">(</span>baz<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    
    <span class="token comment">//private</span>
    <span class="token function">_bar</span><span class="token punctuation">(</span><span class="token parameter">baz</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
        <span class="token keyword">return</span> <span class="token keyword">this</span><span class="token punctuation">.</span>snaf <span class="token operator">=</span> baz<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><p>方法名前面下划线，表示是一个只限于内部使用的私有方法，但是类的外部，还是能调用这个方法。</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token comment">//将私有方法移除模块，因为模块内部的所有方法都是对外可见的</span>
<span class="token keyword">class</span> <span class="token class-name">Widget</span><span class="token punctuation">{</span>
    <span class="token function">foo</span><span class="token punctuation">(</span><span class="token parameter">baz</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
        <span class="token function">bar</span><span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span> baz<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token keyword">function</span> <span class="token function">bar</span><span class="token punctuation">(</span><span class="token parameter">baz</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
    <span class="token keyword">return</span> <span class="token keyword">this</span><span class="token punctuation">.</span>snaf <span class="token operator">=</span> baz<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><p>还有一种方法，利用Symbol值得唯一性，将私有方法的名字命名为一个Symbol值</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">const</span> bar <span class="token operator">=</span> <span class="token function">Symbol</span><span class="token punctuation">(</span><span class="token string">'bar'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">const</span> snaf <span class="token operator">=</span> <span class="token function">Symbol</span><span class="token punctuation">(</span><span class="token string">'snaf'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">export</span> <span class="token keyword">default</span> <span class="token keyword">class</span> <span class="token class-name">myClass</span><span class="token punctuation">{</span>
    <span class="token comment">//公有方法</span>
    <span class="token function">foo</span><span class="token punctuation">(</span><span class="token parameter">baz</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
        <span class="token keyword">this</span><span class="token punctuation">[</span>bar<span class="token punctuation">]</span><span class="token punctuation">(</span>baz<span class="token punctuation">)</span>
    <span class="token punctuation">}</span>
    <span class="token comment">//私有方法</span>
    <span class="token punctuation">[</span>bar<span class="token punctuation">]</span><span class="token punctuation">(</span><span class="token parameter">baz</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
        <span class="token keyword">return</span> <span class="token keyword">this</span><span class="token punctuation">[</span>snaf<span class="token punctuation">]</span> <span class="token operator">=</span> baz<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><p>一般情况下无法获取bar和snaf值，但是可以通过Reflect.ownKeys()依然可以拿到。</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">const</span> instance <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">myClass</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
Reflect<span class="token punctuation">.</span><span class="token function">ownKeys</span><span class="token punctuation">(</span>myClass<span class="token punctuation">.</span>prototype<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><p><strong>私有属性的提案</strong>，在属性名之前，使用#表示。</p> <p>私有属性，只能在类的内部使用。</p> <h3 id="new-target属性"><a href="#new-target属性" class="header-anchor">#</a> new.target属性</h3> <p>new是从构造函数生成实例对象的命令。ES6为new命令引入一个new.target属性，该属性一般用在构造函数中，返回new命令作用于那个构造函数。</p> <p>若构造函数不是通过new命令或Reflect.constructor()调用的，new.target会返回undefined。</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">function</span> <span class="token function">Person</span><span class="token punctuation">(</span><span class="token parameter">name</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
    <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token keyword">new</span><span class="token punctuation">.</span>target <span class="token operator">===</span> Person<span class="token punctuation">)</span><span class="token punctuation">{</span>
        <span class="token keyword">this</span><span class="token punctuation">.</span>name <span class="token operator">=</span> name<span class="token punctuation">;</span>
    <span class="token punctuation">}</span><span class="token keyword">else</span><span class="token punctuation">{</span>
        throe <span class="token keyword">new</span> <span class="token class-name">Error</span><span class="token punctuation">(</span><span class="token string">'必须使用new命令生成实例'</span><span class="token punctuation">)</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token comment">//上面代码确保构造函数只能通过new命令调用。</span>
</code></pre></div><p>Class内部调用new.target，返回当前的Class。</p> <p>注意： 子类继承父类，new.target会返回子类。利用这个特点，可以写出不能独立使用，必须继承后才能使用的类。</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">class</span> <span class="token class-name">Shape</span><span class="token punctuation">{</span>
    <span class="token function">constructor</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
        <span class="token keyword">if</span><span class="token punctuation">(</span><span class="token keyword">new</span><span class="token punctuation">.</span>target <span class="token operator">===</span> Shape<span class="token punctuation">)</span><span class="token punctuation">{</span>
            <span class="token keyword">throw</span> <span class="token keyword">new</span> <span class="token class-name">Error</span><span class="token punctuation">(</span><span class="token string">'本类不能实例化'</span><span class="token punctuation">)</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token keyword">class</span> <span class="token class-name">Rectangle</span> <span class="token keyword">extends</span> <span class="token class-name">Shape</span><span class="token punctuation">{</span>
    <span class="token function">constructor</span><span class="token punctuation">(</span><span class="token parameter">length<span class="token punctuation">,</span> width</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
        <span class="token keyword">super</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token comment">//...</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
<span class="token keyword">var</span> x <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Shape</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">var</span> y <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Rectangle</span><span class="token punctuation">(</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token number">4</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">//Shape类不能被实例化，只能用于继承。</span>
<span class="token comment">//在函数外部，使用new.target会报错。</span>
</code></pre></div><h2 id="class的继承"><a href="#class的继承" class="header-anchor">#</a> Class的继承</h2> <p>Class可以通过extend关键字是实现继承，这笔ES5通过修改原型链实现继承，方便清晰。</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">class</span> <span class="token class-name">Point</span><span class="token punctuation">{</span><span class="token punctuation">}</span>
<span class="token keyword">class</span> <span class="token class-name">ColorPoint</span> <span class="token keyword">extends</span> <span class="token class-name">Point</span><span class="token punctuation">{</span>
    <span class="token function">constructor</span><span class="token punctuation">(</span><span class="token parameter">x<span class="token punctuation">,</span> y<span class="token punctuation">,</span> color</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
        <span class="token keyword">super</span><span class="token punctuation">(</span>x<span class="token punctuation">,</span>y<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">this</span><span class="token punctuation">.</span>color <span class="token operator">=</span> color<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
        <span class="token keyword">return</span> <span class="token keyword">this</span><span class="token punctuation">.</span>color<span class="token operator">+</span><span class="token string">' '</span> <span class="token operator">+</span> <span class="token keyword">super</span><span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//调用父类的toString</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><p>子类必须在constructor方法调用super方法。这是因为子类自己的this对象，必须先通过父类的构造函数完成塑造，得到与父类同样的实例属性和方法，然后对其加工，加上子类自己的实例属性和方法。</p> <p>如果不加super方法，子类就得不到this对象。</p> <p>ES5继承实质是先创造子类的实例对象this，然后再将父类的方法添加到this上面（Parent.apply(this)）;</p> <p>ES6的继承机制完全不同，实质是先将父类实例对象的属性和方法，加到this上面（必须调用super方法），然后再用子类的构造函数修改this。</p> <p>不管有没有显示定义constructor方法，任何一个子类都有constructor方法。</p> <p>在子类的构造函数中，只有调用super之后，才能使用this关键字。这是因为子类实例的构建，基于父类实例，只有super方法才能调用父类实例。</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">class</span> <span class="token class-name">Point</span><span class="token punctuation">{</span>
    <span class="token function">constructor</span><span class="token punctuation">(</span><span class="token parameter">x<span class="token punctuation">,</span>y</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
        <span class="token keyword">this</span><span class="token punctuation">.</span>x <span class="token operator">=</span> x<span class="token punctuation">;</span>
        <span class="token keyword">this</span><span class="token punctuation">.</span>y <span class="token operator">=</span> y<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
<span class="token keyword">class</span> <span class="token class-name">ColorPoint</span> <span class="token keyword">extends</span> <span class="token class-name">Point</span><span class="token punctuation">{</span>
    <span class="token function">constructor</span><span class="token punctuation">(</span><span class="token parameter">x<span class="token punctuation">,</span> y<span class="token punctuation">,</span> color</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
        <span class="token keyword">this</span><span class="token punctuation">.</span>color <span class="token operator">=</span> color<span class="token punctuation">;</span><span class="token comment">//ReferenceError</span>
        <span class="token keyword">super</span><span class="token punctuation">(</span>x<span class="token punctuation">,</span> y<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">this</span><span class="token punctuation">.</span>color <span class="token operator">=</span> color<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
<span class="token comment">//super方法必须放在最前面，才能使用this。</span>
</code></pre></div><h3 id="object-getprototypeof"><a href="#object-getprototypeof" class="header-anchor">#</a> Object.getPrototypeOf()</h3> <p>该方法可以用来从子类上获取父类。</p> <div class="language-js extra-class"><pre class="language-js"><code>Object<span class="token punctuation">.</span><span class="token function">getPrototypeOf</span><span class="token punctuation">(</span>ColorPoint<span class="token punctuation">)</span> <span class="token operator">===</span> Point<span class="token punctuation">;</span>
<span class="token comment">//可以通过这个方法判断，一个类是否继承另一个类</span>
</code></pre></div><h3 id="super关键字-2"><a href="#super关键字-2" class="header-anchor">#</a> super关键字</h3> <p>这个关键字，既可以当做函数使用，也可以当做对象使用。</p> <ol><li><p>super作为函数调用时，代表父类的构造函数。ES6规定，子类的构造函数必须执行一次super函数。</p> <p>super代表了父类的构造函数，但是返回的时子类的实例，即super内部的this指向了B的实例</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token class-name">A</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span><span class="token function">constructor</span><span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">class</span> <span class="token class-name">A</span><span class="token punctuation">{</span>
    <span class="token function">constructor</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
        console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token keyword">new</span><span class="token punctuation">.</span>target<span class="token punctuation">.</span>name<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
<span class="token keyword">class</span> <span class="token class-name">B</span> <span class="token keyword">extends</span> <span class="token class-name">A</span><span class="token punctuation">{</span>
    <span class="token function">constructor</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
        <span class="token keyword">super</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
<span class="token keyword">new</span> <span class="token class-name">A</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//A</span>
<span class="token keyword">new</span> <span class="token class-name">B</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//B</span>
<span class="token comment">//new.target指向当前正在执行的函数，当super()执行时，它指向的时子类B的构造函数，而不是父类A的构造函数。</span>
</code></pre></div><p>作为函数，super只能用在子类的构造函数中</p></li> <li><p>super作为对象，在普通方法中，指向父类的原型对象；静态方法中，指向父类。</p> <p>由于super指向父类的原型对象，所以定义在父类实例上的方法或属性时无法通过super调用的。</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">class</span> <span class="token class-name">A</span><span class="token punctuation">{</span>
    <span class="token function">constructor</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
        <span class="token keyword">this</span><span class="token punctuation">.</span>p <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
<span class="token keyword">class</span> <span class="token class-name">B</span> <span class="token keyword">extends</span> <span class="token class-name">A</span><span class="token punctuation">{</span>
    <span class="token keyword">get</span> <span class="token function">m</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
        <span class="token keyword">return</span> <span class="token keyword">super</span><span class="token punctuation">.</span>p<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
<span class="token keyword">let</span> b <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">B</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
b<span class="token punctuation">.</span>m<span class="token punctuation">;</span><span class="token comment">//undefined</span>
<span class="token comment">//若定义在父类的原型对象上，则可以访问</span>
<span class="token class-name">A</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span>x <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span>
</code></pre></div><p>如果陒对象，用在静态方法之中，super将指向父类，而不是父类的原型对象。</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">class</span> <span class="token class-name">Parent</span><span class="token punctuation">{</span>
    <span class="token keyword">static</span> <span class="token function">myMethod</span><span class="token punctuation">(</span><span class="token parameter">msg</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
        cosnole<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'static'</span><span class="token punctuation">,</span> msg<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    
    <span class="token function">myMethod</span><span class="token punctuation">(</span><span class="token parameter">msg</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
        console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'instance'</span><span class="token punctuation">,</span> msg<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token keyword">class</span> <span class="token class-name">Child</span> <span class="token keyword">extends</span> <span class="token class-name">Parent</span><span class="token punctuation">{</span>
    <span class="token keyword">static</span> <span class="token function">myMethod</span><span class="token punctuation">(</span><span class="token parameter">msg</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
        <span class="token keyword">super</span><span class="token punctuation">.</span><span class="token function">myMethod</span><span class="token punctuation">(</span>msg<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    
    
    <span class="token function">myMethod</span><span class="token punctuation">(</span><span class="token parameter">msg</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
        console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>msg<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

Child<span class="token punctuation">.</span><span class="token function">myMethod</span><span class="token punctuation">(</span><span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//static 1</span>
<span class="token keyword">var</span> child <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Child</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
child<span class="token punctuation">.</span><span class="token function">myMethod</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//instance 2</span>
</code></pre></div><p>子类的静态方法中通过super调用父类的方法时，方法内部的this指向当前的子类，而不是子类的实例。</p></li></ol> <p>注意：使用super的时候，必须显示指定是作为函数，还是作为对象。</p> <h3 id="类的prototype属性和-proto-属性"><a href="#类的prototype属性和-proto-属性" class="header-anchor">#</a> 类的prototype属性和__proto__属性</h3> <p>大多数浏览器的ES5之前，每个对象都有__proto__属性，指向对应的构造函数prototype属性。</p> <p>Class作为构造函数的语法糖，同时又prototype属性和__proto__属性，所以同时存在两天继承链。</p> <ul><li>子类的__proto__属性，表示构造函数的继承，总是指向父类</li> <li>子类的prototype属性的__proto__属性，表示方法的继承，总是指向父类的prototype属性。</li></ul> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">class</span> <span class="token class-name">A</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>
<span class="token keyword">class</span> <span class="token class-name">B</span> <span class="token keyword">extends</span> <span class="token class-name">A</span><span class="token punctuation">{</span><span class="token punctuation">}</span>
<span class="token constant">B</span><span class="token punctuation">.</span>__proto__ <span class="token operator">===</span> <span class="token constant">A</span><span class="token punctuation">;</span><span class="token comment">//true</span>
<span class="token class-name">B</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span>__proto__ <span class="token operator">===</span> <span class="token class-name">A</span><span class="token punctuation">.</span>prototype
</code></pre></div><p>这是因为类的继承按照下面方式实现的：</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">class</span> <span class="token class-name">A</span><span class="token punctuation">{</span><span class="token punctuation">}</span>
<span class="token keyword">class</span> <span class="token class-name">B</span><span class="token punctuation">{</span><span class="token punctuation">}</span>
<span class="token comment">//B的实例继承A的实例</span>
Object<span class="token punctuation">.</span><span class="token function">setPrototypeOf</span><span class="token punctuation">(</span><span class="token class-name">B</span><span class="token punctuation">.</span>prototype<span class="token punctuation">,</span> <span class="token class-name">A</span><span class="token punctuation">.</span>prototype<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">//B继承了A的静态属性</span>
Object<span class="token punctuation">.</span><span class="token function">setPtototypeOf</span><span class="token punctuation">(</span><span class="token constant">B</span><span class="token punctuation">,</span> <span class="token constant">A</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">const</span> b <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">B</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><p>Object.setPrototypeOf方法的实现</p> <div class="language-js extra-class"><pre class="language-js"><code>Object<span class="token punctuation">.</span><span class="token function-variable function">setPrototypeOf</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">obj<span class="token punctuation">,</span> proto</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
    obj<span class="token punctuation">.</span>__proto__ <span class="token operator">=</span> proto<span class="token punctuation">;</span>
    <span class="token keyword">return</span> obj<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><p><strong>两条继承链</strong>：</p> <p>作为一个对象，子类(B)的原型(__proto__属性）时父类A；</p> <p>作为一个构造函数，子类B的原型对象（prototype属性）是父类的原型对象的实例；</p> <h3 id="实例的-proto-属性"><a href="#实例的-proto-属性" class="header-anchor">#</a> 实例的__proto__属性</h3> <p>子类实例的__proto__属性的__proto__属性，指向父类实例的__proto__，即子类的原型的原型，是父类的原型。</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">var</span> p1 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Point</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">var</span> p2 <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">ColorPoint</span><span class="token punctuation">(</span><span class="token number">2</span><span class="token punctuation">,</span><span class="token number">3</span><span class="token punctuation">,</span><span class="token string">'red'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
p2<span class="token punctuation">.</span>__proto__<span class="token punctuation">.</span>__proto__ <span class="token operator">===</span> p1<span class="token punctuation">.</span>__proto__
</code></pre></div><p>所以通过子类实例的__proto__.__proto__属性，可以修改父类实例的行为。</p> <div class="language-js extra-class"><pre class="language-js"><code>p2<span class="token punctuation">.</span>__proto__<span class="token punctuation">.</span>__proto__<span class="token punctuation">.</span><span class="token function-variable function">printName</span> <span class="token operator">=</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'test'</span><span class="token punctuation">)</span><span class="token punctuation">}</span>
</code></pre></div><h3 id="原生构造函数的继承"><a href="#原生构造函数的继承" class="header-anchor">#</a> 原生构造函数的继承</h3> <p>原生构造函数是指语言内置的构造函数，通常用来生成数据结构：</p> <ul><li>Boolean</li> <li>Number</li> <li>String</li> <li>Array</li> <li>Date</li> <li>Function</li> <li>RegExp</li> <li>Error</li> <li>Object</li></ul> <p>ES6允许继承原生的构造函数定义子类，因为ES6是先新建父类的实例对象this，然后再用子类的构造函数修身this，使得父类的所有行为都可以继承。</p> <h3 id="mixin模式的实现"><a href="#mixin模式的实现" class="header-anchor">#</a> Mixin模式的实现</h3> <p>Mixin是指多个对象合成一个新的对象，新的对象具有各个组成成员的接口。</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">function</span> <span class="token function">mix</span><span class="token punctuation">(</span><span class="token parameter"><span class="token operator">...</span>mixins</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
    <span class="token keyword">class</span> <span class="token class-name">Mix</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
        <span class="token function">constructor</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
            <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">let</span> mixin <span class="token keyword">of</span> mixins<span class="token punctuation">)</span><span class="token punctuation">{</span>
                <span class="token function">copyProperties</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">,</span> <span class="token keyword">new</span> <span class="token class-name">mixin</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//拷贝实例属性</span>
            <span class="token punctuation">}</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
    
    <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">let</span> mixin <span class="token keyword">of</span> mixins<span class="token punctuation">)</span><span class="token punctuation">{</span>
        <span class="token function">copyProperties</span><span class="token punctuation">(</span>Mix<span class="token punctuation">,</span> mixin<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token function">copyProperties</span><span class="token punctuation">(</span><span class="token class-name">Mix</span><span class="token punctuation">.</span>prototype<span class="token punctuation">,</span> mixin<span class="token punctuation">.</span>prototype<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">return</span> Mix
<span class="token punctuation">}</span>

<span class="token keyword">function</span> <span class="token function">copyProperties</span><span class="token punctuation">(</span><span class="token parameter">target<span class="token punctuation">,</span> source</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
    <span class="token keyword">for</span><span class="token punctuation">(</span><span class="token keyword">let</span> key <span class="token keyword">of</span> Reflect<span class="token punctuation">.</span><span class="token function">ownKeys</span><span class="token punctuation">(</span>source<span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
        <span class="token keyword">if</span><span class="token punctuation">(</span>key <span class="token operator">!==</span> <span class="token string">'constructor'</span> <span class="token operator">&amp;&amp;</span> key <span class="token operator">!==</span> <span class="token string">'prototype'</span> <span class="token operator">&amp;&amp;</span> key <span class="token operator">!==</span> <span class="token string">'name'</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
            <span class="token keyword">let</span> desc <span class="token operator">=</span> Object<span class="token punctuation">.</span><span class="token function">getOwnPropertyDescriptor</span><span class="token punctuation">(</span>source<span class="token punctuation">,</span> key<span class="token punctuation">)</span><span class="token punctuation">;</span>
            Object<span class="token punctuation">.</span><span class="token function">defineProperty</span><span class="token punctuation">(</span>target<span class="token punctuation">,</span> key<span class="token punctuation">,</span> desc<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

</code></pre></div><h2 id="module的语法"><a href="#module的语法" class="header-anchor">#</a> Module的语法</h2> <p>ES6之前主要模块的加载方案是CommonJS 和AMD两种，前者用于服务器，后者用于浏览器。</p> <p>ES6模块设计思想是尽量的静态化，使得编译时就能确定模块的依赖关系，以及输入和输出的遍历，CommonJS和AMD只能在运行时确定。</p> <p>ES6模块不是对象，而是通过export命令显示指定输出代码，在通过import命令输入。</p> <p>由于ES6模块是编译时加载，使得静态分析称为可能，这样救恩能够拓宽JavaScript语法。</p> <p>ES6模块的优点：</p> <ul><li>不再需要UMD模块格式了，浏览器和服务器都支持</li> <li>浏览器的新API就能用模块提供，不必做成全局变量或navigator对象的属性</li> <li>不再需要对象作为命名空间</li></ul> <h3 id="严格模式-2"><a href="#严格模式-2" class="header-anchor">#</a> 严格模式</h3> <p>ES6模块自动采用严格模式。</p> <p>严格模式主要有一下限制：</p> <ul><li>变量必须声明后使用</li> <li>函数的参数不能有同名属性</li> <li>不能使用with语句</li> <li>不能对只读属性赋值</li> <li>不能使用前缀0表示八进制</li> <li>不能删除不可删除属性</li> <li>不能删除变量delete prop</li> <li>eval不会在它的外层作用域引入变量</li> <li>eval和arguments不能被重新赋值</li> <li>arguments不会自动反映函数的变化</li> <li>不能使用arguments.callee</li> <li>不能使用arguments.caller</li> <li>禁止this指向全局对象</li> <li>不能使用fn.caller和fn.arguments获取函数调用的堆栈</li> <li>增加保留字protected、static、interface</li></ul> <h3 id="export-命令"><a href="#export-命令" class="header-anchor">#</a> export 命令</h3> <p>模块功能主要由两个命令构成：export和import。</p> <p>一个模块就是一个独立的文件。该文件内部所有的遍历，外部无法获取。</p> <p>export可以输出遍历、函数、类，可以使用as关键字重命名。</p> <p>export命令规定的是对外的接口，必须与模块内部的遍历建立一一对应关系。</p> <p>export语句输出的接口，与其对应的值是动态绑定关系，即通过该接口，可以取到模块内部实时的值。</p> <h3 id="import命令"><a href="#import命令" class="header-anchor">#</a> import命令</h3> <p>使用export命令定义了模块的对外接口以后，其他JS文件就可以通过import命令加载这个模块</p> <p>import命令可以使用关键字as重命名。</p> <p>import命令输入的变量都是只读的，因为它的本质是输入接口，即不允许在加载模块的脚本里面，改写接口。</p> <p>import命令具有提升效果，会提升到整个模块的头部，首先执行。</p> <p>由于import是静态执行，所以不能使用表达式和变量，这些只有在运行时才能得到结果的语法结构。</p> <h3 id="模块的整体加载"><a href="#模块的整体加载" class="header-anchor">#</a> 模块的整体加载</h3> <p>除了制定加载某个输出值，也可以整体加载，即用星号指定一个对象。</p> <p>模块整体加载所在的那个对象，应该是可以静态分析的，所以不允许运行时改变。</p> <h3 id="export-default命令"><a href="#export-default命令" class="header-anchor">#</a> export default命令</h3> <p>为模块指定默认输出。</p> <p>本质上，export default就是输出一个叫做default的变量或方法，然后系统允许你为它取任意名字</p> <h3 id="export-和-import的复合写法"><a href="#export-和-import的复合写法" class="header-anchor">#</a> export 和 import的复合写法</h3> <p>在一个模块中，先输入后输出同一个模块，import语句可以与export语句写在一起</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">export</span> <span class="token punctuation">{</span> foo<span class="token punctuation">,</span> bar <span class="token punctuation">}</span> <span class="token keyword">from</span> <span class="token string">'my_module'</span>
</code></pre></div><h3 id="模块的继承"><a href="#模块的继承" class="header-anchor">#</a> 模块的继承</h3> <p>模块之间也可以继承。</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">export</span> <span class="token operator">*</span> <span class="token keyword">from</span> <span class="token string">'circle'</span><span class="token punctuation">;</span>
<span class="token keyword">export</span> <span class="token keyword">default</span> <span class="token keyword">function</span><span class="token punctuation">(</span><span class="token parameter">x</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
    <span class="token keyword">return</span> Math<span class="token punctuation">.</span><span class="token function">exp</span><span class="token punctuation">(</span>x<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><h3 id="跨模块常量"><a href="#跨模块常量" class="header-anchor">#</a> 跨模块常量</h3> <p>若设置跨模块的常量或一个值要被多个模块共享，可以按如下写法：</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">export</span> <span class="token keyword">const</span> <span class="token constant">A</span> <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>
<span class="token keyword">export</span> <span class="token keyword">const</span> <span class="token constant">B</span> <span class="token operator">=</span> <span class="token number">2</span><span class="token punctuation">;</span>
<span class="token keyword">export</span> <span class="token keyword">const</span> <span class="token constant">C</span> <span class="token operator">=</span> <span class="token number">3</span><span class="token punctuation">;</span>
</code></pre></div><h3 id="import"><a href="#import" class="header-anchor">#</a> import()</h3> <p>import命令会被JavaScript引擎静态分析，先于模块内部的其他语句执行，所以import命令无法取代require动态加载功能。</p> <p>ES2020引入了import()函数，支持动态加载。</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">import</span><span class="token punctuation">(</span>specifier<span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><p>import命令能够接受什么参数，import()函数就能够接受什么参数，主要区别是后者是动态加载。</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">const</span> main <span class="token operator">=</span> document<span class="token punctuation">.</span><span class="token function">querySelector</span><span class="token punctuation">(</span><span class="token string">'main'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">import</span><span class="token punctuation">(</span><span class="token template-string"><span class="token template-punctuation string">`</span><span class="token string">./section-modules/</span><span class="token interpolation"><span class="token interpolation-punctuation punctuation">${</span>someVariable<span class="token interpolation-punctuation punctuation">}</span></span><span class="token string">.js</span><span class="token template-punctuation string">`</span></span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">then</span><span class="token punctuation">(</span><span class="token parameter">module</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
    module<span class="token punctuation">.</span><span class="token function">loadPageInto</span><span class="token punctuation">(</span>main<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">catch</span><span class="token punctuation">(</span><span class="token parameter">err</span><span class="token operator">=&gt;</span><span class="token punctuation">{</span>
    main<span class="token punctuation">.</span>textConent <span class="token operator">=</span> err<span class="token punctuation">.</span>message<span class="token punctuation">;</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span>
</code></pre></div><p>适合场合：</p> <ul><li>按需加载，可以在需要的时候，再加载某个模块</li> <li>条件加载，可以将import()函数放在if代码块，根据不同条件加载不同模块</li> <li>动态的模块路径</li></ul> <p>注意：import()加载模块成功后，这个模块会作为一个对象，当做then方法的参数，所以可以使用对象解构赋值的语法。</p> <h2 id="module的加载实现"><a href="#module的加载实现" class="header-anchor">#</a> Module的加载实现</h2> <p>默认情况下，浏览器是同步加载JavaScript脚本，即渲染引擎遇到&lt;script&gt;标签就会停下来，等到执行完脚本，继续向下渲染，如果是外部脚本，还必须加入脚本下载时间。</p> <p>浏览器可以通过defer或者async进行异步加载。</p> <p>defer要等到整个页面在内存中正常渲染接受，才会执行。</p> <p>async一旦下载完毕，渲染引擎就会中断渲染，执行这个脚本以后，继续渲染。</p> <p>若多个defer，会按照他们在页面中出现的顺序加载。</p> <p>若多个async，则不能保证加载顺序。</p> <p><strong>加载规则</strong>，浏览器加载ES6模块，需要加入type=&quot;module&quot;属性</p> <p>浏览器对于带有type=&quot;module&quot;的脚本，都是异步加载，不会造成浏览器堵塞，即等到整个页面渲染完，再执行模块脚本，等同于打开了defer属性。</p> <p>若页面上多个type=&quot;module&quot;，则会按照页面出现顺序依次执行。</p> <p>若同时使用type=&quot;module&quot; async 则不会按照顺序执行，只要该模块加载完成，立即执行。</p> <p>ES6模块也允许内嵌在网页中，语法行为与外部加载脚本一致，对于外部的模块脚本，有几点注意：</p> <ul><li>代码是在模块作用域中允许，而不是全局作用域。模块内部的顶层遍历，外部不可见</li> <li>模块脚本自动采用严格模式</li> <li>模块之中，可以使用import命令加载其他模块，也可以使用export输出对外接口</li> <li>模块之中，顶层this关键字返回undefined，不是指向window</li> <li>同一个模块如果加载多次，只执行一次</li></ul> <p><strong>利用this等于undefined这个语法点，可以侦测当前代码是否在ES6模块之中</strong></p> <h3 id="es6模块和commonjs模块的差异"><a href="#es6模块和commonjs模块的差异" class="header-anchor">#</a> ES6模块和CommonJS模块的差异</h3> <p>两个模块完全不同，有两个重大差异：</p> <ul><li>CommonJS模块输出的是一个值得拷贝，ES6输出的时值得引用</li> <li>CommonJS模块是运行时加载，ES6模块是编译时输出接口</li></ul> <p>第二个差异是因为CommonJS加载一个对象，即module.exports属性，该对象只有在脚本运行完才会生成。</p> <p>ES6模块不是对象，对外接口只是一种静态定义，在代码静态解析阶段就会生成。</p> <p>CommonJS模块输出的时值得拷贝，即一旦输出一个值，模块内部的变化，不会影响到这个值。</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token comment">//lib.js</span>
<span class="token keyword">var</span> counter <span class="token operator">=</span> <span class="token number">3</span><span class="token punctuation">;</span>
<span class="token keyword">function</span> <span class="token function">incCounter</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
    counter<span class="token operator">++</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
module<span class="token punctuation">.</span>exports <span class="token operator">=</span> <span class="token punctuation">{</span>
    counter<span class="token punctuation">,</span>
    incCounter
<span class="token punctuation">}</span>
<span class="token comment">//main.js</span>
<span class="token keyword">var</span> mod <span class="token operator">=</span> <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">'./lib.js'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>mod<span class="token punctuation">.</span>counter<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//3</span>
mod<span class="token punctuation">.</span><span class="token function">incCounter</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>mod<span class="token punctuation">.</span>counter<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">///3</span>
</code></pre></div><p>lib加载后，内部变化影响不到输出的mod.counter。因为mod.counter是一个原始类型的值，会被缓存。除非写成一个函数，才能得到内部变动后的值。</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token comment">//lib.js</span>
module<span class="token punctuation">.</span>exports <span class="token operator">=</span> <span class="token punctuation">{</span>
    <span class="token keyword">get</span> <span class="token function">counter</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>
        <span class="token keyword">return</span> counter<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
<span class="token comment">//实际上，counter属性是一个取值函数，此时就能正确取到内部变化了。</span>
</code></pre></div><p>ES6 模块的允许机制不一样，JS引擎对脚本静态分析的时候，遇到模块加载命令import，就会生成一个只读引用，等到脚本真正执行时，根据这个只读引用，到被加载的模块里面取值。原始值变了，imoprt加载的值也会变。</p> <p>ES6模块是动态引用，并不会缓存值，模块里面变了绑定其所在的模块。</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token comment">//lib.js</span>
<span class="token keyword">export</span> <span class="token keyword">let</span> counter <span class="token operator">=</span> <span class="token number">3</span><span class="token punctuation">;</span>
<span class="token keyword">export</span> <span class="token keyword">function</span> <span class="token function">incCounter</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span>counter<span class="token operator">++</span><span class="token punctuation">}</span>

<span class="token comment">//main.js</span>
<span class="token keyword">import</span> <span class="token punctuation">{</span>counter<span class="token punctuation">,</span> incCounter<span class="token punctuation">}</span> <span class="token keyword">from</span> <span class="token string">'./lib'</span><span class="token punctuation">;</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>counter<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//3</span>
<span class="token function">incCounter</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>counter<span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token comment">//4</span>
</code></pre></div><p>ES6模块的输入变了counter是活的，完全反应其所在模块lib.js内部的变化。</p> <p>ES6输入的模块变量只是一个'符号链接'，所以是只读的，对他重新赋值会报错。</p> <h3 id="nodejs加载"><a href="#nodejs加载" class="header-anchor">#</a> NodeJS加载</h3> <p>NodeJS对ES6模块处理，目前解决方案，将两者分开，ES6和CommonJS采用各自的加载方案。从v13.2开始，NodeJS默认开启ES6模块支持</p> <p>ES6模块采用.mjs后缀文件名。只要在文件里面使用import或export命令，必须采用.mjs后缀名。</p> <p>NodeJS遇到.mjs文件，就会认为是ES6模块，默认开启严格模式。</p> <p>如果不希望改后缀，则可以在项目package.json文件中，指定type字段为module，一旦设置，该目录里面的JS脚本，就被解释用ES6模块。如果此时用CommonJS模块，需将CommonJS文件后缀名改为.cjs。</p> <p>ES6模块与CommonJS模块尽量不要混用。</p> <p><strong>main字段</strong>，package.json文件有两个字段可以指定模块的入口文件：main和exports。</p> <p>比较简单的模块，可以只使用main，指定模块加载的入口文件。</p> <p><strong>exports字段</strong>，优先级高与main，有多种用法：</p> <ul><li><p>子目录别名</p> <p>exports字段可以指定脚本或子目录的别名，定义别名为submodule，可以从别名加载文件</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token punctuation">{</span>
    <span class="token string">&quot;exports&quot;</span><span class="token operator">:</span><span class="token punctuation">{</span>
        <span class="token string">&quot;./submodule&quot;</span><span class="token operator">:</span> <span class="token string">'./src/submodule.js'</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token keyword">import</span> submodule <span class="token keyword">from</span> <span class="token string">'es-module-package/submodule'</span>

<span class="token comment">//目录别名</span>
<span class="token punctuation">{</span>
    <span class="token string">&quot;exports&quot;</span><span class="token operator">:</span><span class="token punctuation">{</span>
        <span class="token string">&quot;./features&quot;</span><span class="token operator">:</span><span class="token string">&quot;./src/features&quot;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token keyword">import</span> feature <span class="token keyword">from</span> <span class="token string">'es-module-package/features/x.js'</span>
</code></pre></div></li> <li><p>main的别名</p> <p>exports字段的别名如果是.，就代表模块的主入口，优先级高于mian字段，并且可以直接写成exports字段的值</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token punctuation">{</span>
    <span class="token string">&quot;main&quot;</span><span class="token operator">:</span> <span class="token string">'./main-legacy.cjs'</span><span class="token punctuation">,</span>
     <span class="token string">&quot;exports&quot;</span><span class="token operator">:</span> <span class="token punctuation">{</span>
        <span class="token string">&quot;.&quot;</span><span class="token operator">:</span><span class="token string">&quot;main-modern.cjs&quot;</span>
     <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div></li> <li><p>条件加载</p> <p>利用.这个别名，可以为ES6模块和CommonJS指定不同入口。目前，这个功能需要在NodeJS允许的时候，打开--experimental-conditional-exports标志。</p></li></ul> <p>ES6模块加载CommonJS模块，一个模块同时支持ES6和CommonJS两种格式的常见方法是，package.json文件<strong>main</strong>字段指定CommonJS入口，给NodeJS使用，<strong>module</strong>字段指定ES6模块入口，给打包工具使用。</p> <div class="language-json extra-class"><pre class="language-json"><code><span class="token punctuation">{</span>
    <span class="token property">&quot;type&quot;</span><span class="token operator">:</span> <span class="token string">&quot;module&quot;</span><span class="token punctuation">,</span>
    <span class="token property">&quot;main&quot;</span><span class="token operator">:</span> <span class="token string">&quot;./index.cjs&quot;</span><span class="token punctuation">,</span>
    <span class="token property">&quot;exports&quot;</span><span class="token operator">:</span> <span class="token punctuation">{</span>
        <span class="token property">&quot;require&quot;</span><span class="token operator">:</span> <span class="token string">&quot;./index.cjs&quot;</span><span class="token punctuation">,</span>
        <span class="token property">&quot;default&quot;</span><span class="token operator">:</span> <span class="token string">&quot;./wrapper.mjs&quot;</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><p>注意： import命令加载CommonJS模块，只能整体加载，不能只加载单一的输出项。</p> <p>使用NodeJS内置的module.createRequire()方法</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">import</span> <span class="token punctuation">{</span> createRequire <span class="token punctuation">}</span> <span class="token keyword">from</span> <span class="token string">'module'</span><span class="token punctuation">;</span>
<span class="token keyword">const</span> require <span class="token operator">=</span> <span class="token function">require</span><span class="token punctuation">(</span><span class="token keyword">import</span><span class="token punctuation">.</span>meta<span class="token punctuation">.</span>url<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">const</span> cjs <span class="token operator">=</span> <span class="token function">require</span><span class="token punctuation">(</span><span class="token string">'./cjs.cjs'</span><span class="token punctuation">)</span>
</code></pre></div><p>通过ES6模块通过module.createRequire()方法加载CommonJS模块</p> <p>CommonJS模块加载ES6模块</p> <p>CommonJS的require命令不能加载ES6模块，只能使用import方法加载</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token punctuation">(</span><span class="token keyword">async</span> <span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token operator">=&gt;</span><span class="token punctuation">{</span>
    <span class="token keyword">await</span> <span class="token keyword">import</span><span class="token punctuation">(</span><span class="token string">''</span><span class="token punctuation">.</span><span class="token operator">/</span>my<span class="token operator">-</span>app<span class="token punctuation">.</span>js<span class="token punctuation">)</span>
<span class="token punctuation">}</span><span class="token punctuation">)</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><p>ES6模块的加载路径必须给出脚本的完整路径，不能省略脚本的后缀名。</p> <p>import命令和package.json文件的main字段如果省略脚本的后缀名，会报错。</p> <p>为了与浏览器的import加载规则相同，NodeJS的.mjs文件支持URL路径。</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">import</span> <span class="token string">'./foo.mjs?query=1'</span><span class="token punctuation">;</span><span class="token comment">//传入参数1</span>
</code></pre></div><p>目前NodeJS的imporrt命令只支持加载本地模块file协议和data协议，不支持远程加载模块。</p> <p>NodeJS规定ES6模块中不能使用CommonJS模块的特有内部变量：</p> <ul><li>this 关键字，ES6中指向undefined</li> <li>arguments</li> <li>require</li> <li>module</li> <li>exports</li> <li>__filename</li> <li>__dirname</li></ul> <h3 id="循环加载"><a href="#循环加载" class="header-anchor">#</a> 循环加载</h3> <p>指a脚本的执行依赖b脚本，b脚本的执行依赖a脚本。</p> <p>CommonJS模块加载原理：</p> <p>CommonJS的一个模块是一个脚本文件，require命令第一次加载该脚本，就会执行整个脚本，并在内存中生成一个对象。以后需要用到这个模块的时候，回到生成对象的exports属性上取值，即使再次执行，也不会再次执行该模块，而是到缓存中取值。</p> <p>CommonJS模块无论加载多少次，都只会第一次加载时运行一次，以后加载，就返回第一次运行的结果，除非手动清除系统缓存。</p> <p>CommonJS输入的是被输出值得拷贝，不是引用。</p> <p>由于CommonJS模块遇到循环加载时，返回的是当前已经指向的部分值，而不是代码全部执行后的值。</p> <p>ES6的模块是动态引用，如果使用import从一个模块加载遍历，那些变量不会被缓存，而是成为一个指向被加载mode引用，需要开发者自己保证。</p> <p>可以用函数来解决，因为函数具有提升作用，在执行时，已经完成了定义。</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token comment">//a.mjs</span>
<span class="token keyword">import</span> <span class="token punctuation">{</span> bar <span class="token punctuation">}</span> <span class="token keyword">from</span> <span class="token string">'./b'</span><span class="token punctuation">;</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'a.mjs'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token function">bar</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">function</span> <span class="token function">foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">{</span><span class="token keyword">return</span> <span class="token string">'foo'</span><span class="token punctuation">}</span>
<span class="token keyword">export</span> <span class="token punctuation">{</span>foo<span class="token punctuation">}</span>

<span class="token comment">//b.js</span>
<span class="token keyword">import</span> <span class="token punctuation">{</span> foo <span class="token punctuation">}</span> <span class="token keyword">from</span> <span class="token string">'./a'</span><span class="token punctuation">;</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token string">'b.mjs'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token function">foo</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token keyword">function</span> <span class="token function">bar</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span> <span class="token keyword">return</span> <span class="token string">'bar'</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
<span class="token keyword">export</span> <span class="token punctuation">{</span> bar <span class="token punctuation">}</span>
</code></pre></div><div class="language-shell extra-class"><pre class="language-shell"><code>node --experimental-modules a.mjs
</code></pre></div><p>执行过程：</p> <p>首先执行a.mjs以后，引擎发现加载b.mjs，所以会优先执行b.mjs，在执行a.mjs。</p> <p>在执行b.mjs时，已知从a.mjs输入了foo接口，这是不会去执行a.mjs，而是认为这个接口已经存在，继续往下执行。</p></div> <footer class="page-edit"><!----> <!----></footer> <!----> </main></div><div class="global-ui"><!----><!----></div></div>
    <script src="/note/assets/js/app.492a4f88.js" defer></script><script src="/note/assets/js/2.7a960a6a.js" defer></script><script src="/note/assets/js/6.c5848a03.js" defer></script><script src="/note/assets/js/3.ededa1a2.js" defer></script>
  </body>
</html>
